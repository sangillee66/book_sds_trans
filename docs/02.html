<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>공간데이터사이언스 개론 - 2&nbsp; 좌표계</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./03.html" rel="next">
<link href="./01.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script><link rel="stylesheet" href="styles.css">
</head>
<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <a class="flex-grow-1 no-decor" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
          <h1 class="quarto-secondary-nav-title"><span id="sec-coord" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">좌표계</span></span></h1>
        </a>     
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">공간데이터사이언스 개론</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/sangillee66/book_sds_trans" title="소스 코드" class="quarto-navigation-tool px-1" aria-label="소스 코드"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">서장</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">공간데이터</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">시작하기</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">좌표계</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">지오메트리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">구면 지오메트리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">속성과 서포트</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">데이터 큐브</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">공간데이터사이언스와 R</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">sf와 stars 패키지</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">공간데이터의 플로팅</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">대규모 데이터와 클라우드 네이티브</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">공간통계분석과 공간모델링</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">공간데이터의 통계적 모형화</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">포인트 패턴 분석</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">공간적 내삽</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">다변량 및 시공간 지구통계학</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">근접성과 에어리어 데이터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">공간적 자기상관 측도</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">공간적 회귀분석</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./17.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">공간계량경제학적 모형</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">부록</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./A.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">예전 R 공간 패키지</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./B.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">R 기초</span></span></a>
  </div>
</li>
      </ul>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">목차</h2>
   
  <ul>
<li><a href="#%EB%AC%BC%EB%A6%AC%EB%9F%89-%EB%8B%A8%EC%9C%84-%EB%8D%B0%EC%9D%B4%ED%85%80" id="toc-물리량-단위-데이텀" class="nav-link active" data-scroll-target="#%EB%AC%BC%EB%A6%AC%EB%9F%89-%EB%8B%A8%EC%9C%84-%EB%8D%B0%EC%9D%B4%ED%85%80"><span class="header-section-number">2.1</span> 물리량, 단위, 데이텀</a></li>
  <li>
<a href="#%ED%83%80%EC%9B%90%EC%B2%B4-%EC%A2%8C%ED%91%9C%EA%B3%84" id="toc-타원체-좌표계" class="nav-link" data-scroll-target="#%ED%83%80%EC%9B%90%EC%B2%B4-%EC%A2%8C%ED%91%9C%EA%B3%84"><span class="header-section-number">2.2</span> 타원체 좌표계</a>
  <ul class="collapse">
<li><a href="#%EA%B5%AC%EC%B2%B4-%ED%98%B9%EC%9D%80-%ED%83%80%EC%9B%90%EC%B2%B4-%EC%A2%8C%ED%91%9C" id="toc-구체-혹은-타원체-좌표" class="nav-link" data-scroll-target="#%EA%B5%AC%EC%B2%B4-%ED%98%B9%EC%9D%80-%ED%83%80%EC%9B%90%EC%B2%B4-%EC%A2%8C%ED%91%9C"><span class="header-section-number">2.2.1</span> 구체 혹은 타원체 좌표</a></li>
  <li><a href="#%ED%88%AC%EC%98%81-%EC%A2%8C%ED%91%9C%EA%B3%84%EC%99%80-%EA%B1%B0%EB%A6%AC" id="toc-투영-좌표계와-거리" class="nav-link" data-scroll-target="#%ED%88%AC%EC%98%81-%EC%A2%8C%ED%91%9C%EA%B3%84%EC%99%80-%EA%B1%B0%EB%A6%AC"><span class="header-section-number">2.2.2</span> 투영 좌표계와 거리</a></li>
  <li><a href="#%ED%95%9C%EC%A0%95-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EB%B9%84%ED%95%9C%EC%A0%95-%EA%B3%B5%EA%B0%84" id="toc-한정-공간과-비한정-공간" class="nav-link" data-scroll-target="#%ED%95%9C%EC%A0%95-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EB%B9%84%ED%95%9C%EC%A0%95-%EA%B3%B5%EA%B0%84"><span class="header-section-number">2.2.3</span> 한정 공간과 비한정 공간</a></li>
  </ul>
</li>
  <li><a href="#crs" id="toc-crs" class="nav-link" data-scroll-target="#crs"><span class="header-section-number">2.3</span> CRS</a></li>
  <li><a href="#proj%EC%99%80-%EC%A7%80%EB%8F%84-%EC%A0%95%ED%99%95%EB%8F%84" id="toc-proj와-지도-정확도" class="nav-link" data-scroll-target="#proj%EC%99%80-%EC%A7%80%EB%8F%84-%EC%A0%95%ED%99%95%EB%8F%84"><span class="header-section-number">2.4</span> PROJ와 지도 정확도</a></li>
  <li><a href="#wkt-2" id="toc-wkt-2" class="nav-link" data-scroll-target="#wkt-2"><span class="header-section-number">2.5</span> WKT-2</a></li>
  <li><a href="#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C" id="toc-연습문제" class="nav-link" data-scroll-target="#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C"><span class="header-section-number">2.6</span> 연습문제</a></li>
  </ul><div class="toc-actions"><ul><li><a href="https://github.com/sangillee66/book_sds_trans/issues/new" class="toc-action"><i class="bi bi-github"></i>이슈 보고</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<h1 class="title d-none d-lg-block"><span id="sec-coord" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">좌표계</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">2025년 8월 16일</p>
    </div>
  </div>
    
  </div>
  


</header><p>“<em>데이터는 단순한 숫자가 아니라 맥락을 가진 숫자이다.</em>”: “<em>데이터 분석에서 맥락은 의미를 부여한다.</em>”(Cobb and Moore 1997)</p>
<p>포인트, 라인, 폴리곤, 커버리지, 그리드와 같은 지오메트리를 이해하기에 앞서, 좌표계(coordinate system)를 먼저 살펴보는 것이 유용하다. 이를 통해 좌표값이 무엇을 의미하는지 명확히 이해할 수 있다. 공간데이터에서 관측 개체의 위치는 좌표값으로 표현되며, 이 좌표값은 특정 좌표계에 의해 규정된다. 좌표계에는 여러 유형이 있으며, 그중 중요한 구분은 2차원 또는 3차원 공간의 좌표값이 서로 직교하는 두 축을 기준으로 정의되는지(데카르트 좌표계), 아니면 거리와 방향을 기준으로 정의되는지(극 좌표계, 구체 좌표계, 타원체 좌표계)이다. 모든 관측치는 공간상의 위치뿐만 아니라 관측 시점과도 결부되므로, 시간 좌표계에 대해서도 간단히 언급할 것이다. 또한 단위와 데이텀에 대해 설명하기에 앞서, 먼저 <em>물리량</em>(quantity)의 개념을 간략히 살펴본다.</p>
<section id="물리량-단위-데이텀" class="level2" data-number="2.1"><h2 data-number="2.1" class="anchored" data-anchor-id="물리량-단위-데이텀">
<span class="header-section-number">2.1</span> 물리량, 단위, 데이텀</h2>
<p>VIM(‘International Vocabulary of Metrology(국제 측정학 어휘)’, BIPM et al.&nbsp;2012)에 따르면 <em>물리량</em>(quantity)은 “현상, 물체, 또는 물질의 성질 중, 그 성질이 수치와 기준에 의거해 표현될 수 있는 크기(magnitude)를 가진 것”으로 정의된다.(역자주: 물리량은 단순한 수량이 아니라 측정 가능한 속성을 의미한다.) 여기서 “기준은 측정 단위, 측정 절차, 기준 물질 또는 이러한 것들의 조합일 수 있다.”라고 기술한다. 모든 데이터가 물리량으로 구성되어 있는지에 대해서는 논란의 여지가 있을 수 있지만, 적절한 데이터 처리를 위해서는 수치(또는 기호)가 무엇을 의미하는지, 특히 수치가 어떤 기준에 근거하고 있는지에 대한 정보가 반드시 필요하다는 점에 대해서는 논란의 여지가 없다.</p>
<p>측정 시스템은 기본 물리량에 대한 기본단위와, 기본 단위를 조합하여 정의한 파생단위로 구성된다. 예를 들어, SI 단위계(Bureau International des Poids et Mesures 2006)는 다음 일곱 가지 기본 단위로 이루어져 있다. 길이(미터, m), 질량(킬로그램, kg), 시간(초, s), 전류(암페어, A), 열역학적 온도(켈빈, K), 물질의 양(몰, mol), 그리고 광도(칸델라, cd)이다. 파생단위는 기본단위의 정수 거듭제곱의 곱으로 정의되며, 속도(<span class="math inline">\(\text{m s}^{-1}\)</span>)나 밀도(<span class="math inline">\(\text{kg m}^{-3}\)</span>), 면적(<span class="math inline">\(\text{m}^{2}\)</span>) 등이 이에 해당한다.</p>
<p>이 일곱 가지 SI 기본단위로 표현되지 않는 것을 무단위(unitless) 측정치라 한다. 무단위 측정치는 크게 두 가지로 구분할 수 있다. 첫째, 단위가 상쇄되는 경우로, 질량 분율(kg/kg)이나 각도(rad = m/m)가 여기에 속한다. 둘째, 계수 단위를 사용하는 경우로, 예를 들어 ‘사과 5개’와 같이 사물이나 사건을 단순히 세는 경우이다. 이 두 경우는 모두 수학적으로는 무차원으로 취급되지만, 의미적으로는 서로 구별된다. 예컨대 각도와 사과 개수를 더하는 것은 전혀 의미가 없지만, 사과 5개와 오렌지 3개는 <em>과일 개수</em>라는 상위 범주(superclass)로 묶어 해석하면 더할 수 있다.(역자주: ‘개’, ‘명’, ’마리’와 같이 사물이나 사건을 셀 때 사용하는 단위를 계수 단위(counting unit)라고 한다. 이러한 계수 단위는 일상적으로는 단위처럼 인식되지만, SI 에서는 차원이 없는 무차원 단위로 취급된다. 예컨대 ’과일 개수’와 같은 계수 단위는 SI 단위에는 속하지 않지만, 서로 다른 객체(사과와 오렌지 등)를 공통의 범주 아래에서 합산할 수 있도록 하는 연산적 틀을 제공한다.) 많은 데이터 변수는 이처럼 SI 기본단위나 유도단위로 환원할 수 없는 단위를 갖는다. Hand(2004)는 사회과학에서 지능과 같은 변수를 측정하는 척도를 포함하여, 이러한 다양한 측정 척도를 단위 개념의 맥락에서 논의하고 있다.</p>
<p>많은 물리량의 자연스러운 원점은 0이다. 이는 양의 차이를 계산했을 때 음수 값도 의미를 갖는다는 점에서 알 수 있다. 위치나 시간의 경우에도 차이는 자연스럽게 0을 기준으로 해석된다. 다시 말해, 거리는 위치의 차이를, 지속 시간은 시간의 차이를 의미한다. 절대적 위치(좌표)와 절대적 시간은 다른 절대적 시공간 점들을 의미 있게 측정하기 위해 고정된 원점을 필요로 하며, 이를 <strong>데이텀</strong>(datum)이라 부른다. 공간에서의 데이텀은 하나 이상의 차원을 포함한다. 데이텀에 측정 단위(스케일)가 결합되면 이를 <em>참조계</em>(reference system)라고 한다.</p>
<p>이후에서는 공간적 위치를 타원체 좌표 또는 데카르트 좌표로 표현하는 방법을 자세히 살펴본다. 다음 절에서는 시간 및 공간 참조계와, R에서 이러한 참조계를 다루는 방법을 설명한다.</p>
</section><section id="타원체-좌표계" class="level2" data-number="2.2"><h2 data-number="2.2" class="anchored" data-anchor-id="타원체-좌표계">
<span class="header-section-number">2.2</span> 타원체 좌표계</h2>
<div id="fig-2-1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-2-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-polar-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" data-glightbox="description: .lightbox-desc-1"><img src="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-polar-1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;2.1: 2차원 극 좌표와 데카르트 좌표
</figcaption></figure>
</div>
<p>그림 2.1은 2차원 극 좌표(polar coordinate)와 데카르트 좌표(Cartesian coordinate)를 보여준다. 해당 지점의 데카르트 좌표는 <span class="math inline">\((x,y)=(3,4)\)</span>로 주어지고, 극 좌표는 <span class="math inline">\((r,\phi)=(5,\text{arctan(4/3)})\)</span>로 주어지는데 <span class="math inline">\(\text{arctan(4/3)}\)</span>는 대략 <span class="math inline">\(0.93\)</span> 라디안 혹은 <span class="math inline">\(53^\circ\)</span>이다. 여기서 <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, <span class="math inline">\(r\)</span>은 모두 길이 단위이고 <span class="math inline">\(\phi\)</span>는 각도 단위(무단위 길이/길이 비)라는 점에 유의할 필요가 있다. 데카르트 좌표와 극 좌표 간의 변환은 매우 간단하다.</p>
<p><span class="math display">\[
x=r\cos\phi,\quad y=r\sin\phi, \text{ and}
\]</span></p>
<p><span class="math display">\[
r=\sqrt{x^2+y^2}, \quad \phi=\text{atan2}(y,x)
\]</span></p>
<p>여기서 <span class="math inline">\(\text{atan2}\)</span>이 <span class="math inline">\(\text{atan}(y/x)\)</span>대신 사용되었는데, 오른쪽 일사분면에 위치가 있기 때문이다.</p>
<section id="구체-혹은-타원체-좌표" class="level3" data-number="2.2.1"><h3 data-number="2.2.1" class="anchored" data-anchor-id="구체-혹은-타원체-좌표">
<span class="header-section-number">2.2.1</span> 구체 혹은 타원체 좌표</h3>
<p>3차원의 경우, 데카르트 좌표는 <span class="math inline">\((x,y,z)\)</span>로 주어지고, 극 좌표는 <span class="math inline">\((r,\lambda,\phi)\)</span>로 주어진다.</p>
<ul>
<li><p><span class="math inline">\(r\)</span>은 구체의 반지름이다.</p></li>
<li><p><span class="math inline">\(\lambda\)</span>는 경도로, <span class="math inline">\((x,y)\)</span> 평면에서 양의 <span class="math inline">\(x\)</span>축으로부터 반시계방향으로 측정된다.</p></li>
<li><p><span class="math inline">\(\phi\)</span>는 위도로, <span class="math inline">\((x,y)\)</span> 평면과 해당 벡터가 이루는 각도이다.</p></li>
</ul>
<p>그림 2.2는 데카르트 지심 좌표(Cartesian geocentric coordinate)와 타원체 좌표(ellipsoidal coordinate)를 보여준다.</p>
<div id="fig-2-2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-2-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-sphere-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" data-glightbox="description: .lightbox-desc-2"><img src="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-sphere-1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;2.2: 세 개의 거리로 표현되는 데카르트 지심 좌표(왼편)와 두 개의 각도와 하나의 타원체고로 표현되는 타원체 좌표(오른편)
</figcaption></figure>
</div>
<p><span class="math inline">\(\lambda\)</span>는 <span class="math inline">\(-180^\circ\)</span>에서 <span class="math inline">\(180^\circ\)</span> 사이(혹은 <span class="math inline">\(0^\circ\)</span>에서 <span class="math inline">\(360^\circ\)</span> 사이)의 값을 가지며, <span class="math inline">\(\phi\)</span>는 <span class="math inline">\(-90^\circ\)</span>에서 <span class="math inline">\(90^\circ\)</span> 사이의 값을 갖는다. 타원체가 아니라 반지름이 고정된 구체(혹은 구체 <em>상</em>의 위치)를 전제로 한다면, 위의 <span class="math inline">\(r\)</span> 값을 생략한 <span class="math inline">\((\lambda,\phi)\)</span> 만으로도 모든 위치를 고정할 수 있다.</p>
<p>이 정의가 <em>유일한</em> 것은 아니라는 점에 유의해야 한다. 예를 들어, 위도 대신 해당 벡터와 <span class="math inline">\(z\)</span>축 사이의 각도(극각)을 사용할 수도 있다. 또한, 좌표를 <span class="math inline">\((\phi,\lambda)\)</span> 순서로 표기하는 오랜 전통도 존재하지만, 이 책에서는 경도-위도 형식인 (<span class="math inline">\(\lambda,\phi\)</span>)를 사용한다. 그림 2.2에 표시된 지점은 <span class="math inline">\((\lambda,\phi)\)</span> 형식으로 표현되는, 각도 단위의 타원체 좌표를 가진다.</p>
<pre><code># POINT (60 47)</code></pre>
<p>지심 좌표값은 미터 단위로 주어진다.</p>
<pre><code># POINT Z (2178844 3773868 4641765)</code></pre>
<p>타원체 상의 지점에 대해서는 각도를 나타내는 두 가지 방법이 있다(그림 2.3). 하나는 타원체의 중심을 기준으로 측정된 각도(<span class="math inline">\(\psi\)</span>), 또는 해당 지점을 지나는 접선에 수직으로 측정된 각도(<span class="math inline">\(\phi\)</span>)이다.</p>
<div id="fig-2-3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-2-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-ellipse-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" data-glightbox="description: .lightbox-desc-3"><img src="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-ellipse-1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;2.3: 타원체 상의 각도: 측지 위도(파란색)와 지심 위도(붉은색)
</figcaption></figure>
</div>
<p>지구를 표현하는 데 가장 널리 사용되는 파라메트릭 모형은 <em>회전타원체</em>(ellipsoid of revolution)이다. 회전타원체는 길이가 서로 다른 반장축과 반단축을 가진 타원체로, 한쪽 방향이 약간 납작해진 구(또는 구체, spheroid)라고 할 수 있다(Iliffe and Lott 2008). 실제로, 지구의 남북 길이는 동서 길이보다 약간(약 0.33%) 짧다. 이 모형에서 경도는 항상 원을 따라 측정되고(그림 2.2), 위도는 타원을 따라 측정된다(그림 2.3). 그림 2.3을 양 극을 지나는 지구의 단면도로 본다면, 별도의 언급이 없는 경우 위도는 파란선으로 표시된 측지 위도(geodetic latitude)를 의미한다. 이에 대응하여 지심 위도(geocentric latitude)라는 개념도 존재한다.(역자주: 측지 위도는 적도면과, 특정 지점에서 회전타원체에 접하는 평면의 법선이 이루는 각도를 의미한다. 반면 지심 위도는 적도면과, 특정 지점과 지구 중심을 잇는 직선이 이루는 각도를 의미한다. 완전한 구를 가정하면 두 위도는 일치한다. 측지 위도의 경우 위도 1도의 남북 길이는 고위도로 갈수록 길어지지만, 지심 위도에서는 일정하게 나타난다.)</p>
<p>경도와 위도에 고도(altitude)나 높이(elevation)를 더하면, 회전타원체의 위나 아래에 있는 지점의 위치까지 정의할 수 있으며, 이를 통해 완전한 3차원 위치 참조계를 구성할 수 있다. 고도를 정의할 때는 다음을 선택해야 한다.</p>
<ul>
<li><p>고도 0의 기준을 어디에 둘 것인가: 회전타원체 상에 둘 것인가, 아니면 평균 해수면을 근사한 지오이드(geoid) 표면을 기준으로 할 것인가?</p></li>
<li><p>양(+)의 방향을 어디로 할 것인가?</p></li>
<li><p>‘위쪽’ 방향을 어떻게 정의할 것인가: 회전타원체 표면에 수직인 방향으로 할 것인가, 아니면 지오이드 표면에 수직인, 중력의 방향으로 할 것인가?</p></li>
</ul>
<p>응용 분야와 요구되는 측정 정밀도에 따라 이러한 선택들이 중요해질 수 있다.</p>
<p>지구는 완전한 회전타원체가 아니기 때문에, 다양한 회전타원체가 제안되어 사용되고 있다. 이들 회전타원체는 반장축과 반단축의 길이와 같은 파라미터 값이 서로 다를 수 있고, 지구에 정합시키는 방식 또한 다를 수 있다. 이처럼 특정한 방식으로 규정된 회전타원체를 <em>데이텀</em>(datum)이라 하며, <em>좌표참조계</em>(coordinate reference system)와 함께 2.3절에서 간략히 다룬다.</p>
</section><section id="투영-좌표계와-거리" class="level3" data-number="2.2.2"><h3 data-number="2.2.2" class="anchored" data-anchor-id="투영-좌표계와-거리">
<span class="header-section-number">2.2.2</span> 투영 좌표계와 거리</h3>
<p>투영 좌표계(projected coordinate system)는 지구 표면의 위치를 2차원 평면 위에서 표현하는 좌표계이다. 종이 지도와 컴퓨터 화면이 지구본보다 훨씬 더 실용적이고 널리 사용되기 때문에, 우리는 공간데이터를 대개 이러한 2차원 평면에 투영된 형태로 보게 된다. 이차원 공간에서 위치를 계산한다는 것은 곧 투영 좌표를 사용한다는 뜻이다. 타원체 좌표를 평면으로 투영하면 형태, 방향, 면적 중 하나 이상이 반드시 왜곡된다(Iliffe and Lott 2008).</p>
<p>데카르트 좌표에서 두 지점 <span class="math inline">\(p_i\)</span>와 <span class="math inline">\(p_j\)</span> 간의 거리는 유클리드 거리로 계산되며, 2차원의 경우 <span class="math inline">\(p_i=(x_i,y_i)\)</span>이므로 다음의 수식으로 주어진다.</p>
<p><span class="math display">\[
d_{ij}=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}
\]</span></p>
<p>3차원의 경우는 <span class="math inline">\(p_i=(x_i,y_i,z_i)\)</span>이므로, 다음의 수식으로 주어진다.</p>
<p><span class="math display">\[
d_{ij}=\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}
\]</span></p>
<p>이 거리는 지점 <span class="math inline">\(i\)</span>와 지점 <span class="math inline">\(j\)</span> 사이의 <em>직선</em>거리를 뜻한다. 즉, 두 지점을 직선으로 연결했을 때 그 선분의 길이를 의미한다.</p>
<p>반지름이 <span class="math inline">\(r\)</span>인 원 위에서, 두 지점 <span class="math inline">\(c_1=(r,\phi_1)\)</span>와 <span class="math inline">\(c_2=(r,\phi_2)\)</span> 사이의 호 길이는 다음과 같이 주어진다. <span class="math display">\[
s_{ij}=r|\phi_1-\phi_2|=r\theta
\]</span></p>
<p>여기서 <span class="math inline">\(\theta\)</span>는 <span class="math inline">\(\phi_1\)</span>과 <span class="math inline">\(\phi_2\)</span> 사이의 각도를 라디안 단위로 나타낸다. <span class="math inline">\(\theta\)</span>가 매우 작을 경우, 호가 직선에 가까워지므로 <span class="math inline">\(s_{ij}\approx d_{ij}\)</span>가 성립한다.</p>
<p>반지름이 <span class="math inline">\(r'\)</span>인 구체 위의 두 지점 <span class="math inline">\(p_1=(\lambda_1,\phi_1)\)</span>과 <span class="math inline">\(p_2=(\lambda_2,\phi_2)\)</span>를 지나는 원(중심은 구체의 중심과 일치)에서, 두 지점 사이의 호의 길이를 <em>대권거리</em>(great circle distance)라 하며, 이는 <span class="math inline">\(s_{12}=r\theta_{12}\)</span>로 표현된다. 따라서 <span class="math inline">\(p_1\)</span>과 <span class="math inline">\(p_2\)</span> 사이의 각도 <span class="math inline">\(\theta_{12}\)</span>(라디안 단위)는 다음과 같이 주어진다.</p>
<p><span class="math display">\[
\theta_{12}=\arccos(\sin\phi_1\cdot \sin\phi_2+\cos\phi_1\cdot \cos\phi_2\cdot\cos(|\lambda_1-\lambda_2|))
\]</span></p>
<p>타원체 위의 두 지점 사이의 호의 길이를 계산하는 일은 훨씬 더 복잡하다. Karney(2013)은 이에 대해 심도 있는 논의를 제시하였으며, PROJ 라이브러리의 일부인 GeographicLib에서 구현된 방법에 대한 상세한 설명도 제공한다.</p>
<p>이러한 거리 계산 방법들이 실제로 서로 다른 값을 산출한다는 점을 보이기 위해, 우리는 베를린과 파리 사이의 거리를 계산하였다. WGS84 타원체와 완전 구체 각각에 대해 거리를 구했으며, 여기서 <code>gc_</code>는 대권거리를, <code>str_</code>은 지심 좌표값을 이용한 직선거리를 나타낸다.</p>
<pre><code># Units: [km]
#  gc_ellipse str_ellipse   gc_sphere  str_sphere 
#      879.70      879.00      877.46      876.77</code></pre>
</section><section id="한정-공간과-비한정-공간" class="level3" data-number="2.2.3"><h3 data-number="2.2.3" class="anchored" data-anchor-id="한정-공간과-비한정-공간">
<span class="header-section-number">2.2.3</span> 한정 공간과 비한정 공간</h3>
<p>2차원 및 3차원 유클리드 공간(<span class="math inline">\(R^2\)</span>와 <span class="math inline">\(R^3\)</span>)은 비한정 공간(unbounded space)이다. 이 공간의 모든 선은 무한한 길이를 가지며, 면적이나 부피는 자연적인 상한이 없다. 이에 비해 원(<span class="math inline">\(S^1\)</span>)이나 구(<span class="math inline">\(S^2\)</span>)와 같은 공간은 한정 공간(bounded space)이다. 이 경우 점의 개수는 무한할 수 있지만, 원의 둘레와 면적, 구의 반지름과 표면적, 부피는 유한하다.</p>
<p>이 차이는 사소해 보일 수 있으나, 공간데이터 처리에서는 흥미로운 도전 과제를 유발한다. 예를 들어, <span class="math inline">\(R^2\)</span> 상의 폴리곤은 명확히 내부와 외부가 구분된다. 그러나 <span class="math inline">\(S^2\)</span> 공간인 구체 상에서 모든 폴리곤은 구를 두 영역으로 나누며, 어느 쪽을 내부로, 어느 쪽을 외부로 정의할지는 탐색 방향(traversal direction)에 따라 달라진다. 이러한 <span class="math inline">\(S^2\)</span> 지오메트리에서의 차이는 4장에서 다시 논의한다.(역자주: 탐색 방향이란 폴리곤 경계를 따라가는 방향을 의미한다. 일반적으로 평면(<span class="math inline">\(R^2\)</span>)에서는 경계를 시계 방향으로 탐색하면 왼쪽에 있는 영역이 내부로, 반시계 방향으로 탐색하면 오른쪽에 있는 영역이 내부로 간주된다. 그러나 구현 방식이나 좌표계 종류(예: 구면 좌표계)에 따라 내부와 외부의 정의가 달라질 수 있으므로, 적용 환경에 맞는 판정 규칙을 확인해야 한다.)</p>
</section></section><section id="crs" class="level2" data-number="2.3"><h2 data-number="2.3" class="anchored" data-anchor-id="crs">
<span class="header-section-number">2.3</span> CRS</h2>
<p>Lott(2015)를 따라, 다음과 같은 개념 정의를 사용한다(이탤릭체는 Lott의 정의를 그대로 옮겨 온 것이다)</p>
<ul>
<li><p><strong>좌표계</strong>는 <em>지점에 좌표를 부여하는 방법을 규정하는 수학적 규칙의 집합이다</em>.</p></li>
<li><p><strong>데이텀</strong>은 <em>좌표계의 원점, 축척, 방향을 정의하는 파라미터 또는 파라미터의 집합이다</em>.</p></li>
<li><p><strong>측지 데이텀</strong>은 <em>2차원 또는 3차원 좌표계와 지구와의 관계를 설명하는 데이텀이다</em>.(역자주: 즉, 지구에 부여된 2차원 또는 3차원 좌표계를 정의하는 데이텀이다.)</p></li>
<li><p><strong>CRS</strong>(좌표참조계)는 <em>특정 데이텀을 바탕으로 특정 객체에 부여된 좌표계이다. 측지 데이텀과 수직 데이텀의 경우, 그 객체는 지구이다.</em>(역자 주: 측지 데이텀은 지구 표면상의 위치를 규정하는 수평 데이텀이며, 수직 데이텀은 말 그대로 지표의 높이를 규정하는 데이텀이다).</p></li>
</ul>
<p>이 개념에 대한 보다 상세하고 친절한 설명은 Iliffe와 Lott(2008)에서 찾아볼 수 있다.</p>
<p>지구의 형태는 규칙적이지 않다. 지표면의 기복이 매우 불규칙하다는 사실은 널리 알려져 있지만, 평균해수면 개념과 연결되는 일정한 중력면, 즉 지오이드(geoid) 또한 불규칙한 형상을 띤다. 지오이드를 단순화한 모형 가운데 가장 일반적으로 사용되는 것은 회전타원체로, 이는 두 개의 동일한 반단축을 가진 타원이다. 이 회전타원체를 지구와 어떻게 맞출 것인지가 데이텀을 규정한다. 타원체를 지구의 어느 부분에 일치시킬지, 또는 어떤 기준점을 사용할지에 따라 타원체의 적합도는 달라질 수 있으며, 이러한 이유로 다양한 데이텀이 존재한다. 일부 데이텀은 특정 지각판에 대한 적합도를 중시하기도 하고(예: ETRS89), 다른 데이텀은 전 세계적인 평균 적합도를 지향하기도 한다(예: WGS84). 국지적 적합도에 중점을 둘수록 해당 지역에서의 위치 근사 오차는 작아진다.</p>
<p>위의 정의에서 알 수 있듯이, 경도와 위도로 표현된 좌표값은 해당 데이텀이 함께 제공될 때에만 지구 좌표계로서 의미를 가지며, 이를 통해 해석상의 모호성을 제거할 수 있다.</p>
<p>특정 투영법이 적용<em>된</em> 데이터는 반드시 해당하는 참조 타원체(데이텀)와 결부되어 있다는 점에 유의해야 한다. 데이텀 전환 <em>없이</em> 투영법만 변경하는 작업은 <em>좌표 전환</em>(coordinate conversion)이라고 하며, 이는 해당 데이텀에 결부된 특정 타원체상의 좌표값을 기준으로 수행된다. 좌표 전환 과정은 정보 손실이 없고 가역적이며, 전환에 사용되는 파라미터와 수식은 변하지 않는다.</p>
<p>새로운 데이텀에 따라 좌표를 재계산하는 과정을 <em>좌표 변환</em>(coordinate transformation)이라 한다. 좌표 전환과 달리, 좌표 변환은 근사적으로 수행된다. 이는 데이텀이 지구에 대한 모형 적합의 결과물이므로, 데이텀 간 변환 또한 하나의 적합된 모형으로 간주되기 때문이다. 변환 함수 역시 경험적으로 도출되며, 적합도나 정확성의 설정에 따라 다양한 변환 경로가 존재할 수 있다.</p>
<p>판 구조론은 글로벌 데이텀에서 고정된 객체의 위치가 시간이 흐름에 따라 변할 수 있음을 보여준다. 이는 데이텀 간 좌표 변환이 시간에 따라 달라질 수 있음을 시사한다. 예를 들어, 지진과 같은 지각 운동으로 인해 특정 지역의 좌표가 갑작스럽게 변동할 수 있다. 국지적 데이텀은 특정 지각판에 고정하여 정의할 수도 있지만(예: ETRS89), 이를 보다 역동적으로 설정하여 시간에 따른 위치 변화를 반영하도록 할 수도 있다.</p>
</section><section id="proj와-지도-정확도" class="level2" data-number="2.4"><h2 data-number="2.4" class="anchored" data-anchor-id="proj와-지도-정확도">
<span class="header-section-number">2.4</span> PROJ와 지도 정확도</h2>
<p>오늘날 오픈소스 지리공간 소프트웨어 분야에서 활동하는 사람들 중에는 PROJ 이전의 시기를 기억하는 이가 거의 없다. PROJ(Evenden, 1990)는 1970년대에 포트란 기반 프로젝트로 시작되어, 1985년 지도 투영을 위한 C 라이브러리로 공개되었다. 이 라이브러리는 직접 투영과 역투영을 수행할 수 있는 명령줄 인터페이스를 제공했으며, 이를 다른 소프트웨어와 연동하여 투영 및 재투영 작업을 즉시 실행할 수 있었다. 당시에는 데이텀이 단순히 주어진 것으로 간주되었고, 데이텀 간 변환 기능은 지원되지 않았다.</p>
<p>2000년대 초, PROJ는 PROJ.4라는 이름으로 불리게 되었는데, 이는 고정된 버전 번호가 접미사로 붙은 형태였다. GPS의 보급 확대를 비롯한 여러 요인으로 좌표계 간 변환 수요가 증가하자, PROJ.4는 기본적인 데이텀 지원 기능을 갖추게 되었다. 이후 PROJ는 CRS를 다음과 같은 형식으로 정의하게 된다.</p>
<pre><code>+proj=utm +zone=33 +datum=WGS84 +units=m +no_defs</code></pre>
<p>‘<em>키=값</em>’ 쌍은 <code>+</code> 기호로 시작하며, 공백으로 구분된다. 이러한 형식은 PROJ 프로젝트가 수십 년 동안 4.x 버전을 유지하면서, 일반적으로 ’PROJ.4 문자열’로 불리게 되었다. 아래는 그 몇 가지 예시이다.</p>
<pre><code>+ellps=bessel +towgs84=565.4,50.3,465.6,-0.399,0.344,-1.877,4.072</code></pre>
<p>이 문자열은 해당 데이텀이 Bessel 타원체를 사용하며, 이를 WGS84(주로 GPS의 기준으로 널리 사용됨)로 변환하기 위해 7개(또는 경우에 따라 3개)의 파라미터가 필요함을 잘 보여준다.</p>
<p>PROJ.4 외에도 다양한 투영법 관련 데이터베이스가 구축되었는데, 그중 가장 널리 알려진 것이 EPSG(European Petroleum Survey Group) 레지스트리이다. 각국의 지도 제작 기관은 자국 CRS의 <code>+towgs84</code> 파라미터(즉, WGS84로 변환하기 위한 파라미터)에 대해 최적 추정값을 계산하고, 이를 지속적으로 갱신하여 EPSG 등록부를 통해 배포해 왔다. 일부 좌표 변환에는 <em>데이텀 그리드</em>(datum grid)가 함께 제공되었는데, 이는 PROJ.4의 일부로도 배포되었다. 데이텀 그리드는 결국 래스터 형식의 지도이며, 데이텀 변환 시 발생하는 경도, 위도, 고도 변화값을 모든 지점에 대해 미리 계산해 둔 데이터를 의미한다.</p>
<p>PROJ.4에서는 모든 좌표 변환이 반드시 WGS84를 경유하여 수행되었다. 서로 다른 데이텀을 가진 데이터를 재투영할 때도, 중간 단계로 WGS84로 변환한 뒤 목표 좌표계로 변환해야 했다. 이로 인해 최대 약 100m의 오차가 발생할 수 있었는데, 이는 비교적 넓은 지역을 대상으로 하는 지도 제작에서는 수용 가능한 수준이었다. 그러나 정밀 농업, UAV(무인항공기) 운용 계획, 객체 추적 등 일부 응용 분야에서는 이보다 훨씬 높은 정밀도의 좌표 변환이 요구된다.</p>
<p>2018년, ‘GDAL 좌표계 공동 개발(Coordinate System Unification)’ 이니셔티브가 성공적으로 추진된 이후, 오픈소스 지리공간 소프트웨어 스택의 혜택을 받아온 여러 기업들이 PROJ의 보다 현대적이고 고도화된 좌표 변환 시스템 개발을 지원하였다. 그 결과 PROJ.4는 5, 6, 7, 8, 9 버전을 거치며 지속적으로 발전했고, 명칭도 PROJ또는 PR<span class="math inline">\(\phi\)</span>J)로 변경되었다.</p>
<p>가장 주목할 만한 변화는 다음과 같다.</p>
<ul>
<li><p>PROJ.4 문자열의 한계와 WKT-2 도입: PROJ.4 문자열은 여전히 새로운 CRS를 정의하는 데 사용할 수 있지만, 모든 CRS를 포괄하기에는 한계가 있음이 드러났다. 이를 대체하기 위해 WKT-2 형식이 도입되었으며, 이에 대해서는 다음 절에서 설명한다.</p></li>
<li><p>WGS84dml ‘허브 데이텀’ 지위 폐지: 좌표 변환 시 WGS84와 같은 특정 데이텀을 중간 단계로 거칠 필요 없이, 직접 데이텀 간 변환이 가능해졌다.</p></li>
<li><p>다중 변환 경로(<em>파이프라인</em>) 지원: 하나의 CRS(A)에서 다른 CRS(B)로 이동할 때 사용할 수 있는 다수의 변환 또는 전환 경로가 존재할 수 있으며, 각 경로에 대한 정확도 정보가 제공되면 등록할 수 있다. PROJ는 기본적으로 가장 정확한 경로를 자동 선택하지만, 사용자가 직접 선택할 수도 있다.</p></li>
<li><p>변환 파이프라인 구성 가능: 변환 파이프라인은 축 교환, 단위 변환 등 여러 기본 변환 단계를 연결하여 구성될 수 있다.</p></li>
<li><p>데이텀 그리드 배포 방식 변경: 데이텀 그리드는 더 이상 라이브러리에 포함되지 않으며, 대신 콘텐츠 전송 네트워크(CDN)를 통해 제공된다. PROJ는 네트워크 접근을 켜거나 끌 수 있는 옵션을 제공하며, 실제 필요한 그리드 구간만 다운로드해 로컬 캐시에 저장해 이후에도 사용할 수 있다.</p></li>
<li><p>에포크(epoch) 기반 좌표 변환 지원: 시간-의존적 좌표 변환이 가능해져, 소스와 타깃 시간 정보를 포함하는 4차원 좌표계 간 변환이 지원된다.(역자주: 지구의 좌표계는 시간이 지남에 따라 점진적으로 변화해 왔으며, 특정 시점(에포크)에 기반한 위치 정의가 가능해졌다는 의미다.)</p></li>
<li><p>축 순서 사용자 정의 가능: 예를 들어 위도–경도(Lat–Lon) 또는 경도–위도(Lon–Lat)와 같은 축 순서를 자유롭게 변경할 수 있다.</p></li>
</ul>
<p>이러한 개선을 통해 좌표 변환의 정확도는 이제 1미터 이하 수준까지 향상될 수 있다. 특히 주목할 만한 변화는 마지막 항목에 있다. 수십 년 동안 경도–위도 순서를 따르는 타원체 좌표의 축 순서는 자명한 것으로 여겨져 왔으나, 이제 더 이상 그렇지 않다. 섹션 7.7.6에서는 이러한 변화에 어떻게 대응할 수 있는지를 살펴본다.</p>
<div id="fig-2-4" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-2-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-horizontalgrid-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" data-glightbox="description: .lightbox-desc-4"><img src="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-horizontalgrid-1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;2.4: 영국의 OSGB 1936(EPSG:4277)를 ETRS89(EPSG:4258)로 변환하는데 사용되는 수평 데이텀 그리드
</figcaption></figure>
</div>
<div id="fig-2-5" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-2-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-verticalgrid-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" data-glightbox="description: .lightbox-desc-5"><img src="https://r-spatial.org/book/02-Spaces_files/figure-html/fig-verticalgrid-1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-2-5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;2.5: 영국의 ETRS89(EPSG:4937)를 ODN 고도(EPSG:5701)로 변환하는데 사용되는 수직 데이텀 그리드
</figcaption></figure>
</div>
<p>그림 2.4의 수평 데이텀 그리드 예시와 그림 2.5의 수직 데이텀 그리드 예시는 cdn.proj.org에서 다운로드한 것이다. 경우에 따라 데이텀 그리드에는 픽셀 단위의 정밀도 값이 포함되기도 한다.</p>
</section><section id="wkt-2" class="level2" data-number="2.5"><h2 data-number="2.5" class="anchored" data-anchor-id="wkt-2">
<span class="header-section-number">2.5</span> WKT-2</h2>
<p>Lott(2015)는 CRS의 인코딩 방식과 CRS 간 변환을 WKT(<em>well-known text</em>)로 표현하는 표준을 정리하였다. 이 표준(및 포맷)은 비공식적으로 WKT-2라고 불린다. 앞서 언급했듯이, GDAL과 PROJ는 이 표준을 지원한다. 예를 들어, 특정 CRS인 EPSG:4326은 WKT-2 형식으로 다음과 같이 표현된다.</p>
<pre><code>GEOGCRS["WGS 84",
    ENSEMBLE["World Geodetic System 1984 ensemble",
        MEMBER["World Geodetic System 1984 (Transit)"],
        MEMBER["World Geodetic System 1984 (G730)"],
        MEMBER["World Geodetic System 1984 (G873)"],
        MEMBER["World Geodetic System 1984 (G1150)"],
        MEMBER["World Geodetic System 1984 (G1674)"],
        MEMBER["World Geodetic System 1984 (G1762)"],
        MEMBER["World Geodetic System 1984 (G2139)"],
        ELLIPSOID["WGS 84",6378137,298.257223563,
            LENGTHUNIT["metre",1]],
        ENSEMBLEACCURACY[2.0]],
    PRIMEM["Greenwich",0,
        ANGLEUNIT["degree",0.0174532925199433]],
    CS[ellipsoidal,2],
        AXIS["geodetic latitude (Lat)",north,
            ORDER[1],
            ANGLEUNIT["degree",0.0174532925199433]],
        AXIS["geodetic longitude (Lon)",east,
            ORDER[2],
            ANGLEUNIT["degree",0.0174532925199433]],
    USAGE[
        SCOPE["Horizontal component of 3D system."],
        AREA["World."],
        BBOX[-90,-180,90,180]],
    ID["EPSG",4326]]</code></pre>
<p>이 예시는 축 순서가 <em>위도–경도</em>로 설정된 좌표계를 보여준다. 그러나 실제로 사용되는 대부분의 좌표계는 <em>경도–위도</em> 순서를 따른다. WGS84 타원체에 대한 <em>앙상블</em>(ensemble)은 다양한 버전과 업데이트를 포함하고 있으며, 어떤 앙상블을 사용하는지에 따라 수 미터 수준의 오차가 발생할 수 있다. <code>OGC:CRS84</code>는 <code>longitude–altitude</code> 순서를 명시적으로 정의하고 있어 GRS84의 대안으로 권장되지만, 데이텀 앙상블 문제까지 해결해 주지는 않는다.</p>
<p>PROJ의 역사와 최근 변화는 Knudsen과 Evers(2017), Evers와 Knudsen(2017)의 연구를 바탕으로 정리한 Bivand(2020)에 잘 요약되어 있다.</p>
</section><section id="연습문제" class="level2" data-number="2.6"><h2 data-number="2.6" class="anchored" data-anchor-id="연습문제">
<span class="header-section-number">2.6</span> 연습문제</h2>
<p>R을 활용하여 아래의 연습문제를 풀되, 패키지는 사용하지 않는다. 적절한 기본 함수를 찾아 활용하도록 한다.</p>
<ol type="1">
<li><p>자연 원점(0)을 갖지 않는 <em>지리적</em> 측도 세가지를 나열하시오.</p></li>
<li><p>다음의 <span class="math inline">\((x,y)\)</span> 좌표, <span class="math inline">\((10,2)\)</span>, <span class="math inline">\((-10,-2)\)</span>, <span class="math inline">\((10,-2)\)</span>, <span class="math inline">\((0,10)\)</span>을 극 좌표로 변환하시오.</p></li>
<li><p>다음의 <span class="math inline">\((r,\phi)\)</span> 좌표, <span class="math inline">\((10,45^\circ)\)</span>, <span class="math inline">\((0,100^\circ)\)</span>, <span class="math inline">\((5,359^\circ)\)</span>를 데카르트 좌표로 변환하시오.</p></li>
<li><p>지구를 반지름이 6,371 km인 완전한 구체로 가정하고, 다음 네 쌍의 (<span class="math inline">\(\lambda, \phi\)</span>) 지점 간의 대권거리를 각도 단위로 계산하시오. 각 쌍의 위도와 경도는 각도 단위로 주어진다. <span class="math inline">\((10,10)\)</span>과 <span class="math inline">\((11,10)\)</span>, <span class="math inline">\((10,80)\)</span>과 <span class="math inline">\((11,80)\)</span>, <span class="math inline">\((10,10)\)</span>과 <span class="math inline">\((10,11)\)</span>, <span class="math inline">\((10,80)\)</span>과 <span class="math inline">\((10,81)\)</span></p></li>
</ol>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">그림&nbsp;2.1: 2차원 극 좌표와 데카르트 좌표</span>
<span class="glightbox-desc lightbox-desc-2">그림&nbsp;2.2: 세 개의 거리로 표현되는 데카르트 지심 좌표(왼편)와 두 개의 각도와 하나의 타원체고로 표현되는 타원체 좌표(오른편)</span>
<span class="glightbox-desc lightbox-desc-3">그림&nbsp;2.3: 타원체 상의 각도: 측지 위도(파란색)와 지심 위도(붉은색)</span>
<span class="glightbox-desc lightbox-desc-4">그림&nbsp;2.4: 영국의 OSGB 1936(EPSG:4277)를 ETRS89(EPSG:4258)로 변환하는데 사용되는 수평 데이텀 그리드</span>
<span class="glightbox-desc lightbox-desc-5">그림&nbsp;2.5: 영국의 ETRS89(EPSG:4937)를 ODN 고도(EPSG:5701)로 변환하는데 사용되는 수직 데이텀 그리드</span>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./01.html" class="pagination-link  aria-label=">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">시작하기</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./03.html" class="pagination-link" aria-label="<span class='chapter-number'>3</span>&nbsp; <span class='chapter-title'>지오메트리</span>">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">지오메트리</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/sangillee66/book_sds_trans/issues/new" class="toc-action"><i class="bi bi-github"></i>이슈 보고</a></li></ul></div></div></div></footer><script>var lightboxQuarto = GLightbox({"loop":false,"descPosition":"bottom","openEffect":"zoom","selector":".lightbox","closeEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>


</body></html>