[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "공간데이터사이언스 개론",
    "section": "",
    "text": "서장\n데이터사이언스는 주어진 데이터를 바탕으로 질문에 대한 해답을 찾고, 그 과정을 타인과 효과적으로 소통하는 학문이다. 여기서 소통은 단순히 결과를 제시하는 것을 넘어, 사용된 데이터를 공유하고 해답 도출의 전 과정을 포괄적이며 재현 가능한 방식으로 투명하게 공개하는 것을 포함한다. 또한 데이터사이언스는 주어진 데이터가 질문에 답하기에 충분하지 않을 수 있음을 인정하며, 설령 해답이 도출되었다 하더라도 데이터 수집 또는 표본추출 방식에 따라 그 결과가 달라질 수 있음을 수용한다.\n이 책은 공간데이터의 기본 개념을 소개하고 설명한다. 포인트, 라인, 폴리곤, 래스터, 커버리지, 지오메트리 속성, 데이터 큐브, 참조계와 같은 기초 개념부터, 속성과 지오메트리가 어떻게 연결되고 이러한 연결이 분석에 어떤 영향을 미치는지에 관한 고차원 개념까지를 다룬다. 속성과 지오메트리 간의 관계를 서포트(support)라 하며, 서포트가 달라지면 속성의 특성도 변할 수 있다. 일부 데이터는 공간적 연속성에 기반해 생성되어 모든 지점에서 관찰이 가능하지만, 다른 데이터는 공간적 이산성에 기반해 특정한 구획 체계를 통해서만 관찰된다. 현대 공간데이터분석에서는 이러한 구획 체계 개념이 포인트 데이터, 지구통계학적 데이터, 에어리어 데이터를 포함한 다양한 데이터 유형에 폭넓게 적용된다. 공간적 재현의 중요성을 뒷받침하는 핵심 개념이 바로 서포트이며, 서포트에 대한 이해는 필수적이다. 이 책은 공간데이터를 분석에 활용하고자 하는 데이터 과학자를 주요 독자로 한다. 책 전반에 걸쳐 공간데이터분석의 절차와 방법을 설명하며, 예시에는 프로그래밍 언어 R을 사용한다. 향후에는 Python과 Julia를 활용한 예제도 추가할 예정이다(Bivand 2022a 참조).\n공간데이터에 대해 흔히 갖는 통념이 있다. 공간데이터란 관측 개체의 경위도값을 속성으로 포함한 데이터이며, 이 경위도값을 다른 변수들과 동일하게 취급해도 무방하다는 생각이다. 그러나 이러한 인식은 더 풍부한 연구 결과를 도출할 기회를 놓칠 뿐 아니라, 잘못된 결론에 이를 위험을 높인다. 다음의 세 가지 점을 살펴보자.\n이 책은 공간데이터, 좌표참조계, 공간분석과 관련된 다양한 개념 뿐만 아니라 sf(Pebesma 2018, 2022a), stars(Pebesma 2022b), s2(Dunnington, Pebesma, and Rubak 2023), lwgeom(Pebesma 2023)와 같은 여러 R 패키지를 함께 다룬다. 이와 더불어 공간적 tidyverse(Wickham et al. 2019; Wickham 2022) 확장 패키지와 이들 패키지와 연계하여 사용할 수 있는 공간분석 및 시각화 패키지들인 gstat(Pebesma 2004; Pebesma and Graeler 2022), spdep(Bivand 2022b), spatialreg(Bivand and Piras 2022), spatstat(Baddeley, Rubak, and Turner 2015; Baddeley, Turner, and Rubak 2022), tmap(Tennekes 2018, 2022), mapview(Appelhans et al. 2022)도 함께 소개한다.\n데이터사이언스와 마찬가지로 공간데이터사이언스도 특정 과학 분야의 하위 영역으로서 위로부터 형성된 것이 아니라, 공간데이터 활용과 관련된 다양한 학문 및 산업 분야에서의 상향식 발전을 통해 형성되어 온 분야이다. 학술대회, 심포지엄, 학회, 연구 프로그램 등을 통해 공간데이터사이언스를 정의하려는 시도가 이어지고 있으나, 그 응용 범위가 워낙 광범위하고 다양하기 때문에 결실을 맺기는 쉽지 않다. 이 책에 ’공간데이터사이언스’라는 제목을 붙인 이유는 이 분야의 경계를 명확히 규정하려는 의도에서 비롯된 것이 아니다. 지난 30~40년 동안 우리는 기본 아이디어, 데이터, 소프트웨어 기반의 분석 절차 등 연구의 전 과정을 기꺼이 공유해 온 수많은 연구자들과 함께해 왔으며, 이 책은 그러한 공동 경험을 정리한 결과물이다. 이를 통해 공간데이터사이언스의 발전에 작게나마 기여하고자 하는 것이 우리의 본래 의도이다. 따라서 이 책에서 다루는 주제의 선택은 필연적으로 저자들의 연구 관심과 경험에 일정 부분 편향될 수밖에 없다. 우리가 경험한 오픈 연구 커뮤니티의 형성에는 여러 플랫폼이 중요한 역할을 했다. ai-geostats, r-sig-geo 메일링 리스트, SourceForge, R-Forge, GitHub, 그리고 2006년부터 매년 열리고 있는 OpenGeoHub 여름학교가 그 예이다. 데이터사이언스라는 언어 장벽을 넘어서려는 수많은 노력의 결과, 오늘날 우리는 새로운 가능성과 흥미로운 관점이 열리고 있음을 실감하고 있다. 우리가 이 분야에 기여하고자 하는 이유는, 오픈사이언스가 더 나은 과학을 가능하게 하며, 더 나은 과학이 보다 지속가능한 세상을 만드는 데 기여할 수 있다고 믿기 때문이다.",
    "crumbs": [
      "서장"
    ]
  },
  {
    "objectID": "index.html#감사의-글",
    "href": "index.html#감사의-글",
    "title": "공간데이터사이언스 개론",
    "section": "감사의 글",
    "text": "감사의 글\n우리는 r-spatial 커뮤니티 전체에 깊이 감사드리며, 특히 다음에 열거한 분들께 특별한 감사를 전한다.\n\nr-spatial 패키지를 개발하거나 그 개발에 기여해 주신 분들\n트위터의 #rspatial 해시태그나 GitHub에서 토론에 참여해 주신 분들\n강좌, 여름학교, 학술 컨퍼런스에서 의견을 개진하거나 질문을 통해 토론에 기여해 주신 분들\n\n특히, s2 패키지를 구현한 듀이 더닝턴(Dewey Dunnington)과, 제6장 데이터 큐브의 그림을 준비해 준 사힐 반다리(Sahil Bhandari), 조너선 발만(Jonathan Bahlmann), 그리고 클라우스 빌케(Claus Wilke), 야쿠브 노보사드(Jakub Nowosad)의 적극적인 기여에 깊이 감사드린다. 또한 2021년과 2022년에 진행된 ‘R을 활용한 공간데이터사이언스(Spatial Data Science with R)’ 수업의 참가자들과, 다음의 GitHub 리포지터리에서 이슈, 풀 리퀘스트, 디스커션 등을 통해 적극적으로 참여해 주신 모든 분들께도 진심으로 감사드린다.\n\n이 책의 리포지터리(Nowosad, jonathom, JaFro96, singhkpratham, liuyadong, hurielreichel, PPaccioretti, Robinlovelace, Syverpet, jonas-hurst, angela-li, ALanguillaume, florisvdh, ismailsunni, andronaco)\nsf 리포지터리(aecoleman, agila5, andycraig, angela-li, ateucher, barryrowlingson, bbest, BenGraeler, bhaskarvk, Bisaloo, bkmgit, christophertull, chrisyeh96, cmcaine, cpsievert, daissi, dankelley, DavisVaughan, dbaston, dblodgett-usgs, dcooley, demorenoc, dpprdan, drkrynstrng, etiennebr, famuvie, fdetsch, florisvdh, gregleleu, hadley, hughjonesd, huizezhang-sherry, jeffreyhanson, jeroen, jlacko, joethorley, joheisig, JoshOBrien, jwolfson, kadyb, karldw, kendonB, khondula, KHwong12, krlmlr, lambdamoses, lbusett, lcgodoy, lionel-, loicdtx, marwahaha, MatthieuStigler, mdsumner, MichaelChirico, microly, mpadge, mtennekes, nikolai-b, noerw, Nowosad, oliverbeagley, Pakillo, paleolimbot, pat-s, PPaccioretti, prdm0, ranghetti, rCarto, renejuan, rhijmans, rhurlin, rnuske, Robinlovelace, robitalec, rubak, rundel, statnmap, thomasp85, tim-salabim, tyluRp, uribo, Valexandre, wibeasley, wittja01, yutannihilation, Zedseayou)\nstars 리포지터리(a-benini, ailich, ateucher, btupper, dblodgett-usgs, djnavarro, ErickChacon, ethanwhite, etiennebr, flahn, floriandeboissieu, gavg712, gdkrmr, jannes-m, jeroen, JoshOBrien, kadyb, kendonB, mdsumner, michaeldorman, mtennekes, Nowosad, pat-s, PPaccioretti, przell, qdread, Rekyt, rhijmans, rubak, rushgeo, statnmap, uribo, yutannihilation)\ns2 리포지토리(kylebutts, spiry34, jeroen, eddelbuettel)",
    "crumbs": [
      "서장"
    ]
  },
  {
    "objectID": "part_1.html",
    "href": "part_1.html",
    "title": "공간데이터",
    "section": "",
    "text": "이 책의 제1부에서는 공간데이터사이언스의 핵심 개념을 다룬다. 지도, 투영, 벡터 및 래스터 데이터의 구조, 소프트웨어, 속성과 서포트, 데이터 큐브 등의 개념을 익히게 된다. 이 부분에서 R의 비중은 크지 않으며, 주로 텍스트 출력이나 그래프 작성에만 사용된다. 따라서 독자가 내용에 집중할 수 있도록 R 코드를 제시하거나 설명하지 않는다. R은 제2부에서 본격적으로 다루어진다. 이 책의 온라인 버전(https://r-spatial.org/book/)에서는 모든 R 코드를 확인할 수 있으며, 필요한 경우 클립보드에 복사해 실행해 볼 수 있다. R 코드 실행 결과는 # 기호로 시작하며, 코드 폰트로 표시된다.\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\n공간데이터사이언스 문제 해결을 위한 R 코드에 대한 보다 상세한 설명은 제2부부터 시작된다. 부록 B에는 R 데이터 구조에 대한 간략한 설명이 있으며, 더 자세한 내용은 Wickham(2014)을 참고하면 된다.",
    "crumbs": [
      "공간데이터"
    ]
  },
  {
    "objectID": "01.html",
    "href": "01.html",
    "title": "1  시작하기",
    "section": "",
    "text": "1.1 첫 번째 지도\n공간데이터를 표현하는 가장 전형적인 방법은 지도를 그리는 것이다. 그림 1.1은 그중에서도 단순한 형태의 지도를 예시로 보여준다.\n이 지도에는 다음과 같은 그래픽 요소가 포함되어 있다.\n폴리곤은 공간 지오메트리(geometry)의 한 형태다. 공간 지오메트리(포인트, 라인, 폴리곤, 픽셀)에 대해서는 3장에서 자세히 다룬다. 폴리곤은 여러 포인트가 선분으로 연결되어 형성되며, 포인트의 위치 표현과 측정 방법은 2장에서 설명한다. 그림 1.1에서 볼 수 있듯, 모든 경위선이 직선으로 나타나지는 않는다. 이는 지도에 특정 투영법이 적용되었음을 의미하며, 지도 투영에 대한 내용은 2장과 8.1절에서 다룬다.\n그림 1.1에서 컬러로 표현된 것은 BIR74 변수의 값이다. 각 값은 하나의 지오메트리, 즉 하나의 피처(feature)에 연결되어 있으며, 피처 속성과 지오메트리의 관계는 5장에서 다룬다. BIR74 변수는 출생아 수를 나타내는 지역별 빈도값(count)이다. 여기서 ’지역별’이라는 말은, 이 값이 지역 내 모든 지점과 직접적으로 대응되는 것이 아니라는 뜻이다. 지도의 컬러가 연속적으로 채색되어 있어 모든 지점이 해당 값을 가진다고 오해할 수 있지만, 실제로는 해당 값이 폴리곤 전체와 연결된 일종의 적분값임에 유의해야 한다.\n그림 1.1의 지도를 작성하려면 당연히 데이터가 필요하다. 여기서는 7.1절에서 사용된 파일을 불러와 사용하였다. 세 개 속성 변수에 대해 앞의 세 개 레코드만 요약한 결과는 다음과 같다.\n이 데이터 요약을 통해 다음과 같은 사실을 알 수 있다.\n패싯(facet) 플롯을 활용하면 그림 1.2와 같이 보다 복잡한 형태의 지도를 작성할 수 있다.\n리플릿(leaflet)을 사용하면 그림 1.3과 같은 인터랙티브 지도를 제작할 수 있다.\n그림 1.3: mapview로 그린 상호작용형 지도: 팬과 줌을 이용해 지도 스케일에 변화를 줄 수 있고 카운티를 클릭하면 해당 카운티의 속성을 보여주는 팝업 윈도우가 뜬다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#첫-번째-지도",
    "href": "01.html#첫-번째-지도",
    "title": "1  시작하기",
    "section": "",
    "text": "그림 1.1: 첫 번째 지도: 미국 노스캐롤라이나의 카운티별 출생아수, 1974~1978년\n\n\n\n\n폴리곤: 검은색 외곽선을 가진 폴리곤이며, 내부는 BIR74 변수(지도 제목)의 값에 따라 서로 다른 색상으로 채워져 있다.\n범례: 색상이 나타내는 값을 설명하며, 특정 컬러 팔레트(color palette)가 적용되어 있고 색상 변화 지점에는 컬러 단절값(color break)이 표시되어 있다.\n경위선망(그래티큘): 지도의 배경에 표시된다.\n축 눈금: 경도와 위도 값을 나타낸다.\n\n\n\n\n# Simple feature collection with 100 features and 3 fields\n# Geometry type: MULTIPOLYGON\n# Dimension:     XY\n# Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6\n# Geodetic CRS:  NAD27\n# # A tibble: 100 × 4\n#    AREA BIR74 SID74                                             geom\n#   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;                               &lt;MULTIPOLYGON [°]&gt;\n# 1 0.114  1091     1 (((-81.5 36.2, -81.5 36.3, -81.6 36.3, -81.6 36…\n# 2 0.061   487     0 (((-81.2 36.4, -81.2 36.4, -81.3 36.4, -81.3 36…\n# 3 0.143  3188     5 (((-80.5 36.2, -80.5 36.3, -80.5 36.3, -80.5 36…\n# # ℹ 97 more rows\n\n\n데이터셋은 100개의 피처(레코드)와 3개의 필드(속성)로 구성되어 있다.\n지오메트리 유형은 MULTIPOLYGON이다(3장 참조).\n디멘션은 XY이다. 즉, 개별 포인트는 두 개의 좌표값으로 구성되어 있다.\nCRS(coordinate reference system, 좌표참조계)는 측지 좌표계이며, NAD27 데이텀을 기반으로한 경위도값을 사용한다(2장 참조).\n세 개의 속성 변수 다음에는 MULTIPOLYGON 유형의 geom 변수가 있는데, 이는 폴리곤 정보를 각도(°) 형식으로 저장하고 있다.\n\n\n\n\n\n\n\n그림 1.2: 미국 노스캐롤라이나 카운티별 영아돌연사증후군에 의한 사망아수의 패싯 지도, 1974~1978년과 1979~1984년",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#좌표참조계crs",
    "href": "01.html#좌표참조계crs",
    "title": "1  시작하기",
    "section": "\n1.2 좌표참조계(CRS)",
    "text": "1.2 좌표참조계(CRS)\n좌표참조계(CRS, coordinate reference system)는 공간데이터의 좌표값이 어떤 기준과 규칙에 따라 정의되는지를 나타낸다. 그림 1.1의 배경에 보이는 회색선은 경위선망, 즉 그래티큘(graticule)이다. 경위선이 \\(x\\), \\(y\\) 축과 직교하는 직선이 아니라는 점은, 이 데이터에 특정한 투영법(projection)이 적용되었음을 보여준다. 반면 그림 1.3에서는 노스캐롤라이나의 북쪽 경계가 곡선이 아닌 직선으로 나타나는데, 이는 또 다른 투영법이 사용되었음을 의미한다.\n그림 1.1에 나타난 경위도 좌표는 특정한 데이텀(datum), 여기서는 NAD27에 기반하고 있다.(역자주: 경위도 좌표는 절대적인 값이 아니라 데이텀에 따라 달라지는 상대적인 값임을 반드시 이해해야 한다. 동일한 지점이라도 데이텀에 따라 서로 다른 경위도 좌표를 가질 수 있으며, 반대로 동일한 좌표값이 데이텀에 따라 지표상의 서로 다른 지점을 가리킬 수도 있다.) 데이텀은 지구를 모형화하기 위해 어떤 지구타원체를 선택하고, 이를 지구와 어떻게 일치시킬 것인가―즉 지구타원체의 원점을 지구상의 어느 지점에, 어떤 방향으로 맞출 것인가―에 대한 일련의 사항을 규정한다. 예를 들어, GPS 수신기(예: 모바일 폰)를 통해 획득한 좌표값은 WGS84(World Geodetic System 1984) 데이텀에 기반한다. 이 좌표값을 NAD27(North American Datum 1927) 기준으로 해석하면, 동일한 좌표값이 실제 위치에서 약 30m 정도 차이이날 수 있다.\n투영법은 하나의 좌표계에서 다른 좌표계로 변환하기 위해, 두 좌표값 간의 대응 관계를 정의하는 함수이다.\n\n타원체 좌표(ellipsoidal coordinates): 지구를 수학적으로 모형화한 지구타원체(또는 지구구체) 상의 3차원 좌표로, 경도와 위도를 사용하여 표현한다.\n투영 좌표(projected coordinates): 지도 상의 2차원 평면 좌표계로, 일반적으로 \\(x\\) 좌표와 \\(y\\) 좌표 또는 동거(easting)와 북거(northing)로 나타낸다.\n\n한 데이텀을 다른 데이텀으로 변환하는 과정을 데이텀 변환이라고 한다. 투영과 좌표계는 공간참조계(spatial reference system)의 설정과 관련된 개념이며, 이에 대해서는 2장에서 자세히 설명한다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#래스터-데이터와-벡터-데이터",
    "href": "01.html#래스터-데이터와-벡터-데이터",
    "title": "1  시작하기",
    "section": "\n1.3 래스터 데이터와 벡터 데이터",
    "text": "1.3 래스터 데이터와 벡터 데이터\n포인트, 라인, 폴리곤 지오메트리는 벡터(vector) 데이터의 대표적인 예이다. 벡터 지오메트리를 구성하는 좌표값은 지표상의 ‘정확한’ 위치를 나타낸다. 이에 반해, 래스터 데이터는 주로 정사각형 픽셀로 구성된 격자망(이를 래스터(raster)라고 부른다)에 각 셀의 속성값이 할당된 형태의 데이터이다. 래스터 데이터의 예는 그림 1.4에 제시되어 있다.\n\n\n\n\n\n그림 1.4: 브라질의 대서양 연안 도시 올린다에 대한 래스터 지도: (a) Landsat-7의 청색 밴드를 타나낸 것으로 서로 다른 컬러는 속성값의 차이를 나타냄. (b) 좌상의 10 X 10 픽셀만 확대하여 나타냄. (c) 3개의 표본 포인트로 구성된 벡터 데이터를 중첩하여 나타냄. (d) 표본 포인트로부터 반경 500 m를 나타낸 3개의 폴리곤으로 구성된 벡터 데이터를 중첩하여 나타냄.\n\n\n벡터 데이터와 래스터 데이터는 여러 방식으로 결합할 수 있다. 예를 들어, 그림 1.4(c)에 나타난 세 개의 포인트에 해당하는 래스터 값을 추출할 수 있으며, 그림 1.4(d)에 나타난 원 내부에 포함된 모든 래스터 값을 선택적으로 추출할 수도 있다.\n래스터에서 벡터로의 전환은 7.6절에서 다루며, 다음과 같은 내용을 포함한다.\n\n래스터 픽셀 값을 포인트의 속성값으로 전환하기\n래스터 픽셀 값을 폴리곤의 속성값으로 전환한 후, 동일한 속성값을 가진 폴리곤을 병합하기(‘폴리곤 생성’)\n특정 범위의 값을 가진 연속적인 픽셀 영역을 라인이나 폴리곤으로 표현하기(‘등치선 생성’)\n\n\n\n\n\n\n그림 1.5: 그림 1.1에 나타나 있는 카운티별 출생아 수(1974~1978)를 래스터화하여 나타낸 지도\n\n\n그림 1.5에 나타난 벡터에서 래스터로의 전환(폴리곤의 래스터화)은 매우 단순한 사례이다. 그러나 다른 형태의 벡터-투-래스터 전환은 보다 복잡한 통계적 모형화를 수반한다. 예를 들어 다음과 같은 경우가 있다.\n\n포인트 속성값을 내삽하여 그리드 셀에 할당하기(12장 참조)\n포인트의 밀도 분포를 추정하여 그리드 셀에 할당하기(11장 참조)\n폴리곤의 속성값을 면적 가중 내삽을 통해 그리드 셀에 할당하기(5.3절 참조)\n포인트, 라인, 폴리곤을 래스터로 직접 변환하기(7.6절 참조)",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#래스터-유형",
    "href": "01.html#래스터-유형",
    "title": "1  시작하기",
    "section": "\n1.4 래스터 유형",
    "text": "1.4 래스터 유형\n래스터 데이터의 디멘션은 행과 열이 공간 좌표계와 어떻게 연결되는가에 따라 결정된다. 그림 1.6은 그 다양한 가능성을 예시로 보여준다.\n\n\n\n\n\n그림 1.6: 다양한 래스터 지오메트리 유형\n\n\n그림 1.6에 나타나 있는 규칙(regular) 래스터는 일정한 모양(반드시 정사각형일 필요는 없음)의 그리드 셀로 구성되어 있으며, 가로축과 세로축이 \\(x\\)축(동거축)과 \\(y\\)축(북거축)과 일치한다. 그러나 이 외에도 다양한 형태의 래스터가 존재한다. 예를 들어, 가로축과 세로축이 \\(x\\)축 및 \\(y\\)축과 일치하지 않는 회전형(rotated) 래스터, 가로축과 세로축이 서로 직교하지 않는 전단형(sheared) 래스터, 특정 디멘션을 따라 셀 크기가 달라지는 직교형(rectilinear) 래스터이다. 마지막으로, 곡선형(curvilinear) 래스터는 셀의 크기나 방향이 한 디멘션에서만 결정되는 것이 아니라, 다른 디멘션의 변화에도 영향을 받는다.(역자주: 곡선형 래스터는 좌표축이 곡선 형태를 이루기 때문에, 셀의 크기와 방향이 한 축에서만 결정되는 것이 아니라 다른 축의 변화에도 의존한다. 이는 일반적인 직교 좌표 기반 래스터와 달리, 두 디멘션이 서로 얽혀 있는 구조를 가진다는 뜻이다.)\n특정 좌표참조계에 기반한 규칙 래스터가 있다고 하자. 이 래스터를 셀 구조를 그대로 유지한 채 다른 투영법으로 변환하면, 직교형 래스터가 될 수도 있고(예: 그림 1.3에서처럼 측지 좌표를 메르카토르 도법으로 변환하는 경우), 곡선형 래스터가 될 수도 있다(예: 그림 1.1에서처럼 측지 좌표를 람베르트 정형원추 도법으로 변환하는 경우). 이와 같은 변환 과정을 역으로 수행하면 원래의 래스터를 손실없이 정확히 복원할 수 있다.\n새로운 투영법이 적용된 규칙 그리드를 새로 생성하는 과정을 래스터(또는 이미지) 재투영(reprojection) 또는 워핑(warping)이라고 한다(7.8절 참조). 워핑 과정에서는 정보 손실이 발생할 수 있으며, 일반적으로 불가역적이고 여러 옵션 설정이 필요하다. 예를 들어, 새로운 셀 값을 생성할 때 인터폴레이션을 적용할지, 평균값이나 합계값을 계산할지 여부를 결정해야 하며, 이웃 셀 값을 활용한 재샘플링 적용 여부도 함께 고려해야 한다. 이러한 선택은 래스터 셀 값이 범주형인지 연속형인지에 따라 달라질 수 있다(1.6절 참조).",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#시계열-어레이-데이터-큐브",
    "href": "01.html#시계열-어레이-데이터-큐브",
    "title": "1  시작하기",
    "section": "\n1.5 시계열, 어레이, 데이터 큐브",
    "text": "1.5 시계열, 어레이, 데이터 큐브\n많은 공간데이터는 공간적 특성뿐만 아니라 시간적 특성도 함께 지닌다. 모든 관측치는 관측이 이루어진 특정 지점뿐 아니라, 관측이 수행된 특정 시점과도 결부되어 있다. 예를 들어, 노스캐롤라이나 카운티 데이터셋은 그림 1.2에서 보듯 두 시점의 관측값을 포함하고 있다. 원래 데이터셋에서는 이 두 시점의 값이 각각 별도의 변수로 저장되어 있었을 가능성이 크지만, 그림 1.2와 같이 두 개의 패싯 지도로 표현하려면 지오메트리를 반복하여 두 변수를 하나의 열로 길게 배열하는 형태로 변형해야 한다. 위컴(Wickham, 2014)은 이러한 형태를 타이디(tidy) 형태라고 부른다. 그러나 지오메트리와 연결된 긴 시계열 데이터를 다룰 때는, 시간별로 여러 열을 사용하는 방식도, 지오메트리를 반복해 하나의 열로 시간값을 나열하는 방식도 효율적이지 않을 수 있다. 이러한 경우에는 시간과 공간을 각각 하나의 차원으로 설정한 매트릭스나 어레이(array) 구조가 더 효과적일 수 있다. 이미지나 래스터 데이터는 본래 매트릭스 구조로 저장되며, 여기에 시간이 추가되면 3차원 어레이가 된다. 이렇게 여러 차원의 데이터를 저장 및 표현하는 일반적인 구조를 (시공간적) 데이터 큐브(data cube)라고 한다. 데이터 큐브는 차원의 수에 제한이 없는 어레이 구조를 의미하며, 벡터 데이터와 래스터 데이터 모두에 적용될 수 있다. 이에 대한 다양한 예시는 6장에서 다룬다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#서포트",
    "href": "01.html#서포트",
    "title": "1  시작하기",
    "section": "\n1.6 서포트",
    "text": "1.6 서포트\n단일 포인트 지오메트리가 아닌, 포인트 집합 지오메트리(다중 포인트, 라인, 폴리곤, 픽셀)를 가진 공간데이터의 경우 결부된 속성값은 해당 지오메트리와 몇 가지 서로 다른 방식으로 연결될 수 있다.\n\n지오메트리의 모든 포인트에 공통적으로 적용되는 상수값(constant value)\n지오메트리의 모든 포인트를 집합적으로 대표하는 집계값(aggregate value)\n각 지오메트리의 고유성을 나타내는 식별값(identity value)\n\n상수값의 예로는 폴리곤의 토지이용 속성이나 기반암 유형이 있고, 집계값의 예로는 카운티의 출생아수가 있으며, 식별값의 예로는 카운티 이름이 있다.(역자주: 폴리곤의 토지이용은 폴리곤 내 모든 지점에 공통적으로 적용될 수 있는 상수값이다. 반면, 카운티의 출생아 수는 카운티 내 모든 지점의 값을 합산한 집계값이므로, 특정 지점에 적용될 수는 없고 카운티 전체를 집합적으로 대표하는 값이다.)\n한 속성값과 결부된 공간적 개체를 해당 속성값의 서포트(support)라고 한다. 집계값은 ‘블록(block)’(폴리곤 또는 라인) 서포트를 가지며, 상수값은 ‘포인트’ 서포트를 가진다(동일한 값이 모든 포인트에 적용된다). 예를 들어, 그림 1.5는 폴리곤 서포트를 갖는 변수(카운티별 출생아 수)로부터, 카운티별 속성값을 해당 카운티를 구성하는 픽셀의 속성값으로 할당한 결과이다. 그러나 이렇게 생성된 래스터 지도는 의미가 없다. 속성값인 카운티별 ’총출생아 수’는 개별 래스터 셀과 무관하며, 속성값과 결부된 카운티 전체 경계조차 표시되어 있지 않다. 따라서 이 지도로부터 노스캐롤라이나 주 전체의 출생아 수나 출생아 밀도를 재계산할 수 없다.\n래스터 셀의 속성은 포인트 서포트를 가질 수도 있고, 블록 서포트를 가질 수도 있다. 포인트 서포트의 대표적인 예는 고도이다. 예를 들어 DEM(digital elevation model, 수치표고모형)에서는 보통 셀 중심점의 고도값을 셀 속성으로 저장한다. 블록 서포트(혹은 셀 서포트)의 예로는 위성영상을 들 수 있다. 이미지 픽셀의 속성값은 대개 해당 픽셀(또는 픽셀을 중심으로 한 일정 영역) 내부 값들의 평균이다. 대부분의 파일 포맷은 이러한 서포트 정보를 명시적으로 제공하지 않는다. 그러나 래스터 데이터를 애그리게이팅(aggregating) 하거나, 리그리딩(regridding) 하거나, 워핑(warping) 할 때(7.8절), 또는 포인트별 값을 추출할 때는 매우 중요한 요소가 된다.(역자주: 애그리게이팅은 공간 해상도를 낮추는 과정, 리그리딩은 그리드 체계를 바꾸는 과정, 워핑은 다른 투영법을 적용해 래스터 유형을 변환하는 것을 의미한다.)",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#공간데이터사이언스를-위한-소프트웨어",
    "href": "01.html#공간데이터사이언스를-위한-소프트웨어",
    "title": "1  시작하기",
    "section": "\n1.7 공간데이터사이언스를 위한 소프트웨어",
    "text": "1.7 공간데이터사이언스를 위한 소프트웨어\n이 책에서 기본적으로 사용하는 프로그래밍 언어는 R이며, 공간데이터사이언스를 위해 다양한 R 패키지를 활용한다. 이들 R 패키지 중 상당수는 여러 종류의 소프트웨어 라이브러리를 기반으로 동작하는데, 이러한 라이브러리들은 R만을 위해 개발된 것이 아니다. 예를 들어, 그림 1.7은 sf 패키지의 의존 관계(dependency)를 보여주며, 이를 통해 sf 패키지가 R 패키지뿐 아니라 시스템 라이브러리도 함께 사용하고 있음을 알 수 있다.\n\n\n\n\n\n그림 1.7: sf 패키지의 의존 관계: 직선은 강한 의존성을, 점선은 약한 의존성을 나타낸다.\n\n\nC 또는 C++로 작성된 라이브러리(GDAL, GEOS, PROJ, liblwgeom, s2geometry, NetCDF, udunits2)는 모두 R 커뮤니티가 아니라 (공간)데이터사이언스 전반의 다른 커뮤니티에서 개발, 유지, 활용되고 있다. 이러한 라이브러리를 사용함으로써 R 사용자들은 다른 커뮤니티와 공유하는 기술과 협업의 범위를 이해할 수 있다. R, Python, Julia는 인터랙티브한 인터페이스를 제공하기 때문에 많은 사용자가 이러한 라이브러리를 기반으로 한 응용 소프트웨어 사용자들보다 라이브러리에 더 직접적으로 접근할 수 있다. 이 책의 제1부에서는 이러한 라이브러리에 내재된 핵심 개념을 설명하며, 이는 공간데이터사이언스를 폭넓게 이해하는 데 큰 도움이 될 것이다.\n\n1.7.1 GDAL\nGDAL(Geospatial Data Abstraction Library)은 공간데이터 처리에서 ’스위스 만능칼’과 같은 역할을 한다고 할 수 있다. GDAL은 R, Python, PostGIS를 비롯해 100개가 넘는 다른 소프트웨어 프로젝트에서 폭넓게 사용되고 있다.\nGDAL은 공간데이터를 읽고 쓸 수 있게 해주는 라이브러리 가운데서도 핵심적인 라이브러리로, 수많은 다른 라이브러리에 의존한다. 약 100개가 넘는 라이브러리와 연동되며, 각 라이브러리는 특정 데이터 파일 포맷, 특정 데이터베이스, 특정 웹서비스 또는 특정 압축 코덱을 처리한다.\nCRAN에서 배포되는 바이너리 형식의 R 패키지에는 스태틱 링크 코드(statically linked code)만 포함되어 있다. 이는 CRAN이 패키지를 배포하는 시스템에 서드파티(third-party) 라이브러리가 설치되어 있다고 가정하지 않기 때문이다. 그 결과 CRAN에서 바이너리 형식의 sf 패키지를 설치하면 sf 패키지의 의존성뿐 아니라 모든 외부 라이브러리도 함께 다운로드되어, 설치 파일 용량이 약 100MB에 달한다.(역자주: CRAN은 The Comprehensive R Archive Network의 약자로, R 패키지를 저장하는 중앙 저장소이다. R 언어 자체의 과거와 현재 버전뿐 아니라 20,000개 이상의 R 패키지가 모여 있다. 1997년 쿠르트 호르닉(Kurt Hornik)과 프리드리히 라이슈(Friedrich Leisch)가 처음 만들었으며, 현재도 쿠르트 호르닉과 많은 자원봉사자가 운영하고 있다. 스태틱 링크 코드는 컴파일 시점에 필요한 라이브러리나 의존성을 실행 파일에 미리 포함시켜 만든 코드를 의미한다.)\n\n1.7.2 PROJ\nPROJ(혹은 PR\\(\\phi\\)J)는 지도 투영과 데이텀 변환을 위한 라이브러리로, 공간 좌표를 한 CRS에서 다른 CRS로 변환한다. PROJ에는 현재까지 알려진 수많은 투영법에 대한 데이터베이스가 포함되어 있으며, 데이텀 변환을 위한 고정밀 계수값을 담은 데이터 그리드에 접근할 수 있다. 또한 PROJ는 CRS에 관한 국제 표준을 따른다(Lott 2015). 좌표계와 PROJ에 대해서는 2장에서 자세히 다룬다.\n\n1.7.3 GEOS와 s2geometry\nGEOS(Geometry Engine Open Source)와 s2geometry는 지오메트리 연산을 위한 라이브러리이다. 이들 라이브러리를 활용하면 기하학적 측정(길이, 면적, 거리), 프레디케이트(predicate)(두 지오메트리가 포인트를 공유하는지 여부), 새로운 지오메트리 생성(두 지오메트리가 공유하는 포인트) 등의 연산을 수행할 수 있다.(역자주: 프레디케이트는 특정 조건이 참인지 거짓인지 판별하는 논리 연산을 의미한다. 공간데이터 연산에서는 두 지오메트리가 접하는지, 포함하는지, 겹치는지 등을 판정하는 함수나 연산자를 지칭한다. ‘(공간) 관계 연산자’ 등으로 번역하기도 하지만 여기서는 원어를 음역한 ’프레디케이트’를 그대로 사용한다.) GEOS는 이러한 연산을 2차원 평면(\\(R^2\\))에서 수행하며, s2geometry는 이를 3차원 구면(\\(S^2\\))에서 수행한다. CRS에 대해서는 2장에서, 그리고 2차원 공간과 3차원 공간을 다루는 차이점은 4장에서는 좀 더 깊이 논의한다.\n\n1.7.4 NetCDF, udunits2, liblwgeom\nNetCDF(UCAR 2020)는 파일 형식이자 NetCDF 파일을 읽고 쓰기 위한 C 라이브러리를 의미한다. NetCDF를 통해 모든 차원의 어레이를 정의할 수 있으며, 특히 기후 모형화 커뮤니티에서 공간 및 시공간 정보를 다루는 데 널리 사용된다. Udunits2(UCAR 2014; Pebesma, Mailud, and Hiebert 2016; Pebesma et al. 2022)는 측정 단위와 관련된 데이터베이스이자 소프트웨어 라이브러리로, 측정 단위 간 전환과 파생 단위 처리를 지원하며 사용자 정의 단위도 사용할 수 있다. liblwgeom ’라이브러리’는 PostGIS(Obe and Hsu 2015)의 소프트웨어 구성 요소로서, GDAL이나 GEOS에서는 다루지 않는 몇 가지 루틴을 포함한다. 예를 들어 PROJ가 포함된 GeographicLib 루틴에 손쉽게 접근할 수 있게 해준다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#연습문제",
    "href": "01.html#연습문제",
    "title": "1  시작하기",
    "section": "\n1.8 연습문제",
    "text": "1.8 연습문제\n\n래스터 데이터와 백터 데이터의 차이점 다섯 가지를 열거하시오.\n그림 1.1 아래에 나열되어 있는 것 외에, 지도의 그래픽 요소 다섯 개를 더 열거하시오.\n그림 1.5에 나타나 있는 수치 정보가 왜 오해를 불러일으키는지(혹은 무의미한지)에 대해 얘기해 보시오.\n지오메트리 연산을 \\(S^2\\)에서 수행하는 것과 \\(R^2\\)에서 수행하는 것의 차이가 가장 극명하게 드러나는 상황을 예로 들어 설명하시오.\n\n\n\n\n그림 1.1: 첫 번째 지도: 미국 노스캐롤라이나의 카운티별 출생아수, 1974~1978년\n그림 1.2: 미국 노스캐롤라이나 카운티별 영아돌연사증후군에 의한 사망아수의 패싯 지도, 1974~1978년과 1979~1984년\n그림 1.4: 브라질의 대서양 연안 도시 올린다에 대한 래스터 지도: (a) Landsat-7의 청색 밴드를 타나낸 것으로 서로 다른 컬러는 속성값의 차이를 나타냄. (b) 좌상의 10 X 10 픽셀만 확대하여 나타냄. (c) 3개의 표본 포인트로 구성된 벡터 데이터를 중첩하여 나타냄. (d) 표본 포인트로부터 반경 500 m를 나타낸 3개의 폴리곤으로 구성된 벡터 데이터를 중첩하여 나타냄.\n그림 1.5: 그림 1.1에 나타나 있는 카운티별 출생아 수(1974~1978)를 래스터화하여 나타낸 지도\n그림 1.6: 다양한 래스터 지오메트리 유형\n그림 1.7: sf 패키지의 의존 관계: 직선은 강한 의존성을, 점선은 약한 의존성을 나타낸다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "02.html",
    "href": "02.html",
    "title": "2  좌표계",
    "section": "",
    "text": "2.1 물리량, 단위, 데이텀\nVIM(‘International Vocabulary of Metrology(국제 측정학 어휘)’, BIPM et al. 2012)에 따르면 물리량(quantity)은 “현상, 물체, 또는 물질의 성질 중, 그 성질이 수치와 기준에 의거해 표현될 수 있는 크기(magnitude)를 가진 것”으로 정의된다.(역자주: 물리량은 단순한 수량이 아니라 측정 가능한 속성을 의미한다.) 여기서 “기준은 측정 단위, 측정 절차, 기준 물질 또는 이러한 것들의 조합일 수 있다.”라고 기술한다. 모든 데이터가 물리량으로 구성되어 있는지에 대해서는 논란의 여지가 있을 수 있지만, 적절한 데이터 처리를 위해서는 수치(또는 기호)가 무엇을 의미하는지, 특히 수치가 어떤 기준에 근거하고 있는지에 대한 정보가 반드시 필요하다는 점에 대해서는 논란의 여지가 없다.\n측정 시스템은 기본 물리량에 대한 기본단위와, 기본 단위를 조합하여 정의한 파생단위로 구성된다. 예를 들어, SI 단위계(Bureau International des Poids et Mesures 2006)는 다음 일곱 가지 기본 단위로 이루어져 있다. 길이(미터, m), 질량(킬로그램, kg), 시간(초, s), 전류(암페어, A), 열역학적 온도(켈빈, K), 물질의 양(몰, mol), 그리고 광도(칸델라, cd)이다. 파생단위는 기본단위의 정수 거듭제곱의 곱으로 정의되며, 속도(\\(\\text{m s}^{-1}\\))나 밀도(\\(\\text{kg m}^{-3}\\)), 면적(\\(\\text{m}^{2}\\)) 등이 이에 해당한다.\n이 일곱 가지 SI 기본단위로 표현되지 않는 것을 무단위(unitless) 측정치라 한다. 무단위 측정치는 크게 두 가지로 구분할 수 있다. 첫째, 단위가 상쇄되는 경우로, 질량 분율(kg/kg)이나 각도(rad = m/m)가 여기에 속한다. 둘째, 계수 단위를 사용하는 경우로, 예를 들어 ‘사과 5개’와 같이 사물이나 사건을 단순히 세는 경우이다. 이 두 경우는 모두 수학적으로는 무차원으로 취급되지만, 의미적으로는 서로 구별된다. 예컨대 각도와 사과 개수를 더하는 것은 전혀 의미가 없지만, 사과 5개와 오렌지 3개는 과일 개수라는 상위 범주(superclass)로 묶어 해석하면 더할 수 있다.(역자주: ‘개’, ‘명’, ’마리’와 같이 사물이나 사건을 셀 때 사용하는 단위를 계수 단위(counting unit)라고 한다. 이러한 계수 단위는 일상적으로는 단위처럼 인식되지만, SI 에서는 차원이 없는 무차원 단위로 취급된다. 예컨대 ’과일 개수’와 같은 계수 단위는 SI 단위에는 속하지 않지만, 서로 다른 객체(사과와 오렌지 등)를 공통의 범주 아래에서 합산할 수 있도록 하는 연산적 틀을 제공한다.) 많은 데이터 변수는 이처럼 SI 기본단위나 유도단위로 환원할 수 없는 단위를 갖는다. Hand(2004)는 사회과학에서 지능과 같은 변수를 측정하는 척도를 포함하여, 이러한 다양한 측정 척도를 단위 개념의 맥락에서 논의하고 있다.\n많은 물리량의 자연스러운 원점은 0이다. 이는 양의 차이를 계산했을 때 음수 값도 의미를 갖는다는 점에서 알 수 있다. 위치나 시간의 경우에도 차이는 자연스럽게 0을 기준으로 해석된다. 다시 말해, 거리는 위치의 차이를, 지속 시간은 시간의 차이를 의미한다. 절대적 위치(좌표)와 절대적 시간은 다른 절대적 시공간 점들을 의미 있게 측정하기 위해 고정된 원점을 필요로 하며, 이를 데이텀(datum)이라 부른다. 공간에서의 데이텀은 하나 이상의 차원을 포함한다. 데이텀에 측정 단위(스케일)가 결합되면 이를 참조계(reference system)라고 한다.\n이후에서는 공간적 위치를 타원체 좌표 또는 데카르트 좌표로 표현하는 방법을 자세히 살펴본다. 다음 절에서는 시간 및 공간 참조계와, R에서 이러한 참조계를 다루는 방법을 설명한다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>좌표계</span>"
    ]
  },
  {
    "objectID": "02.html#타원체-좌표계",
    "href": "02.html#타원체-좌표계",
    "title": "2  좌표계",
    "section": "\n2.2 타원체 좌표계",
    "text": "2.2 타원체 좌표계\n\n\n\n\n\n그림 2.1: 2차원 극 좌표와 데카르트 좌표\n\n\n그림 2.1은 2차원 극 좌표(polar coordinate)와 데카르트 좌표(Cartesian coordinate)를 보여준다. 해당 지점의 데카르트 좌표는 \\((x,y)=(3,4)\\)로 주어지고, 극 좌표는 \\((r,\\phi)=(5,\\text{arctan(4/3)})\\)로 주어지는데 \\(\\text{arctan(4/3)}\\)는 대략 \\(0.93\\) 라디안 혹은 \\(53^\\circ\\)이다. 여기서 \\(x\\), \\(y\\), \\(r\\)은 모두 길이 단위이고 \\(\\phi\\)는 각도 단위(무단위 길이/길이 비)라는 점에 유의할 필요가 있다. 데카르트 좌표와 극 좌표 간의 변환은 매우 간단하다.\n\\[\nx=r\\cos\\phi,\\quad y=r\\sin\\phi, \\text{ and}\n\\]\n\\[\nr=\\sqrt{x^2+y^2}, \\quad \\phi=\\text{atan2}(y,x)\n\\]\n여기서 \\(\\text{atan2}\\)이 \\(\\text{atan}(y/x)\\)대신 사용되었는데, 오른쪽 일사분면에 위치가 있기 때문이다.\n\n2.2.1 구체 혹은 타원체 좌표\n3차원의 경우, 데카르트 좌표는 \\((x,y,z)\\)로 주어지고, 극 좌표는 \\((r,\\lambda,\\phi)\\)로 주어진다.\n\n\\(r\\)은 구체의 반지름이다.\n\\(\\lambda\\)는 경도로, \\((x,y)\\) 평면에서 양의 \\(x\\)축으로부터 반시계방향으로 측정된다.\n\\(\\phi\\)는 위도로, \\((x,y)\\) 평면과 해당 벡터가 이루는 각도이다.\n\n그림 2.2는 데카르트 지심 좌표(Cartesian geocentric coordinate)와 타원체 좌표(ellipsoidal coordinate)를 보여준다.\n\n\n\n\n\n그림 2.2: 세 개의 거리로 표현되는 데카르트 지심 좌표(왼편)와 두 개의 각도와 하나의 타원체고로 표현되는 타원체 좌표(오른편)\n\n\n\\(\\lambda\\)는 \\(-180^\\circ\\)에서 \\(180^\\circ\\) 사이(혹은 \\(0^\\circ\\)에서 \\(360^\\circ\\) 사이)의 값을 가지며, \\(\\phi\\)는 \\(-90^\\circ\\)에서 \\(90^\\circ\\) 사이의 값을 갖는다. 타원체가 아니라 반지름이 고정된 구체(혹은 구체 상의 위치)를 전제로 한다면, 위의 \\(r\\) 값을 생략한 \\((\\lambda,\\phi)\\) 만으로도 모든 위치를 고정할 수 있다.\n이 정의가 유일한 것은 아니라는 점에 유의해야 한다. 예를 들어, 위도 대신 해당 벡터와 \\(z\\)축 사이의 각도(극각)을 사용할 수도 있다. 또한, 좌표를 \\((\\phi,\\lambda)\\) 순서로 표기하는 오랜 전통도 존재하지만, 이 책에서는 경도-위도 형식인 (\\(\\lambda,\\phi\\))를 사용한다. 그림 2.2에 표시된 지점은 \\((\\lambda,\\phi)\\) 형식으로 표현되는, 각도 단위의 타원체 좌표를 가진다.\n# POINT (60 47)\n지심 좌표값은 미터 단위로 주어진다.\n# POINT Z (2178844 3773868 4641765)\n타원체 상의 지점에 대해서는 각도를 나타내는 두 가지 방법이 있다(그림 2.3). 하나는 타원체의 중심을 기준으로 측정된 각도(\\(\\psi\\)), 또는 해당 지점을 지나는 접선에 수직으로 측정된 각도(\\(\\phi\\))이다.\n\n\n\n\n\n그림 2.3: 타원체 상의 각도: 측지 위도(파란색)와 지심 위도(붉은색)\n\n\n지구를 표현하는 데 가장 널리 사용되는 파라메트릭 모형은 회전타원체(ellipsoid of revolution)이다. 회전타원체는 길이가 서로 다른 반장축과 반단축을 가진 타원체로, 한쪽 방향이 약간 납작해진 구(또는 구체, spheroid)라고 할 수 있다(Iliffe and Lott 2008). 실제로, 지구의 남북 길이는 동서 길이보다 약간(약 0.33%) 짧다. 이 모형에서 경도는 항상 원을 따라 측정되고(그림 2.2), 위도는 타원을 따라 측정된다(그림 2.3). 그림 2.3을 양 극을 지나는 지구의 단면도로 본다면, 별도의 언급이 없는 경우 위도는 파란선으로 표시된 측지 위도(geodetic latitude)를 의미한다. 이에 대응하여 지심 위도(geocentric latitude)라는 개념도 존재한다.(역자주: 측지 위도는 적도면과, 특정 지점에서 회전타원체에 접하는 평면의 법선이 이루는 각도를 의미한다. 반면 지심 위도는 적도면과, 특정 지점과 지구 중심을 잇는 직선이 이루는 각도를 의미한다. 완전한 구를 가정하면 두 위도는 일치한다. 측지 위도의 경우 위도 1도의 남북 길이는 고위도로 갈수록 길어지지만, 지심 위도에서는 일정하게 나타난다.)\n경도와 위도에 고도(altitude)나 높이(elevation)를 더하면, 회전타원체의 위나 아래에 있는 지점의 위치까지 정의할 수 있으며, 이를 통해 완전한 3차원 위치 참조계를 구성할 수 있다. 고도를 정의할 때는 다음을 선택해야 한다.\n\n고도 0의 기준을 어디에 둘 것인가: 회전타원체 상에 둘 것인가, 아니면 평균 해수면을 근사한 지오이드(geoid) 표면을 기준으로 할 것인가?\n양(+)의 방향을 어디로 할 것인가?\n‘위쪽’ 방향을 어떻게 정의할 것인가: 회전타원체 표면에 수직인 방향으로 할 것인가, 아니면 지오이드 표면에 수직인, 중력의 방향으로 할 것인가?\n\n응용 분야와 요구되는 측정 정밀도에 따라 이러한 선택들이 중요해질 수 있다.\n지구는 완전한 회전타원체가 아니기 때문에, 다양한 회전타원체가 제안되어 사용되고 있다. 이들 회전타원체는 반장축과 반단축의 길이와 같은 파라미터 값이 서로 다를 수 있고, 지구에 정합시키는 방식 또한 다를 수 있다. 이처럼 특정한 방식으로 규정된 회전타원체를 데이텀(datum)이라 하며, 좌표참조계(coordinate reference system)와 함께 2.3절에서 간략히 다룬다.\n\n2.2.2 투영 좌표계와 거리\n투영 좌표계(projected coordinate system)는 지구 표면의 위치를 2차원 평면 위에서 표현하는 좌표계이다. 종이 지도와 컴퓨터 화면이 지구본보다 훨씬 더 실용적이고 널리 사용되기 때문에, 우리는 공간데이터를 대개 이러한 2차원 평면에 투영된 형태로 보게 된다. 이차원 공간에서 위치를 계산한다는 것은 곧 투영 좌표를 사용한다는 뜻이다. 타원체 좌표를 평면으로 투영하면 형태, 방향, 면적 중 하나 이상이 반드시 왜곡된다(Iliffe and Lott 2008).\n데카르트 좌표에서 두 지점 \\(p_i\\)와 \\(p_j\\) 간의 거리는 유클리드 거리로 계산되며, 2차원의 경우 \\(p_i=(x_i,y_i)\\)이므로 다음의 수식으로 주어진다.\n\\[\nd_{ij}=\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\n\\]\n3차원의 경우는 \\(p_i=(x_i,y_i,z_i)\\)이므로, 다음의 수식으로 주어진다.\n\\[\nd_{ij}=\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}\n\\]\n이 거리는 지점 \\(i\\)와 지점 \\(j\\) 사이의 직선거리를 뜻한다. 즉, 두 지점을 직선으로 연결했을 때 그 선분의 길이를 의미한다.\n반지름이 \\(r\\)인 원 위에서, 두 지점 \\(c_1=(r,\\phi_1)\\)와 \\(c_2=(r,\\phi_2)\\) 사이의 호 길이는 다음과 같이 주어진다. \\[\ns_{ij}=r|\\phi_1-\\phi_2|=r\\theta\n\\]\n여기서 \\(\\theta\\)는 \\(\\phi_1\\)과 \\(\\phi_2\\) 사이의 각도를 라디안 단위로 나타낸다. \\(\\theta\\)가 매우 작을 경우, 호가 직선에 가까워지므로 \\(s_{ij}\\approx d_{ij}\\)가 성립한다.\n반지름이 \\(r'\\)인 구체 위의 두 지점 \\(p_1=(\\lambda_1,\\phi_1)\\)과 \\(p_2=(\\lambda_2,\\phi_2)\\)를 지나는 원(중심은 구체의 중심과 일치)에서, 두 지점 사이의 호의 길이를 대권거리(great circle distance)라 하며, 이는 \\(s_{12}=r\\theta_{12}\\)로 표현된다. 따라서 \\(p_1\\)과 \\(p_2\\) 사이의 각도 \\(\\theta_{12}\\)(라디안 단위)는 다음과 같이 주어진다.\n\\[\n\\theta_{12}=\\arccos(\\sin\\phi_1\\cdot \\sin\\phi_2+\\cos\\phi_1\\cdot \\cos\\phi_2\\cdot\\cos(|\\lambda_1-\\lambda_2|))\n\\]\n타원체 위의 두 지점 사이의 호의 길이를 계산하는 일은 훨씬 더 복잡하다. Karney(2013)은 이에 대해 심도 있는 논의를 제시하였으며, PROJ 라이브러리의 일부인 GeographicLib에서 구현된 방법에 대한 상세한 설명도 제공한다.\n이러한 거리 계산 방법들이 실제로 서로 다른 값을 산출한다는 점을 보이기 위해, 우리는 베를린과 파리 사이의 거리를 계산하였다. WGS84 타원체와 완전 구체 각각에 대해 거리를 구했으며, 여기서 gc_는 대권거리를, str_은 지심 좌표값을 이용한 직선거리를 나타낸다.\n# Units: [km]\n#  gc_ellipse str_ellipse   gc_sphere  str_sphere \n#      879.70      879.00      877.46      876.77\n\n2.2.3 한정 공간과 비한정 공간\n2차원 및 3차원 유클리드 공간(\\(R^2\\)와 \\(R^3\\))은 비한정 공간(unbounded space)이다. 이 공간의 모든 선은 무한한 길이를 가지며, 면적이나 부피는 자연적인 상한이 없다. 이에 비해 원(\\(S^1\\))이나 구(\\(S^2\\))와 같은 공간은 한정 공간(bounded space)이다. 이 경우 점의 개수는 무한할 수 있지만, 원의 둘레와 면적, 구의 반지름과 표면적, 부피는 유한하다.\n이 차이는 사소해 보일 수 있으나, 공간데이터 처리에서는 흥미로운 도전 과제를 유발한다. 예를 들어, \\(R^2\\) 상의 폴리곤은 명확히 내부와 외부가 구분된다. 그러나 \\(S^2\\) 공간인 구체 상에서 모든 폴리곤은 구를 두 영역으로 나누며, 어느 쪽을 내부로, 어느 쪽을 외부로 정의할지는 탐색 방향(traversal direction)에 따라 달라진다. 이러한 \\(S^2\\) 지오메트리에서의 차이는 4장에서 다시 논의한다.(역자주: 탐색 방향이란 폴리곤 경계를 따라가는 방향을 의미한다. 일반적으로 평면(\\(R^2\\))에서는 경계를 시계 방향으로 탐색하면 왼쪽에 있는 영역이 내부로, 반시계 방향으로 탐색하면 오른쪽에 있는 영역이 내부로 간주된다. 그러나 구현 방식이나 좌표계 종류(예: 구면 좌표계)에 따라 내부와 외부의 정의가 달라질 수 있으므로, 적용 환경에 맞는 판정 규칙을 확인해야 한다.)",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>좌표계</span>"
    ]
  },
  {
    "objectID": "02.html#crs",
    "href": "02.html#crs",
    "title": "2  좌표계",
    "section": "\n2.3 CRS",
    "text": "2.3 CRS\nLott(2015)를 따라, 다음과 같은 개념 정의를 사용한다(이탤릭체는 Lott의 정의를 그대로 옮겨 온 것이다)\n\n좌표계는 지점에 좌표를 부여하는 방법을 규정하는 수학적 규칙의 집합이다.\n데이텀은 좌표계의 원점, 축척, 방향을 정의하는 파라미터 또는 파라미터의 집합이다.\n측지 데이텀은 2차원 또는 3차원 좌표계와 지구와의 관계를 설명하는 데이텀이다.(역자주: 즉, 지구에 부여된 2차원 또는 3차원 좌표계를 정의하는 데이텀이다.)\nCRS(좌표참조계)는 특정 데이텀을 바탕으로 특정 객체에 부여된 좌표계이다. 측지 데이텀과 수직 데이텀의 경우, 그 객체는 지구이다.(역자 주: 측지 데이텀은 지구 표면상의 위치를 규정하는 수평 데이텀이며, 수직 데이텀은 말 그대로 지표의 높이를 규정하는 데이텀이다).\n\n이 개념에 대한 보다 상세하고 친절한 설명은 Iliffe와 Lott(2008)에서 찾아볼 수 있다.\n지구의 형태는 규칙적이지 않다. 지표면의 기복이 매우 불규칙하다는 사실은 널리 알려져 있지만, 평균해수면 개념과 연결되는 일정한 중력면, 즉 지오이드(geoid) 또한 불규칙한 형상을 띤다. 지오이드를 단순화한 모형 가운데 가장 일반적으로 사용되는 것은 회전타원체로, 이는 두 개의 동일한 반단축을 가진 타원이다. 이 회전타원체를 지구와 어떻게 맞출 것인지가 데이텀을 규정한다. 타원체를 지구의 어느 부분에 일치시킬지, 또는 어떤 기준점을 사용할지에 따라 타원체의 적합도는 달라질 수 있으며, 이러한 이유로 다양한 데이텀이 존재한다. 일부 데이텀은 특정 지각판에 대한 적합도를 중시하기도 하고(예: ETRS89), 다른 데이텀은 전 세계적인 평균 적합도를 지향하기도 한다(예: WGS84). 국지적 적합도에 중점을 둘수록 해당 지역에서의 위치 근사 오차는 작아진다.\n위의 정의에서 알 수 있듯이, 경도와 위도로 표현된 좌표값은 해당 데이텀이 함께 제공될 때에만 지구 좌표계로서 의미를 가지며, 이를 통해 해석상의 모호성을 제거할 수 있다.\n특정 투영법이 적용된 데이터는 반드시 해당하는 참조 타원체(데이텀)와 결부되어 있다는 점에 유의해야 한다. 데이텀 전환 없이 투영법만 변경하는 작업은 좌표 전환(coordinate conversion)이라고 하며, 이는 해당 데이텀에 결부된 특정 타원체상의 좌표값을 기준으로 수행된다. 좌표 전환 과정은 정보 손실이 없고 가역적이며, 전환에 사용되는 파라미터와 수식은 변하지 않는다.\n새로운 데이텀에 따라 좌표를 재계산하는 과정을 좌표 변환(coordinate transformation)이라 한다. 좌표 전환과 달리, 좌표 변환은 근사적으로 수행된다. 이는 데이텀이 지구에 대한 모형 적합의 결과물이므로, 데이텀 간 변환 또한 하나의 적합된 모형으로 간주되기 때문이다. 변환 함수 역시 경험적으로 도출되며, 적합도나 정확성의 설정에 따라 다양한 변환 경로가 존재할 수 있다.\n판 구조론은 글로벌 데이텀에서 고정된 객체의 위치가 시간이 흐름에 따라 변할 수 있음을 보여준다. 이는 데이텀 간 좌표 변환이 시간에 따라 달라질 수 있음을 시사한다. 예를 들어, 지진과 같은 지각 운동으로 인해 특정 지역의 좌표가 갑작스럽게 변동할 수 있다. 국지적 데이텀은 특정 지각판에 고정하여 정의할 수도 있지만(예: ETRS89), 이를 보다 역동적으로 설정하여 시간에 따른 위치 변화를 반영하도록 할 수도 있다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>좌표계</span>"
    ]
  },
  {
    "objectID": "02.html#proj와-지도-정확도",
    "href": "02.html#proj와-지도-정확도",
    "title": "2  좌표계",
    "section": "\n2.4 PROJ와 지도 정확도",
    "text": "2.4 PROJ와 지도 정확도\n오늘날 오픈소스 지리공간 소프트웨어 분야에서 활동하는 사람들 중에는 PROJ 이전의 시기를 기억하는 이가 거의 없다. PROJ(Evenden, 1990)는 1970년대에 포트란 기반 프로젝트로 시작되어, 1985년 지도 투영을 위한 C 라이브러리로 공개되었다. 이 라이브러리는 직접 투영과 역투영을 수행할 수 있는 명령줄 인터페이스를 제공했으며, 이를 다른 소프트웨어와 연동하여 투영 및 재투영 작업을 즉시 실행할 수 있었다. 당시에는 데이텀이 단순히 주어진 것으로 간주되었고, 데이텀 간 변환 기능은 지원되지 않았다.\n2000년대 초, PROJ는 PROJ.4라는 이름으로 불리게 되었는데, 이는 고정된 버전 번호가 접미사로 붙은 형태였다. GPS의 보급 확대를 비롯한 여러 요인으로 좌표계 간 변환 수요가 증가하자, PROJ.4는 기본적인 데이텀 지원 기능을 갖추게 되었다. 이후 PROJ는 CRS를 다음과 같은 형식으로 정의하게 된다.\n+proj=utm +zone=33 +datum=WGS84 +units=m +no_defs\n‘키=값’ 쌍은 + 기호로 시작하며, 공백으로 구분된다. 이러한 형식은 PROJ 프로젝트가 수십 년 동안 4.x 버전을 유지하면서, 일반적으로 ’PROJ.4 문자열’로 불리게 되었다. 아래는 그 몇 가지 예시이다.\n+ellps=bessel +towgs84=565.4,50.3,465.6,-0.399,0.344,-1.877,4.072\n이 문자열은 해당 데이텀이 Bessel 타원체를 사용하며, 이를 WGS84(주로 GPS의 기준으로 널리 사용됨)로 변환하기 위해 7개(또는 경우에 따라 3개)의 파라미터가 필요함을 잘 보여준다.\nPROJ.4 외에도 다양한 투영법 관련 데이터베이스가 구축되었는데, 그중 가장 널리 알려진 것이 EPSG(European Petroleum Survey Group) 레지스트리이다. 각국의 지도 제작 기관은 자국 CRS의 +towgs84 파라미터(즉, WGS84로 변환하기 위한 파라미터)에 대해 최적 추정값을 계산하고, 이를 지속적으로 갱신하여 EPSG 등록부를 통해 배포해 왔다. 일부 좌표 변환에는 데이텀 그리드(datum grid)가 함께 제공되었는데, 이는 PROJ.4의 일부로도 배포되었다. 데이텀 그리드는 결국 래스터 형식의 지도이며, 데이텀 변환 시 발생하는 경도, 위도, 고도 변화값을 모든 지점에 대해 미리 계산해 둔 데이터를 의미한다.\nPROJ.4에서는 모든 좌표 변환이 반드시 WGS84를 경유하여 수행되었다. 서로 다른 데이텀을 가진 데이터를 재투영할 때도, 중간 단계로 WGS84로 변환한 뒤 목표 좌표계로 변환해야 했다. 이로 인해 최대 약 100m의 오차가 발생할 수 있었는데, 이는 비교적 넓은 지역을 대상으로 하는 지도 제작에서는 수용 가능한 수준이었다. 그러나 정밀 농업, UAV(무인항공기) 운용 계획, 객체 추적 등 일부 응용 분야에서는 이보다 훨씬 높은 정밀도의 좌표 변환이 요구된다.\n2018년, ‘GDAL 좌표계 공동 개발(Coordinate System Unification)’ 이니셔티브가 성공적으로 추진된 이후, 오픈소스 지리공간 소프트웨어 스택의 혜택을 받아온 여러 기업들이 PROJ의 보다 현대적이고 고도화된 좌표 변환 시스템 개발을 지원하였다. 그 결과 PROJ.4는 5, 6, 7, 8, 9 버전을 거치며 지속적으로 발전했고, 명칭도 PROJ또는 PR\\(\\phi\\)J)로 변경되었다.\n가장 주목할 만한 변화는 다음과 같다.\n\nPROJ.4 문자열의 한계와 WKT-2 도입: PROJ.4 문자열은 여전히 새로운 CRS를 정의하는 데 사용할 수 있지만, 모든 CRS를 포괄하기에는 한계가 있음이 드러났다. 이를 대체하기 위해 WKT-2 형식이 도입되었으며, 이에 대해서는 다음 절에서 설명한다.\nWGS84dml ‘허브 데이텀’ 지위 폐지: 좌표 변환 시 WGS84와 같은 특정 데이텀을 중간 단계로 거칠 필요 없이, 직접 데이텀 간 변환이 가능해졌다.\n다중 변환 경로(파이프라인) 지원: 하나의 CRS(A)에서 다른 CRS(B)로 이동할 때 사용할 수 있는 다수의 변환 또는 전환 경로가 존재할 수 있으며, 각 경로에 대한 정확도 정보가 제공되면 등록할 수 있다. PROJ는 기본적으로 가장 정확한 경로를 자동 선택하지만, 사용자가 직접 선택할 수도 있다.\n변환 파이프라인 구성 가능: 변환 파이프라인은 축 교환, 단위 변환 등 여러 기본 변환 단계를 연결하여 구성될 수 있다.\n데이텀 그리드 배포 방식 변경: 데이텀 그리드는 더 이상 라이브러리에 포함되지 않으며, 대신 콘텐츠 전송 네트워크(CDN)를 통해 제공된다. PROJ는 네트워크 접근을 켜거나 끌 수 있는 옵션을 제공하며, 실제 필요한 그리드 구간만 다운로드해 로컬 캐시에 저장해 이후에도 사용할 수 있다.\n에포크(epoch) 기반 좌표 변환 지원: 시간-의존적 좌표 변환이 가능해져, 소스와 타깃 시간 정보를 포함하는 4차원 좌표계 간 변환이 지원된다.(역자주: 지구의 좌표계는 시간이 지남에 따라 점진적으로 변화해 왔으며, 특정 시점(에포크)에 기반한 위치 정의가 가능해졌다는 의미다.)\n축 순서 사용자 정의 가능: 예를 들어 위도–경도(Lat–Lon) 또는 경도–위도(Lon–Lat)와 같은 축 순서를 자유롭게 변경할 수 있다.\n\n이러한 개선을 통해 좌표 변환의 정확도는 이제 1미터 이하 수준까지 향상될 수 있다. 특히 주목할 만한 변화는 마지막 항목에 있다. 수십 년 동안 경도–위도 순서를 따르는 타원체 좌표의 축 순서는 자명한 것으로 여겨져 왔으나, 이제 더 이상 그렇지 않다. 섹션 7.7.6에서는 이러한 변화에 어떻게 대응할 수 있는지를 살펴본다.\n\n\n\n\n\n그림 2.4: 영국의 OSGB 1936(EPSG:4277)를 ETRS89(EPSG:4258)로 변환하는데 사용되는 수평 데이텀 그리드\n\n\n\n\n\n\n\n그림 2.5: 영국의 ETRS89(EPSG:4937)를 ODN 고도(EPSG:5701)로 변환하는데 사용되는 수직 데이텀 그리드\n\n\n그림 2.4의 수평 데이텀 그리드 예시와 그림 2.5의 수직 데이텀 그리드 예시는 cdn.proj.org에서 다운로드한 것이다. 경우에 따라 데이텀 그리드에는 픽셀 단위의 정밀도 값이 포함되기도 한다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>좌표계</span>"
    ]
  },
  {
    "objectID": "02.html#wkt-2",
    "href": "02.html#wkt-2",
    "title": "2  좌표계",
    "section": "\n2.5 WKT-2",
    "text": "2.5 WKT-2\nLott(2015)는 CRS의 인코딩 방식과 CRS 간 변환을 WKT(well-known text)로 표현하는 표준을 정리하였다. 이 표준(및 포맷)은 비공식적으로 WKT-2라고 불린다. 앞서 언급했듯이, GDAL과 PROJ는 이 표준을 지원한다. 예를 들어, 특정 CRS인 EPSG:4326은 WKT-2 형식으로 다음과 같이 표현된다.\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n이 예시는 축 순서가 위도–경도로 설정된 좌표계를 보여준다. 그러나 실제로 사용되는 대부분의 좌표계는 경도–위도 순서를 따른다. WGS84 타원체에 대한 앙상블(ensemble)은 다양한 버전과 업데이트를 포함하고 있으며, 어떤 앙상블을 사용하는지에 따라 수 미터 수준의 오차가 발생할 수 있다. OGC:CRS84는 longitude–altitude 순서를 명시적으로 정의하고 있어 GRS84의 대안으로 권장되지만, 데이텀 앙상블 문제까지 해결해 주지는 않는다.\nPROJ의 역사와 최근 변화는 Knudsen과 Evers(2017), Evers와 Knudsen(2017)의 연구를 바탕으로 정리한 Bivand(2020)에 잘 요약되어 있다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>좌표계</span>"
    ]
  },
  {
    "objectID": "02.html#연습문제",
    "href": "02.html#연습문제",
    "title": "2  좌표계",
    "section": "\n2.6 연습문제",
    "text": "2.6 연습문제\nR을 활용하여 아래의 연습문제를 풀되, 패키지는 사용하지 않는다. 적절한 기본 함수를 찾아 활용하도록 한다.\n\n자연 원점(0)을 갖지 않는 지리적 측도 세가지를 나열하시오.\n다음의 \\((x,y)\\) 좌표, \\((10,2)\\), \\((-10,-2)\\), \\((10,-2)\\), \\((0,10)\\)을 극 좌표로 변환하시오.\n다음의 \\((r,\\phi)\\) 좌표, \\((10,45^\\circ)\\), \\((0,100^\\circ)\\), \\((5,359^\\circ)\\)를 데카르트 좌표로 변환하시오.\n지구를 반지름이 6,371 km인 완전한 구체로 가정하고, 다음 네 쌍의 (\\(\\lambda, \\phi\\)) 지점 간의 대권거리를 각도 단위로 계산하시오. 각 쌍의 위도와 경도는 각도 단위로 주어진다. \\((10,10)\\)과 \\((11,10)\\), \\((10,80)\\)과 \\((11,80)\\), \\((10,10)\\)과 \\((10,11)\\), \\((10,80)\\)과 \\((10,81)\\)\n\n\n\n\n그림 2.1: 2차원 극 좌표와 데카르트 좌표\n그림 2.2: 세 개의 거리로 표현되는 데카르트 지심 좌표(왼편)와 두 개의 각도와 하나의 타원체고로 표현되는 타원체 좌표(오른편)\n그림 2.3: 타원체 상의 각도: 측지 위도(파란색)와 지심 위도(붉은색)\n그림 2.4: 영국의 OSGB 1936(EPSG:4277)를 ETRS89(EPSG:4258)로 변환하는데 사용되는 수평 데이텀 그리드\n그림 2.5: 영국의 ETRS89(EPSG:4937)를 ODN 고도(EPSG:5701)로 변환하는데 사용되는 수직 데이텀 그리드",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>좌표계</span>"
    ]
  },
  {
    "objectID": "03.html",
    "href": "03.html",
    "title": "3  지오메트리",
    "section": "",
    "text": "3.1 심플 피처 지오메트리\n심플 피처 지오메트리(simple feature geometry)는 피처의 지오메트리를 기술하는 방식이다. 여기서 피처란 지오메트리를 가진 사물(thing)을 의미하며, 암묵적으로 시간 속성(attribute)을 포함할 수 있고, 사물을 묘사하기 위한 라벨이나 정량적 측도와 관련된 속성을 가질 수 있다. 심플 피처 지오메트리의 주된 목적은 2차원 공간에서 포인트, 라인, 폴리곤을 기반으로 기하학적 형태를 표현하는 것이다. ’심플’이라는 형용사가 붙은 이유는 라인이나 폴리곤 지오메트리도 포인트 지오메트리와 이를 연결하는 직선으로 표현할 수 있기 때문이다.\n심플 피처 액세스(simple feature access)는 심플 피처 지오메트리를 설명하는 표준(Herring 2011, 2010; ISO 2004)으로, 다음 사항을 포함한다.\n이제 가장 널리 사용되는 7가지 심플 피처 지오메트리 유형에 대해 살펴본다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>지오메트리</span>"
    ]
  },
  {
    "objectID": "03.html#심플-피처-지오메트리",
    "href": "03.html#심플-피처-지오메트리",
    "title": "3  지오메트리",
    "section": "",
    "text": "클래스 위계\n연산(오퍼레이션)의 집합\n이진 인코딩과 텍스트 인코딩\n\n\n\n3.1.1 7개의 대표 지오메트리\n단일(single) 피처를 나타내는 데 사용되는 가장 일반적인 심플 피처 지오메트리 유형은 다음과 같다.\n\n\n\n\n\n\n유형\n설명\n\n\n\nPOINT\n단일 포인트 지오메트리\n\n\nMULTIPOINT\n\nPOINT의 집합\n\n\nLINESTRING\n단일 라인스트링(두개 이상의 포인트가 직선으로 연결되어 있음)\n\n\nMULTILINESTRING\n\nLINESTRING의 집합\n\n\nPOLYGON\n외부 링과 0개 이상의 내부 링(구멍을 나타냄)으로 구성된 구조\n\n\nMULTIPOLYGON\n\nPOLYGON의 집합\n\n\nGEOMETRYCOLLECTION\n위에서 언급된 모든 지오메트리의 집합\n\n\n\n\n\n\n\n\n그림 3.1: 심플 피처 지오메트리의 주요 유형\n\n\n그림 3.1은 이러한 기본 지오메트리 유형의 예를 보여준다. 지오메트리를 표현하는, 사람이 읽을 수 있는 ‘웹 노운 텍스트(well-known text)’ WKT 표기법은 다음과 같다.\nPOINT (0 1)\nMULTIPOINT ((1 1), (2 2), (4 1), (2 3), (1 4))\nLINESTRING (1 1, 5 5, 5 6, 4 6, 3 4, 2 3)\nMULTILINESTRING ((1 1, 5 5, 5 6, 4 6, 3 4, 2 3), (3 0, 4 1, 2 1))\nPOLYGON ((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),\n    (2 2, 3 3, 4 3, 4 2, 2 2))\nMULTIPOLYGON (((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),\n    (2 2, 3 3, 4 3, 4 2, 2 2)), ((3 7, 4 7, 5 8, 3 9, 2 8, 3 7)))\nGEOMETRYCOLLECTION (\n    POLYGON ((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),\n      (2 2 , 3 3, 4 3, 4 2, 2 2)),\n    LINESTRING (1 6, 5 10, 5 11, 4 11, 3 9, 2 8),\n    POINT (2 5),\n    POINT (5 4)\n)\n좌표는 공백으로 구분되며, 포인트들은 쉼표로 구분된다. 집합은 괄호로 묶이고, 각 요소는 쉼표로 구분된다. 폴리곤은 외부 링과, 존재할 경우 내부 링(구멍을 나타냄)으로 구성된다.\n지오메트리의 각 포인트는 최소 두 개의 좌표를 포함하며, 이 좌표는 \\(x\\)와 \\(y\\) 순서로 나열된다. 이 좌표가 타원체 좌표를 나타내는 경우, \\(x\\)는 일반적으로 경도를, \\(y\\)는 위도를 의미한다. 그러나 상황에 따라 위도-경도 순서로 나열되기도 한다(2.4절 및 섹션 7.7.6 참조).\n\n3.1.2 심플 지오메트리, 밸리드 지오메트리, 링 디렉션\nLINESTRING은 자기교차(self-intersect)가 없을 때 심플 지오메트리가 된다.(역자주: ’자기교차’란 선분이 스스로를 가로지르는 경우를 말하며, 예를 들어 숫자 8 모양의 라인처럼 하나의 라인이 교차점을 형성하는 상황을 의미한다.)\n# LINESTRING (0 0, 1 1, 2 2, 0 2, 1 1, 2 0)\n# is_simple \n#     FALSE\n밸리드(valid) 폴리곤과 멀티폴리곤은 다음의 모든 프로퍼티을 갖는다.\n\n폴리곤 링은 닫혀 있어야 한다(즉, 첫번째 포인트와 마지막 포인트가 동일해야 한다)\n폴리곤 구멍(내부 링)은 외부 링 내부에 위치해야 한다.\n폴리곤 내부 링은 외부 링과 한 점에서 만날 수 있으나, 선분(라인)은 공유해서는 안 된다.\n폴리곤 링은 자신의 경로를 반복하지 않는다.\n멀티폴리곤에서 외부 링은 다른 외부 링과 한 지점에서 만날 수 있지만, 선분을 공유해서는 안 된다.\n\n이 조건들 중 하나라도 충족하지 못하면 해당 지오메트리는 밸리드 지오메트리가 아니다. 밸리드하지 않은 지오메트리는 일반적으로 연산 수행 중 오류를 일으키지만, 보통 사전에 밸리드 지오메트리로 수정된다.(역자 주: 밸리드 지오메트리를 유지하는 것은 공간분석, 지도 제작, 공간 질의에서 신뢰할 수 있는 결과를 얻기 위한 필수 조건이다. 보통 ‘유효한’, ‘정합한’, ‘합당한’ 지오메트리 등으로 번역되지만, 여기서는 프로그래밍 용어 및 함수명과의 일관성을 위해 ‘밸리드’ 지오메트리라는 표기를 사용한다.)\n추가적인 규칙으로, 폴리곤의 외부 링은 반시계 방향으로, 구멍(내부 링)은 시계 방향으로 감겨 있어야 한다.(역자 주: 여기서 ’감기다’는 것은 폴리곤 경계를 따라 점들이 연결되는 방향을 의미한다. 외부 링은 반시계 방향으로 이동할 때 왼쪽이 폴리곤 내부가 되고, 내부 링은 시계 방향으로 이동할 때 왼쪽이 폴리곤 내부, 오른쪽이 구멍(빈 공간)임을 나타낸다. 이 방향 규칙은 컴퓨터가 폴리곤 내부와 구멍을 정확히 구분하는 데 필수적이다.) 그러나 이러한 규칙을 따르지 않는 폴리곤도 여전히 밸리드 지오메트리로 간주된다. 구면상의 폴리곤의 경우 ’시계 방향’이라는 개념은 크게 유용하지 않다. 예를 들어, 적도를 폴리곤으로 간주할 때 북반구와 남반구 중 어느 쪽이 ’내부’인지 명확하지 않기 때문이다. 이 책에서는 폴리곤 경계를 따라 이동할 때 왼쪽에 위치한 영역을 폴리곤 내부로 간주하는 규칙을 채택한다(7.3절 참조).\n\n3.1.3 Z 좌표와 M 좌표\n심플 피처 지오메트리의 단일 포인트(버텍스)는 X 좌표와 Y 좌표 외에도 다음과 같은 값을 가질 수 있다.\n\nZ 좌표: 고도\nM 좌표: 측정치\n\nM 속성은 버텍스의 속성으로 간주되어야 한다. 예를 들어, LINESTRING에 이동 경로 데이터를 담기 위해 시간 정보를 M 속성에 인코딩하는 것은 매력적인 방법처럼 보일 수 있다. 그러나 경로가 자기교차하면, 이러한 LINESTRING은 밸리드하지 않거나 심플하지 않는 상태가 되는데, 이때의 자기교차 여부는 X와 Y 좌표만을 기준으로 판단된다.\nZ와 M은 자주 사용되지 않으며, 이를 지원하는 소프트웨어도 아직까지는 드문 편이다. 그럼에도 불구하고, WKT에서의 Z와 M 표기는 비교적 쉽게 이해할 수 있다.\n# POINT Z (1 3 2)\n# POINT M (1 3 2)\n# LINESTRING ZM (3 1 2 4, 4 4 2 2)\n\n3.1.4 엠프티 지오메트리\n피쳐 지오메트리 프레임워크에서 중요한 개념 중 하나가 엠프티(empty) 지오메트리이다. 엠프티 지오메트리는 기하학적 연산(3.2절) 수행 과정에서 자연스럽게 생성된다. 예를 들어 POINT (0 0)과 POINT (1 1)의 교차(intersection) 여부를 검토한다고 하자.\n# GEOMETRYCOLLECTION EMPTY\n두 포인트는 인터섹트하지 않으므로 엠프티 집합이 도출된다. 엠프티 포인트를 비엠프티 지오메트리와 결합(합집합 연산)하면, 엠프티 포인트는 결과에서 사라진다.\n모든 지오메트리 유형은 다음과 같이 엠프티 지오메트리를 나타내는 특별한 값을 가진다.\n# POINT EMPTY\n# LINESTRING M EMPTY\n엠프티 집합이 생성된다는 점은 동일하고 디멘션이 다를 뿐이다(3.2절 참조).\n\n3.1.5 10개의 부수적인 지오메트리\n다음의 열 가지 지오메트리는 사용 빈도는 낮지만 점점 증가하는 추세에 있다.\n\n\n\n\n\n\n유형\n설명\n\n\n\nCIRCULARSTRING\n기본적인 곡선 유형으로, 직선 유형의 LINESTRING과 유사. 단일 세그먼트를 구성하려면 세 점이 필요하며, 이들은 시작점과 끝점(첫 번째와 세 번째 점) 그리고 호 상의 중간 점임. 예외적으로 닫힌 원의 경우에는 시작점과 끝점이 동일하며, 두 번째 점은 반드시 호의 중심, 즉 원의 반대편에 위치해야 함. 호를 연결할 때는 이전 호의 마지막 점이 다음 호의 첫 번째 점과 일치해야 하는데, 이는 LINESTRING에서도 동일한 규칙임. 따라서 유효한 문자열은 반드시 1보다 큰 홀수 개의 점을 가져야 함.\n\n\nCOMPOUNDCURVE\n곡선 세그먼트와 선형 세그먼트를 모두 포함하는 단일 연속 곡선. 구성 요소들이 잘 연결되어 있어야 하며, 모든 구성 요소의 끝점(마지막을 제외한)은 다음 구성 요소의 시작점과 일치해야 함.\n\n\nCURVEPOLYGON\n\nCOMPOUNDCURVE가 내재된 사례: CURVEPOLYGON( COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1))\n\n\n\nMULTICURVE\n곡선으로 이루어진 1차원 지오메트리 컬렉션. 라인 문자열, 서큘러 문자열 또는 컴파운드 문자열을 포함할 수 있음.\n\n\nMULTISURFACE\n동일한 CRS를 사용하는 SURFACE로 구성된 2차원 지오메트리 컬렉션\n\n\nCURVE\n일반적으로 여러 점의 연결로 정의되는 1차원 지오메트리 객체로, 점들 간의 인터폴레이션 방식에 따라 커브의 하위 유형이 결정됨.\n\n\nSURFACE\n2차원 지오메트리 객체\n\n\nPOLYHEDRALSURFACE\n공통 경계 세그먼트를 공유하는 연속된 폴리곤들의 집합\n\n\nTIN\n오직 삼각형으로만 구성된 POLYHEDRALSURFACE\n\n\n\nTRIANGLE\n세 개의 비공선적(non-collinear) 버텍스로 이루어진, 내부 경계가 없는 폴리곤(역자주: 세 점이 일직선 상에 놓이지 않음을 의미한다.)\n\n\n\nCIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON은 SFA 표준에는 포함되지 않지만, SQL-MM Part 3 표준에는 포함되어 있다. 위 표의 설명은 PostGIS 매뉴얼에서 인용한 것이다.\n\n3.1.6 텍스트 인코딩과 바이너리 인코딩\n심플 피처 표준에는 두 가지 인코딩 방식이 포함된다. 하나는 텍스트 인코딩(text encoding), 다른 하나는 바이너리 인코딩(binary encoding)이다. 위에서 사용된 WKT는 사람이 읽을 수 있는(human-readable) 방식이며, WKB(well-known binary) 인코딩은 기계가 읽을 수 있는(machine-readable) 방식이다. WKB 인코딩은 정보 손실이 없으며, 일반적인 텍스트 인코딩 및 디코딩보다 처리 속도가 빠르다. 이러한 이유로 WKB 인코딩은 R의 sf 패키지와 GDAL, GEOS, liblwgeom, s2geometry 라이브러리 간의 모든 통신에 사용된다(그림 1.7).",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>지오메트리</span>"
    ]
  },
  {
    "objectID": "03.html#지오메트리에-적용되는-연산",
    "href": "03.html#지오메트리에-적용되는-연산",
    "title": "3  지오메트리",
    "section": "\n3.2 지오메트리에 적용되는 연산",
    "text": "3.2 지오메트리에 적용되는 연산\n심플 피처 지오메트리의 속성을 추출할 수 있으며, 심플 피처 지오메트리들의 결합으로 새로운 지오메트리가 생성된 경우에도 그 속성을 추출할 수 있다. 이 절에서는 기하 속성에만 초점을 맞춘 연산을 간략히 다룬다. 비기하학적 피처 속성 분석은 5장에서 다룬다. 이 절의 일부 내용은 Pebesma (2018)에서 가져왔다.\n기하학적 속성에 대한 연산은 입력과 출력에 따라 분류할 수 있다. 먼저, 출력 관점에서 다음과 같이 구분된다.\n\n프레디케이트(predicate): 특정 속성이 TRUE인지 여부를 판단하는 논리값\n측도(measure): 양적 값(수치이며 측정 단위가 가질 수 있음)\n변형(transformation): 새롭게 생성된 지오메트리\n\n연산은 적용 대상 지오메트리의 수에 따라 다음과 같이 분류할 수 있다.\n\n단항(unary): 단일 지오메트리에 적용\n이항(binary): 두 개의 지오메트리 쌍에 적용\n다항(n-ary): 여러 지오메트리 집합에 적용\n\n\n3.2.1 단항 프레디케이트\n단항 프레디케이트는 하나의 지오메트리의 특정 속성을 설명한다. is_simple, is_valid, is_empty와 같는 프레디케이트는 각각 지오메트리가 심플한지, 밸리드한지, 엠프티한지의 여부를 논리값을 반환한다. is_longlat 프레디케이트는 주어진 CRS가 경위도 좌표계인지, 평면 좌표계인지 여부를 반환한다. is(geometry, class)는 지오메트리가 특정 클래스에 속하는지를 확인한다.\n\n3.2.2 이항 프레디케이트와 DE-9IM\nDE-9IM(Dimensionally Extended Nine-Intersection Model)(Clementini, Di Felice, and Oosterom 1993; Egenhofer and Franzosa 1991)은 2차원 공간(\\(R^2\\))에서 두 지오메트리 간의 정성적 관계를 설명하는 모형이다. 모든 지오메트리는 디멘션 값을 가진다.\n\n포인트 지오메트리: 0\n라인 지오메트리: 1\n폴리곤 지오메트리: 2\n엠프티 지오메트리: F(거짓)\n\n모든 지오메트리는 내부(I), 경계(B), 외부(E)를 가지며, 이들 요소의 역할은 폴리곤의 경우 특히 명확하다.\n\n라인의 경계는 종점에 의해 형성되고, 선상의 모든 비종점이 내부를 구성한다.\n포인트는 0차원의 내부를 가지지만, 경계는 없다.\n\n\n\n\n\n\n그림 3.2: DE-9IM: 폴리곤의 내부, 경계, 외부(행)와 라인의 내부, 경계, 외부(열) 간의 교차(빨간색으로 표시)\n\n\n그림 3.2는 폴리곤과 라인의 내부(I), 경계(B), 외부(E) 영역 간의 교차를 빨간색으로 표시한 것이다. 각 그래프의 제목에는 교차 결과로 도출되는 차원 값(0, 1, 2 또는 F)이 나타나 있다. 폴리곤 지오메트리와 라인 지오메트리 간의 관계는 이러한 차원 값의 조합으로 표현된다.\n#      [,1]       \n# [1,] \"1020F1102\"\n첫 세 문자는 첫 번째 지오메트리(폴리곤)의 내부에 대한 것으로, 그림 3.2에서는 첫 번째 행에 배열되어 있다.(역자 주: 위의 9자리 문자는 그림 3.2에 나타난 9개 교차 결과의 차원을 표시한 것이다. 차원 값은 행 단위로 지그재그 방식—첫 번째 행은 왼쪽에서 오른쪽, 두 번째 행은 오른쪽에서 왼쪽—으로 읽는다.) 더 나아가, 지오메트리 쌍에 대해 마스크(mask) 문자열로 표현된 특정 조건의 만족 여부를 질의할 수 있다.(역자 주: 마스크 문자열은 원하는 지오메트리 간 공간 관계를 질의하거나 필터링할 수 있도록 해준다.) 예를 들어, 문자열 \"*0*******\"는 두 번째 지오메트리가 첫 번째 지오메트리의 내부와 하나 이상의 경계점을 공유할 때 TRUE로 평가된다. 여기서 기호 *는 차원 값(0, 1, 2 또는 F) 중 어느 것이든 올 수 있음을 의미한다. 이 경우, 마스크 문자열 \"T********\"를 사용하면 내부가 서로 교차하는 모든 지오메트리 쌍을 필터링할 수 있다. 여기서 기호 T는 차원 값이 0, 1, 2이면서 비엠프티 교차가 존재함을 뜻한다.\n더 나아가, 이항 프레디케이트는 DE-9IM에서 규정된 정의를 활용하여 일반 언어의 동사 형태로 표현될 수 있다. 예를 들어, 프레디케이트 equals는 관계 \"T*F**FFF*\"와 동일하다. 어떤 두 지오메트리가 이 관계를 만족한다면, (위상적으로) 동일한 지오메트리로 간주할 수 있지만, 노드의 순서는 서로 다를 수 있다.\n이항 프레디케이트를 나열하면 다음과 같다.\n\n\n\n\n\n\n\n프레디케이트\n의미\n역프레디케이트\n\n\n\ncontains\nA 포인트 어느 것도 B의 외부에 있지 않다.\nwithin\n\n\ncontains_properly\nA는 B를 포함하며, B의 어떤 포인트도 A의 경계 상에 있지 않다.\n\n\n\ncovers\nB의 어떤 포인트도 A의 외부에 있지 않다.\ncovered_by\n\n\ncovered_by\n\ncovers의 반대\ncovers\n\n\ncrosses\nA와 B는 일부 내부 포인트를 공유하지만 모든 포인트를 공유하는 것은 아니다.\n\n\n\ndisjoint\nA와 B는 어떤 포인트도 서로 공유하지 않는다.\nintersects\n\n\nequals\nA와 B는 위상적으로 동일하다. 노드 순서나 노드 수가 다를 수 있으며, A가 B를 포함하고 A가 B의 내부에 있는 것과 동일하다.\n\n\n\nequals_exact\nA와 B는 기하학적으로 동일하며, 노드 순서도 동일하다.\n\n\n\nintersects\nA와 B가 완전 분리의 관계를 가지지 않는다.\ndisjoint\n\n\nis_within_distance\nA가 주어진 거리보다 B에 더 가깝게 위치해 있다.\n\n\n\nwithin\nB의 어떤 포인트도 A의 외부에 있지 않다.\ncontains\n\n\ntouches\nA와 B는 최소한 한 개의 경계 포인트를 공유한다. 내부 포인트를 공유하는 것은 아니다.\n\n\n\noverlaps\nA와 B가 다수의 포인트를 공유한다. 디멘션은 A와 B의 디멘션과 동일하다.\n\n\n\nrelated\nA와 B가 주어진 마스크 패턴을 준수하는지의 여부를 반환한다.\n\n\n\n\n위키피디어의 DE-9IM 페이지에서는 개별 동사에 해당하는 relate 마스크 패턴을 확인할 수 있다. 이는 covers와 contains처럼, 의미를 직관적으로 이해하기 어려운 동사(또는 그 반대 동사)가 존재하기 때문이다.\n\nA가 B를 컨테인(contains) 하는 경우, B는 A의 외부나 경계와 어떤 포인트도 공유하지 않는다.\nA가 B를 커버(covers) 하는 경우, B는 A의 외부와 어떤 포인트도 공유하지 않는다.\n\n3.2.3 단항 측도\n단항 측도(unary measure)는 하나의 지오메트리에 대해, 그 속성을 나타내는 측정값이나 양을 반환한다.\n\n\n\n\n\n\n측도\n반환값\n\n\n\ndimension\n포인트는 0, 라인은 1, 폴리곤은 2, 엠프티 지오메트리에 대해서는 NA\n\n\n\narea\n지오메트리의 면적\n\n\nlength\n라인 지오메트리의 길이\n\n\n\n3.2.4 이항 측도\n이항 측도(binary measure)는 두 지오메트리를 입력으로 받아, 그들 사이의 관계를 수치나 패턴으로 반환한다. 예를 들어, distance는 두 지오메트리 간의 거리를 반환하며, 질적 측도로서 마스크 없이 사용하는 relate는 관계 패턴을 제공한다. 두 지오메트리 간 기하학적 관계에 대한 자세한 설명은 3.2.2절에 제시되어 있다.\n\n3.2.5 단항 변환자\n단항 변환자(unary transformer)는 하나의 지오메트리에 작용하여, 새로운 지오메트리를 생성·반환한다.\n\n\n\n\n\n\n변환자\n반환 지오메트리\n\n\n\ncentroid\n투입 지오메트리의 센트로이드로 구성된 POINT 유형의 지오메트리\n\n\nbuffer\n투입 지오메트리보다 더 큰(혹은 더 작은) 지오메트리: 버퍼 사이즈에 따라 산출 지오메트리의 크기가 달라짐\n\n\njitter\n이변량 균등 분포를 이용해 약간 위치가 변형된 지오메트리\n\n\nwrap_dateline\n날짜 변경선을 더 이상 덮거나 교차하지 않는 조각들로 분할된 지오메트리\n\n\nboundary\n투입 지오메트리의 경계를 가진 지오메트리\n\n\nconvex_hull\n투입 지오메트리의 컨벡스헐을 가진 지오메트리(그림 3.3)(역자주: 컨벡스헐은 주어진 포인트 집합을 모두 포함하는 가장 작은 볼록 다각형을 의미한다.)\n\n\nline_merge\n\nMULTILINESTRING 내의 LINESTRING 요소들을 결합하여 더 긴 LINESTRING을 형성한 지오메트리\n\n\nmake_valid\n밸리드하게 교정된 지오메트리\n\n\nnode\n노드가 없는 교차점에 노드를 추가한 라인 지오메트리로 개별 라인 지오메트리에 적용\n\n\npoint_on_surface\n서피스에 임의의 포인트를 가진 지오메트리\n\n\npolygonize\n폐쇄 링을 형성하는 라인으로부터 생성된 폴리곤 지오메트리\n\n\nsegmentize\n주어진 밀도 또는 최소 거리를 만족하는 노드로 구성된 라인 지오메트리\n\n\nsimplify\n버텍스/노드를 제거함으로써 단순화된 라인 혹은 폴리곤 지오메트리\n\n\nsplit\n라인스트링에 의해 분할된 지오메트리\n\n\ntransform\n새로운 CRS로 변환 혹은 전환된 지오메트리(2장)\n\n\ntriangulate\n들로네 삼각망으로 구성된 지오메트리(그림 3.3)(역자주: 들로네 삼각망은 보로노이 테셀레이션과 상호 대응하는 삼각분할 방법으로, 점들을 삼각형으로 연결하되, 삼각형의 외접원 안에 다른 점이 들어가지 않도록 한다)\n\n\nvoronoi\n투입 지오메트리로부터 형성된 보로노이 테셀레이션(그림 3.3)(역자주: 보로노이 테셀레이션은 평면을 여러 구역으로 분할하는 방법으로, 각 구역 내의 모든 지점이 해당 구역의 중심점에 가장 가깝도록 정의된다.)\n\n\nzm\n\nZ 좌표 및 M 좌표가 수정된(일부 좌표의 삭제 혹은 새로운 좌표의 첨가) 지오메트리\n\n\ncollection_extract\n특정 유형의 GEOMETRYCOLLECTION으로부터 일부를 추출한 지오메트리\n\n\ncast\n유형이 전환된 지오메트리\n\n\n+\n주어진 벡터만큼 전위된 지오메트리\n\n\n*\n스칼라 또는 매트릭스가 곱해진 지오메트리\n\n\n\n\n\n\n\n\n그림 3.3: 포인트의 집합, 왼편은 컨벡스헐, 가운데는 보로노이 폴리곤, 오른편은 들로네 삼각망\n\n\n\n3.2.6 이항 변환자\n이항 변환자(binary transformer)는 두 지오메트리 쌍에 적용되어, 새로운 지오메트리를 생성하는 함수이다. 예를 들어, 다음과 같은 연산이 이에 해당한다.\n\n\n\n\n\n\n\n함수\n반환 지오메트리\n인픽스 오퍼레이터\n\n\n\nintersection\n두 지오메트리의 겹치는 부분에 대한 지오메트리\n&\n\n\nunion\n두 지오메트리를 결합한 지오메트리로, 내부 경계를 제거하고, 중복되는 포인트, 노드, 또는 라인을 삭제\n|\n\n\ndifference\n두 번째 지오메트리와 중복되는 부분을 제거한 첫 번째 지오메트리\n/\n\n\nsym_difference\n중복되는 부분을 제거한 이후에 두 지오메트리를 결합한 지오메트리로 intersection의 반대\n%/%\n\n\n\n3.2.7 다항 변환자\n다항 변환자(n-ary transformer)는 지오메트리의 집합에 작용한다. union 연산을 적용하면 모든 지오메트리를 결합한 결과를 얻을 수 있다. 반대로, 동일한 차원을 가진 지오메트리 집합은 MULTI 유형 지오메트리나 GEOMETRYCOLLECTION으로 결합할 수도 있다. 이 경우 union을 적용하지 않으므로, 예를 들어 두 폴리곤 링이 경계선을 공유하는 경우처럼 밸리드하지 않은 지오메트리가 생성될 수 있다.\n다항 intersection과 difference는 단일 인수를 받는 형식이지만, 모든 쌍, 세 쌍, 네 쌍 등으로 확장되어 순차적으로 작동한다. 그림 3.4를 보자. 세 개의 상자가 모두 겹치는 영역을 어떻게 식별할 수 있을까? 이항 intersection을 사용하면 모든 쌍(1-1, 1-2, 1-3, 2-1, 2-2, 2-3, 3-1, 3-2, 3-3)에 대한 교차 결과를 얻을 수 있다. 그러나 이 방식만으로는 두 개 이상의 지오메트리가 동시에 교차하는 영역을 식별할 수 없다. 그림 3.4 오른쪽은 다항 intersection의 결과를 보여준다. 여기서는 하나, 둘, 혹은 그 이상의 지오메트리가 교차하여 생성된 7개의 상호 중복 없는 고유 지오메트리를 확인할 수 있다.\n\n\n\n\n\n그림 3.4: 왼쪽: 세 개의 정사각형이 서로 겹치고 있는데, 이들 모두가 겹치는 부분을 어떻게 확인할 수 있을까? 오른쪽: 상호 중복이 없는 고유한 다항 교차\n\n\n유사하게, 집합 \\(\\{s_1,s_2,s_3,...\\}\\)에 다항 difference를 적용하면 \\(\\{s_1,s_2-s_1,s_3-s_2-s_1,...\\}\\)를 생성할 수 있다. 그 결과는 그림 3.5에 나타나 있다. 그림의 왼쪽은 원래 집합을, 오른쪽은 입력 지오메트리의 순서를 변경한 후의 집합을 보여준다. 이는 결과가 입력 지오메트리의 순서에 의존한다는 점을 명확히 하기 위함이다. 이렇게 얻어진 지오메트리들은 서로 겹치지 않는다.\n\n\n\n\n\n그림 3.5: 박스들에 서로 다른 순서로 differece를 적용한 결과: 왼쪽은 원래 순서이며, 오른편은 반대 순서",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>지오메트리</span>"
    ]
  },
  {
    "objectID": "03.html#정밀도",
    "href": "03.html#정밀도",
    "title": "3  지오메트리",
    "section": "\n3.3 정밀도",
    "text": "3.3 정밀도\n기하학적 연산, 예를 들어 특정 점이 선 위에 있는지 여부를 판단하는 작업은, 좌표가 R에서 사용하는 8바이트 더블(double)과 같은 배정밀도 부동소수점 수로 표현될 경우 실패할 수 있다. 흔히 선택되는 해결책은 연산 전에 좌표의 정밀도(precision)를 제한하는 것이며, 이를 위해 정밀도 모델(precision model)이 사용된다. 가장 일반적인 방법은 하나의 계수 \\(p\\)를 선택하고, 원래 좌표 \\(c\\)를 반올림하여 새로운 좌표 \\(c'\\)를 계산하는 것이다.\n\\[\nc'=\\text {round} (p\\cdot c)/p\n\\]\n이러한 종류의 반올림은 좌표를 간격이 \\(1/p\\) 인 규칙적인 그리드상의 점으로 변환하며, 이는 기하학적 연산에 유용하다. 그러나 이 반올림은 면적이나 거리와 같은 모든 계산에 영향을 미칠 수 있으며, 경우에 따라 밸리드 지오메트리를 무효화할 수도 있다. 특정 응용 분야에 가장 적합한 정밀도 값은 일반적으로 경험과 시행착오를 통해 결정된다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>지오메트리</span>"
    ]
  },
  {
    "objectID": "03.html#커버리지-테셀레이션과-래스터",
    "href": "03.html#커버리지-테셀레이션과-래스터",
    "title": "3  지오메트리",
    "section": "\n3.4 커버리지: 테셀레이션과 래스터",
    "text": "3.4 커버리지: 테셀레이션과 래스터\nOGC(Open Geospatial Consortium, 오픈지리공간컨소시움)는 커버리지(coverage)를 “시공간 도메인 내 임의의 직접 위치에 대해, 그 범위에서 값을 반환하는 함수 역할을 하는 피처”라고 정의한다(Baumann, Hirschorn, and Masó 2017). 함수가 존재한다는 것은 시공간 도메인 내 모든 ‘포인트’, 즉 특정 지점과 특정 시점의 모든 조합에 대해 범위 내의 단일 값을 얻을 수 있다는 것을 의미한다.(역자주: 범위는 함수가 반환하는 값들의 집합을 의미하는데, 함수는 시공간 내 위치별로 이 범위 안에서 값을 반한한다는 의미이다.) 이는 시공간적 현상에서 매우 흔히 나타나는 상황으로, 몇 가지 예를 들 수 있다.\n\n경계 분쟁을 제외하면, 특정 시점의 특정 지역 내 모든 지점(도메인)은 단일 행정 단위(범위)에 속한다.\n특정 시점의 특정 지역 내 모든 지점(도메인)은 특정한 토지피복유형(land cover type)(범위)을 갖는다.\n특정 지역(도메인)의 모든 지점은 단일한 고도값(범위)을 가지며, 이는 보통 주어진 평균 해수면을 기준으로 측정된다.\n3차원 기체의 모든 시공간적 지점(도메인)은 온도(범위)에 대해 단일 값을 갖는다.\n\n여기서 주의할 점은, 관찰이나 측정에는 항상 시간과 공간이 소요되므로, 측정된 값은 본질적으로 시공간적 부피(volume)에 대한 평균값일 수밖에 없다는 것이다. 따라서 범위 변수를 무부피의 ’포인트’에서 직접 측정하는 경우는 매우 드물다. 그러나 실제 많은 사례에서 측정된 부피는 ’포인트’로 간주할 만큼 충분히 작다. 예를 들어, 토지피복유형과 같은 변수는 구별되는 유형이 측정된 면적 단위와 의미 있게 연관되도록, 적절한 부피 단위를 선택해야 한다.(역자 주: 토지피복과 같은 범주형 변수는 측정된 공간 단위가 해당 범주를 대표할 수 있도록 설정되어야 한다. 즉, 각 토지피복 유형이 관찰된 공간 범위 안에서 충분한 대표성을 가질 수 있도록 적절한 공간 단위로 측정해야 한다는 의미이다.)\n위에서 제시한 네 가지 예 중 처음 두 가지의 범위 변수는 범주형이고, 마지막 두 가지는 연속형이다. 범주형 범위 변수의 경우, 넓은 지역이 동일한 값을 가진다면 이러한 데이터를 효율적으로 표현하는 방법은 동일한 값을 갖는 지역의 경계를 저장하는 것이다. 예를 들어, 국가 경계가 이에 해당한다. 이는 심플 피처 지오메트리(폴리곤 또는 멀티폴리곤)를 사용하여 표현할 수 있지만, 다음과 같은 몇 가지 도전 과제가 뒤따른다.\n\n심플 피처 폴리곤은 서로 겹치지 않고 틈새도 없어야 하지만, 이러한 조건이 항상 보장되는 것은 아니다.\n심플 피처는 인접한 두 폴리곤의 경계에 위치한 포인트를 하나의 폴리곤에만 할당할 수 없는데, 이는 커버리지로서의 해석과 충돌한다.\n\n\n3.4.1 토폴로지 모형\n폴리곤 커버리지에서 겹침과 틈새가 없도록 보장하는 데이터 모형을 토폴로지 모형(topological model)이라 하며, GRASS GIS나 ArcGIS와 같은 지리정보시스템(GIS)에서 그 예를 확인할 수 있다. 토폴로지 모형에서는 폴리곤 경계를 한 번만 저장하고, 그 경계의 양쪽에 위치한 폴리곤을 함께 등록한다.\n토폴로지 모형에서 동일한 범위 값을 가진 지역에 대해 (멀티)폴리곤 집합을 도출하는 것은 비교적 간단하다. 그러나 폴리곤 집합으로부터 토폴로지를 재정의하는 역과정을 수행하려면, 오류에 대한 임계값 설정과 더불어 겹침 및 틈새를 처리하는 구체적인 방법을 고려해야 한다.\n\n3.4.2 래스터 테셀레이션\n테셀레이션(tessellation)은 2차원 또는 3차원의 공간을 폴리곤으로 구성된 더 작은 요소들로 세분화하는 것을 의미한다. 규칙(regular) 테셀레이션은 삼각형, 사각형, 육각형과 같은 규칙 폴리곤으로 이루어진 테셀레이션을 뜻한다. 공간데이터에서 일반적으로 사용되는 정사각형 기반 테셀레이션을 래스터 데이터(raster data)라고 부른다. 래스터 데이터는 공간 차원 \\(d\\)를 규칙 셀로 나누며, 각 셀 \\(d_i\\) 는 좌측 닫힘 및 우측 개방 범위(구간)로 정의된다.(역자주: 좌측 닫힘 우측 개방 범위란 구간의 왼쪽 끝점은 포함하지만, 오른쪽 끝점은 포함하지 않는다는 의미이다.)\n\\[\nd_i=d_0+[i\\times \\delta,(i+1)\\times \\delta)\n\\]\n여기서 \\(d_0\\)는 오프셋 값이고, \\(\\delta\\)는 구간(셀 또는 픽셀)의 크기이다. 셀 인덱스 \\(i\\)는 임의의 값을 가질 수 있지만, 반드시 연속적인 정수여야 한다. \\(\\delta\\)는 \\(y\\)축(북거)의 경우 보통 음수 값을 갖는데, 이는 래스터의 행 번호가 남쪽으로 갈수록 증가하는 반면 \\(y\\) 좌표값은 감소하기 때문이다.\n일반적인 폴리곤 테셀레이션에서는 두 폴리곤이 공유하는 경계에 위치한 점의 할당이 모호할 수 있다. 그러나 규칙 테셀레이션에서는 좌측 닫힘([) 및 우측 개방()) 구간을 사용하여 이러한 모호성을 해소한다. 이는 \\(y\\) 좌표에 음의 \\(\\delta\\) 값이, \\(x\\) 좌표에 양의 \\(\\delta\\) 값이 적용된 래스터의 경우, 각 셀의 모서리 점들 중 좌측 상단의 점만을 해당 셀의 일부로 간주한다는 의미이다. 이로 인해 발생할 수 있는 예기치 못한 결과의 한 예가 그림 3.6에 나타나 있다.\n\n\n\n\n\n그림 3.6: 래스터화의 예기치 못한 결과: 각 셀의 좌측 상단 지점만 셀 내부로 간주되기 때문에, 대각선 아래에 위치하면서 붉은 선과 접촉한 셀들도 래스터로 전환되었다.\n\n\n시간 차원을 좌측 닫힘 및 우측 개방 구간으로 세분하는 것은 매우 일반적인 방식이며, 이는 R의 xts 패키지와 같은 시계열 소프트웨어에서 암묵적인 기본 가정이기도 하다. 즉, 시간 스탬프(시점)는 해당 시간 간격의 시작을 나타낸다. 다른 모형과 결합하는 것도 가능하다. 예를 들어, 심플 피처 폴리곤을 사용해 공간을 세분하고 이를 규칙 시간 테셀레이션과 결합하면, 시공간 벡터 데이터 큐브(vector data cube) 개념을 구현할 수 있다. 래스터 및 벡터 데이터 큐브에 관한 논의는 6장에서 다룬다.\n앞서 언급했듯이, \\(R^2\\)에 대한 규칙 테셀레이션을 생성할 때는 정사각형뿐 아니라 삼각형과 육각형 폴리곤을 사용할 수 있다. 이를 3차원 구체로 확장하면 큐브, 정팔면체, 정이십면체, 정십이면체 등 다양한 형태가 가능하다. 큐브 기반 공간 인덱스에는 s2geometry가 있으며, H3 라이브러리는 정이십면체를 기반으로 하면서 밀집화 과정에서 주로 육각형을 사용한다. 지구 전체를 포괄하는 이러한 모자이크는 일반적으로 이산 글로벌 그리드(discrete global grid)라고 불린다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>지오메트리</span>"
    ]
  },
  {
    "objectID": "03.html#네트워크",
    "href": "03.html#네트워크",
    "title": "3  지오메트리",
    "section": "\n3.5 네트워크",
    "text": "3.5 네트워크\n공간적 네트워크는 일반적으로 라인(LINESTRING) 요소로 구성되지만, 네트워크로서의 완결성을 위해 추가적인 위상적 특성을 갖는다.\n\n라인스트링의 시작점과 끝점은 다른 라인스트링의 시작점이나 끝점에 연결될 수 있으며, 이를 통해 노드와 엣지의 집합이 형성된다.\n엣지는 방향성을 가질 수 있으며, 이 경우 연결(흐름, 수송)은 한 방향으로만 가능하다.\n\nosmar(Schlesinger and Eugster 2013), stplanr(Lovelace, Ellison, and Morgan 2022), sfnetworks(van der Meer et al. 2022)와 같은 R 패키지는 네트워크 객체를 구성하고 이를 다루는 기능을 제공하며, 네트워크를 통한 최단 또는 최속 경로 계산을 지원한다. spatstat 패키지(Baddeley, Turner, and Rubak 2022; Baddeley, Rubak, and Turner 2015)는 선형 네트워크 상에서도 포인트 패턴 분석 기능을 제공한다(11장). Lovelace, Nowosad, and Muenchow(2019)의 12장은 네트워크 데이터를 활용한 교통 애플리케이션을 다룬다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>지오메트리</span>"
    ]
  },
  {
    "objectID": "03.html#연습문제",
    "href": "03.html#연습문제",
    "title": "3  지오메트리",
    "section": "\n3.6 연습문제",
    "text": "3.6 연습문제\n다음의 연습문제를 풀되, 적절한 부분에서 R을 활용하라.\n\n2차원(평면) 공간에서 심플 피처 지오메트리로 표현할 수 없는 지오메트리의 두 가지 예를 제시하고, 그림으로 표현하시오.\n좌표 10.542, 0.01, 45321.6789를 정밀도 값 1, 1e3, 1e6, 및 1e-2를 사용하여 재계산하시오.\n다항 교차가 필요한 실제 문제 사례를 제시하시오.\n지점별로 하나의 폐쇄 폴리곤을 가지는 보로노이 다이어그램(그림 3.3)을 만드는 방법을 설명하시오.\n다음의 지오메트리에 대해 단항 측도 dimension을 계산하시오. POINT Z (0 1 1), LINESTRING Z (0 0 1,1 1 2), POLYGON Z ((0 0 0,1 0 0,1 1 0,0 0 0))\nLINESTRING(0 0,1 0)과 LINESTRING(0.5 0,0.5 1)의 DE-9IM 관계를 설명하고, 각 문자의 의미도 함께 설명하시오.\n심플 피처 폴리곤의 집합을 하나의 커버리지를 만들 수 있는지 답하시오. 가능하다면, 어떤 제약 조건에서 가능한지 설명하시오.\nsf 패키지의 nc 카운티 데이터를 사용하여 네 개의 카운티가 동시에 접촉하는 포인트들을 추출하시오.\n\\(y\\)축에 대한 \\(\\delta\\) 값이 양수일 경우, 그림 3.6은 어떻게 달라지는지 설명하시오.\n\n\n\n\n그림 3.1: 심플 피처 지오메트리의 주요 유형\n그림 3.2: DE-9IM: 폴리곤의 내부, 경계, 외부(행)와 라인의 내부, 경계, 외부(열) 간의 교차(빨간색으로 표시)\n그림 3.3: 포인트의 집합, 왼편은 컨벡스헐, 가운데는 보로노이 폴리곤, 오른편은 들로네 삼각망\n그림 3.4: 왼쪽: 세 개의 정사각형이 서로 겹치고 있는데, 이들 모두가 겹치는 부분을 어떻게 확인할 수 있을까? 오른쪽: 상호 중복이 없는 고유한 다항 교차\n그림 3.5: 박스들에 서로 다른 순서로 differece를 적용한 결과: 왼쪽은 원래 순서이며, 오른편은 반대 순서\n그림 3.6: 래스터화의 예기치 못한 결과: 각 셀의 좌측 상단 지점만 셀 내부로 간주되기 때문에, 대각선 아래에 위치하면서 붉은 선과 접촉한 셀들도 래스터로 전환되었다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>지오메트리</span>"
    ]
  },
  {
    "objectID": "04.html",
    "href": "04.html",
    "title": "4  구면 지오메트리",
    "section": "",
    "text": "4.1 직선\n3장에서 다룬 심플 피처의 기본 전제는 지오메트리가 직선으로 연결된 포인트들의 시퀀스로 표현된다는 것이다. \\(R^2\\)(또는 데카르트 공간)에서는 이는 자명하지만, 구면 위에는 직선이 존재하지 않는다. 두 지점을 연결하는 가장 짧은 경로는 두 지점을 지나는 원의 호이며, 이를 대권호(great circle segment)라고 한다. 이로 인해, 구의 정반대편에 있는 두 점을 연결하는 가장 짧은 선은 유일하게 정의되지 않는다. 이들 점을 잇는 모든 대권호는 동일한 길이를 갖기 때문이다. GeoJSON 표준(Butler et al. 2016)은 측지 좌표계에서 직선의 정의에 대해 독자적인 해석을 제시하고 있다(이 장 말미의 연습문제 1 참조).",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>구면 지오메트리</span>"
    ]
  },
  {
    "objectID": "04.html#링-디렉션과-완전-폴리곤",
    "href": "04.html#링-디렉션과-완전-폴리곤",
    "title": "4  구면 지오메트리",
    "section": "\n4.2 링 디렉션과 완전 폴리곤",
    "text": "4.2 링 디렉션과 완전 폴리곤\n구면 상에 존재하는 폴리곤은 구 표면을 내부와 외부, 두 개의 유한한 면적으로 나눈다. \\(R^2\\)에서 적용되는 ’반시계 방향 규칙’은 구면에서는 잘 작동하지 않는데, 이는 방향 해석에 따라 내부가 달라지기 때문이다. 일반적으로는 폴리곤의 점을 순서대로 따라갈 때, 경계의 왼쪽(또는 오른쪽)을 내부로 정의한다. 점의 순서를 반대로 하면 내부와 외부가 뒤바뀌게 된다.\n3장에서 엠프티 폴리곤을 살펴본 바 있는데, 그 반대 개념으로 지표면 전체를 포괄하는 완전 폴리곤(whole polygon)도 생각할 수 있다. 이 개념은, 예를 들어 완전 폴리곤과 육지부의 합집합에 대한 기하학적 차이를 계산함으로써 해양부를 정의하는 데 유용하다(그림 8.1과 그림 11.6 참조).",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>구면 지오메트리</span>"
    ]
  },
  {
    "objectID": "04.html#바운딩-박스-바운딩-직사각형-바운딩-캡",
    "href": "04.html#바운딩-박스-바운딩-직사각형-바운딩-캡",
    "title": "4  구면 지오메트리",
    "section": "\n4.3 바운딩 박스, 바운딩 직사각형, 바운딩 캡",
    "text": "4.3 바운딩 박스, 바운딩 직사각형, 바운딩 캡\n\\(R^2\\)에서는 \\(x\\)와 \\(y\\) 좌표의 범위를 이용해 바운딩 박스(bounding box)를 쉽게 정의할 수 있다. 그러나, 타원체 좌표의 경우, 지오메트리가 반대자오선(antimeridian)(경도 \\(\\pm 180\\))이나 극점을 가로지르면 이러한 범위는 크게 유용하지 않다.(역자주: 반대자오선은 본초자오선의 반대편에 위치한 자오선을 의미하는 것으로 동경 180도 혹은 서경 180도 경선을 지칭한다.) \\(R^2\\)에서 낮은 \\(x\\)값이 높은 값의 서쪽에 있다는 가정은 반대자오선을 넘을 때 성립하지 않는다. 구면 상의 영역을 정의하는 보다 자연스러운 대안은 바운딩 캡(bounding cap)으로, 영역의 중심 좌표와 반지름만으로 정의할 수 있다. 예를 들어 남극 대륙의 경우 바운딩 박스는 그림 4.1의 (a)와 (c)에 나타나 있는 것처럼 다음의 좌표 범위를 통해 정의된다.\n#   xmin   ymin   xmax   ymax \n# -180.0  -85.2  179.6  -60.5\n이 바운딩 박스는 명백히 ymin이 -90이고 xmax가 180인 지역을 포함하지 않는다. 반면 바운딩 캡은 해당 지역을 포함한다.\n#   lng lat angle\n# 1   0 -90  29.5\n해당 지역을 포함하는 또 다른 지오메트리는 바운딩 직사각형(bounding rectangle)이다.\n#   lng_lo lat_lo lng_hi lat_hi\n# 1   -180    -90    180  -60.5\n반대자오선을 가로지르는 지역의 예로 피지 제도를 들 수 있으며, 이 지역의 바운딩 박스는 다음과 같이 정의된다.\n#   xmin   ymin   xmax   ymax \n# -179.9  -21.7  180.2  -12.5\n이는 지구를 한바퀴 도는 정도의 크기에 해당한다. 동일한 지역에 대한 바운딩 직사각형은 다음과 같이 정의된다.\n#   lng_lo lat_lo lng_hi lat_hi\n# 1    175  -21.7   -178  -12.5\n여기서 lng_lo가 lng_hi 보다 더 큰 값이라는 사실은, 해당 바운딩 직사각형이 반대자오선을 가로지르고 있음을 의미한다. 그러나 단순히 좌표 범위만으로는 이러한 위치 관계를 파악하기가 매우 어렵다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>구면 지오메트리</span>"
    ]
  },
  {
    "objectID": "04.html#구면-상의-밸리드-지오메트리",
    "href": "04.html#구면-상의-밸리드-지오메트리",
    "title": "4  구면 지오메트리",
    "section": "\n4.4 구면 상의 밸리드 지오메트리",
    "text": "4.4 구면 상의 밸리드 지오메트리\n많은 글로벌 데이터셋은 타원체 좌표로 제공되지만, 동시에 [-180,180] × [-90,90] 범위의 \\(R^2\\) 공간에서도 잘 ’작동’하도록 사전 조치되어 있다. 이는 다음과 같은 의미를 가진다.\n\n반대자오선(경도 \\(\\pm 180\\))을 가로지르는 지오메트리는 양쪽으로 분할되어 실제로는 횡단이 발생하지 않지만, 두 부분은 거의 서로 맞닿아 있다.\n극점을 포함하는 지오메트리(예: 남극)는 경도 \\(\\pm 180\\)°를 기준으로 분할되어 (-180, -90)과 (180, -90)이 서로 다른 좌표로 취급되지만, 실제로는 두 좌표 모두 지리적 남극(Geographic South Pole)을 가리킨다.\n\n그림 4.1은 남극을 두 가지 방식으로 표현한 예를 보여준다. 위쪽은 \\(R^2\\)를 전제로 한 타원체 좌표이며, 아래쪽은 극평사 도법(Polar Stereographic projection)으로 변환한 것이다. 왼쪽은 지리적 남극을 중심으로 분할이 없는 경우, 오른쪽은 지리적 남극을 중심으로 분할이 있는 경우를 나타낸다. 폴리곤 (b)와 (c)는 밸리드하지만, 폴리곤 (a)는 자기 교차로 인해 밸리드하지 않으며, 폴리곤 (d)는 남극을 향하는 변을 두 번 지나기 때문에 밸리드하지 않다. 그러나 구면(\\(S^2\\)) 상에서는 폴리곤 (a)는 밸리드한 반면, (b)는 (d)와 동일한 이유로 밸리드하지 않다.\n\n\n\n\n\n그림 4.1: 남극 폴리곤을 나타낸 것으로 (a)와 (c)는 POINT(-180 90)를 통과하지 않고, (b)와 (d)는 POINT(-180 -90)와 POINT(180 -90)를 통과한다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>구면 지오메트리</span>"
    ]
  },
  {
    "objectID": "04.html#연습문제",
    "href": "04.html#연습문제",
    "title": "4  구면 지오메트리",
    "section": "\n4.5 연습문제",
    "text": "4.5 연습문제\n다음의 연습문제를 풀되, 적절한 부분에서 R을 활용하라.\n\nGeoJSON 형식(Butler et al. 2016)은 타원체 좌표 간의 ’직선’을 어떻게 정의하는가(섹션 3.1.1)와, 이 정의를 적용했을 때 LINESTRING(0 85, 180 85)는 극투영법에서 어떻게 표현되는가에 각각 답하고, 북극을 통과하도록 이 지오메트리를 수정하는 방법을 설명하시오.\n\\(S^2\\) 상의 전형적인 폴리곤 링의 디렉션은 어떻게 확인할 수 있을지 설명하시오.\n바운딩 박스 대신 바운딩 캡을 사용하는 이점이 있는 경우, 그 이점을 열거하시오.\n왜 작은 지역 경우, 해당 지역을 중심으로 한 정사 도법이 \\(S^2\\) 상의 지오메트리를 잘 근사하는지 설명하시오.\nrnaturalearth::ne_countries(country = \"Fiji\", returnclass = \"sf\")를 사용하여 피지의 지오메트리가 \\(R^2\\)에서 밸리드한지, 피지를 중심으로 한 정사 도법에서 밸리드한지, 그리고 \\(S^2\\) 상에서 밸리드한지 확인하시오. \\(S^2\\) 상에서 지오메트리를 밸리드하게 만들기 위해서는 어떤 조치를 취해야 하는지 설명하시오. 밸리드하게 만들어진 지오메트리를 \\(R^2\\)로 별환하여 지도로 그려보시오. 또한, 피지의 센트로이드를 \\(R^2\\)와 \\(S^2\\) 각각에서 계산하고, 두 센트로이드 간 거리를 구하시오.\ngiscoR 패키지의 gisco_countries 데이터셋에서 NAME_ENGL == \"Fiji\"인 국가를 선택하시오. 이 국가의 지오메트리가 구면 상에서 벨리드한지 판단하며, 벨리드하다면 그 이유를 설명하시오.\n\n\n\n\n그림 4.1: 남극 폴리곤을 나타낸 것으로 (a)와 (c)는 POINT(-180 90)를 통과하지 않고, (b)와 (d)는 POINT(-180 -90)와 POINT(180 -90)를 통과한다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>구면 지오메트리</span>"
    ]
  },
  {
    "objectID": "05.html",
    "href": "05.html",
    "title": "5  속성과 서포트",
    "section": "",
    "text": "5.1 속성-지오메트리 관계와 서포트\n피처 속성은 변경하지 않고 피처의 기하 특성만 수정하더라도, 피처는 변한 것으로 간주된다. 이는 피처가 지오메트리와 속성의 결합으로 구성되기 때문이다. 예를 들어, 지오메트리를 컨벡스헐(convex hull)이나 센트로이로(centroid) 대체했을 때, 새롭게 생성디는 피처가 기존 속성 값과 의미 있게 관계를 유지할 수 있을까? 이 답은 상황에 따라 다르다.\nLINESTRING 지오메트리를 갖는 도로망을 예로 들어보자. 데이터셋에 도로 폭이라는 속성이 포함되어 있고, 어떤 도로의 속성값이 10 m라고 하자. 그렇다면 해당 도로의 특정 구간의 도로 폭에 대해 우리는 무엇을 말할 수 있을까? 이는 도로 폭 속성이 도로의 모든 지점에서 동일한 폭을 의미하는지(즉, 폭이 일정하다는 것을 의미하는지), 아니면 최소값이나 평균값과 같은 집계 속성을 의미하는지에 따라 달라진다. 최소값의 경우를 좀 더 살펴보자. 최소 도로 폭은 해당 도로에서 임의로 특정 구간을 선택했을 때, 그 구간의 최소 폭이 주어진 최소 도로 폭보다 작지 않음을 의미한다. 그러나 이것이 반드시 그 하위 구간의 최소 폭을 뜻하는 것은 아니다. 이 사례는 속성-지오메트리 관계(AGR, attribute-geometry relationship)가 두 가지 ’유형’으로 구분될 수 있음을 보여한다.\n폴리곤 데이터의 경우, 상수 AGR(포인트 서포트)의 예로 다음의 변수를 들 수 있다.\n상수 AGR 변수의 전형적인 특성은 지오메트리가 인위적으로 생성된 것이 아니며, 센서 장치(예: 원격탐사의 이미지 픽셀 경계)와도 관련이 없다는 것이다. 대신, 지오메트리는 관찰된 변수를 매핑함으로써 결정된다. 집계 AGR의 예로는 다음과 같은 변수를 들 수 있다.\n집계 AGR 변수의 전형적인 특성은, 그 지오메트리가 법률적 규정, 관측 장치, 분석상의 선택 등에서 비롯된 것이며, 관찰 변수 그 자체와 본질적으로 연결되어 있지는 않다는 점이다.\n세 번째 유형의 AGR는 속성이 피처 지오메트리의 식별자 역할을 하는 경우에 해당한다. 개별 지오메트리가 변수의 특정 값과 고유하게 연결되어 있을 때, 이를 식별 변수라고 한다. 즉, 동일한 값을 가지는 다른 지오메트리가 존재하지 않는 경우다. 예를 들어, 카운티 이름은 해당 카운티를 식별하며, 카운티 내 어떤 하위 지역에도 동일한 이름이 적용될 수 있다(포인트 서포트). 그러나 임의의 하위 구역을 고려하면, 이 변수는 더 이상 식별자 역할을 하지 못하고 단순한 상수 속성값으로 변하게 된다. 하나의 예를 들면 다음과 같다.\n여기서 중요한 점은, 공간정보가(단순화를 위해 시간은 무시한다고 할 때) 서로 다른 현상 유형으로 구분될 수 있다는 것이다(Scheider et al. 2016).\n그러나 이러한 현상 유형이 지오메트리 유형(포인트, 라인, 폴리곤, 래스터 셀)과 일대일로 대응하는 것은 아니다.\n속성-지오메트리 관계를 적절히 정의하고, 이에 대한 정보가 누락되었거나 지오메트리의 변화(즉, 서포트의 변화)가 정보 변화를 초래하는 경우 경고 메시지를 표출하는 것은, 공간데이터의 서포트와 관련된 일반적인 공간데이터 분석 오류(Stasch et al. 2014)를 피하는 데 도움이 될 수 있다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>속성과 서포트</span>"
    ]
  },
  {
    "objectID": "05.html#속성-지오메트리-관계와-서포트",
    "href": "05.html#속성-지오메트리-관계와-서포트",
    "title": "5  속성과 서포트",
    "section": "",
    "text": "상수(constant) AGR: 속성값이 지오메트리의 모든 부분에 동일하게 적용된다. 즉, 피처가 무수히 많은 지점으로 구성되어 있고, 각 지점이 동일한 속성값을 가지는 경우를 말한다. 지구통계학에서는 이를 포인트 서포트를 가진 변수라고 부른다.\n집계(aggregate) AGR: 속성값이 지오메트리 전체를 요약한 값이다. 즉, 피처가 하나의 관측값을 가지며, 그 값이 지오메트리 전체를 대표하는 경우를 말한다. 지구통계학에서는 이를 블록 서포트를 가진 변수라고 부른다.\n\n\n\n토지이용도에서의 토지이용\n지질도에서의 암석 단위 또는 지질층\n토양도에서의 토양 유형\n기복도에서의 고도 클래스\n기후 구분도에서의 기후 지역\n\n\n\n인구: 인구수 혹은 인구밀도\n지역별로 요약된 사회경제적 변수\n원격탐사 픽셀별 평균 반사율\n지역별 총 오염물질 배출량\n이산화질소 농도에 대한 블록 평균: 보통 정사각형 블록에 대한 블로 크리깅(12.5절) 또는 구역 평균값을 예측하는 분산 모형을 통해 산출된다.\n\n\n\n\n카운티 내부의 임의의 지점(또는 지역)은 여전히 그 카운티에 속하므로 ‘카운티 이름’ 변수에서 동일한 값을 가져야 한다. 그러나 해당 지점(또는 지역)은 더 이상 카운티 전체 지오메트리를 대표하는 식별자로 기능할 수 없다.\n\n\n\n필드: 연속적인 공간상의 모든 지점이 특정 속성값을 가지는 경우(예를 들어, 고도, 대기질 또는 토지이용)\n객체: 위치의 이산적 집합으로 규정되는 경우(예를 들어, 주택, 나무, 사람)\n집계값: 필드의 총계 또는 평균, 라인 혹은 폴리곤 객체의 총빈도 혹은 밀도로 계산되는 값\n\n\n\n포인트는 필드에서의 표본추출 위치일 수도 있고(예: 대기질 관측소), 객체의 위치일 수도 있다.\n라인은 객체(예: 도로, 강)일 수도 있고, 필드를 나타내는 등치선일 수도 있으며, 행정구역의 경계일 수도 있다.\n래스터 픽셀과 폴리곤은 토지이용(커버리지)과 같은 범주형 필드와 연관될 수도 있고, 인구밀도와 같은 집계값과도 관련될 수 있다.\n래스터나 다른 형태의 메시 삼각망은 노드(포인트), 엣지(라인), 페이스(에어리어, 셀)에 각각 다른 변수를 가질 수 있다. 스태거드 그리드(staggered grid)를 이용해 편미분 방정식을 근사하는 경우(Haltiner and Williams 1980; Collins et al. 2013)가 이에 해당한다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>속성과 서포트</span>"
    ]
  },
  {
    "objectID": "05.html#애그리게이션과-속성-요약",
    "href": "05.html#애그리게이션과-속성-요약",
    "title": "5  속성과 서포트",
    "section": "\n5.2 애그리게이션과 속성 요약",
    "text": "5.2 애그리게이션과 속성 요약\n테이블(또는 data.frame) 레코드의 애그리게이션(aggregation)은 다음의 두 단계를 통해 수행된다.\n\n그룹 프레디케이트에 따라 레코드를 분류한다.\n애그리게이션 함수를 적용하여 각 그룹별 단일 요약 속성값을 계산한다.\n\nSQL에서 애그리게이션 과정은 다음의 예시처럼 이루어진다.\nSELECT GroupID, SUM(population) FROM table GROUP BY GroupID;\n여기서 애그리게이션 함수는 SUM이고 그룹화 프레디케이트는 GroupID이다.\nR의 dplyr 패키지는 이 작업을 두 단계로 수행한다. group_by() 함수는 레코드의 그룹 멤버십을 지정하고, summarise() 함수는 각 그룹에 대한 데이터 요약(예: sum 또는 mean)을 계산한다. 반면 베이스 R의 aggregate() 함수는 테이블, 그룹화 조건, 집계 함수를 인수로 받아 이 두 단계를 하나의 함수 호출로 처리한다.\n노스캐롤라이나 카운티의 예는 그림 5.1에 제시되어 있다. 타원 좌표 POINT(-79, 35.5)를 기준점으로 사분면을 설정하고, 각 카운티의 센트로이드가 속한 사분면에 따라 카운티를 그룹화한 뒤, 각 그룹별로 질병 사례 수를 합산하였다. 그 결과, 그룹별로 통합된 지오메트리가 생성되었음을 확인할 수 있다(3.2.6절 참조). 이러한 그룹별 애그리게이션은 필수적이다. 만약 카운티 지오메트리를 단순히 결합하여 MULTIPOLYGON을 생성했다면, 수 많은 중복 경계가 발생하여 밸리드하지 않은 지오메트리가 생성되었을 것이기 때문이다(3.1.2절 참조).\n\n\n\n\n\n그림 5.1: SID74가 네 개의 지역별로 합산되었다.\n\n\n결합된 카운티 폴리곤을 지도로 표현하는 데 기술적인 문제는 없지만, 그룹 합계가 그룹화된 카운티가 아니라 개별 카운티에 해당하는 값이라는 잘못된 인상을 줄 수 있다.\n이러한 방식의 애그리게이션의 특징은 각 레코드가 하나의 그룹에만 할당된다는 점이다. 이로 인해 그룹별 합계의 총합이 그룹화 이전 데이터의 총합과 동일하다는 유지되는 장점이 있다. 즉, 양(amount)을 나타내는 변수의 경우 정보가 손실되거나 추가되지 않는다. 새로 생성된 지오메트리는 원래 레코드의 지오메트리를 그룹 단위로 유니온(union)한 결과이다.\n\n\n\n\n\n그림 5.2: 노스케롤라이나 카운티 상의 타깃 블록\n\n\n지오메트리를 결합하지 않고도 그룹별 합산값을 계산해야 하는 경우에는 공간 프레디케이트를 활용한다. 다만 이 방식에서는 하나의 레코드가 여러 그룹에 속할 수 있다는 점에 유의해야 한다. 예를 들어, 그림 5.2에서 직사각형을 타깃 에어리어로 설정하고, 각 직사각형과 교차 관계에 있는 카운티의 유병자를 합산하면 전체 합계는 훨씬 더 크게 나타날 것이다.\n#   sid74_sum_counties sid74_sum_rectangles \n#                  667                 2621\n반대로 contains나 covers와 같은 다른 프레디케이트를 사용하면 훨씬 작아진다. 이는 많은 카운티가 어떤 직사각형 안에도 완전히 포함되지 않기 때문이다. 그러나 이러한 결과가 큰 문제가 없거나 최소한 수용 가능한 경우도 있다. 예를 들어, 다음과 같은 경우가 이에 해당한다.\n\nPOINT 지오메트리를 폴리곤 단위로 애그리게이션하는 경우: 모든 포인트는 반드시 하나의 폴리곤에 포함되므로 누락 문제는 발생하지 않는다. 다만 포인트가 공유 경계선 위에 위치하면 문제가 될 수 있다. GEOS 라이브러리는 DE-9IM을 기반으로 해당 포인트를 두 폴리곤 모두에 집계하지만, s2geometry 라이브러리는 폴리곤을 ’반-개방(semi-open)’으로 정의하는 옵션을 제공하여, 폴리곤이 서로 중첩되지 않는 한 포인트를 최대 하나의 폴리곤에만 할당한다.\n아주 작은 폴리곤이나 래스터 픽셀을 더 큰 폴리곤으로 애그리게이션하는 경우: 예를 들어, 노스케롤라이나의 30 m 해상도의 고도 데이터를 카운티별로 평균낼 때, 경계 부근에서 일부 픽셀이 누락되더라도 그로 인한 집계 오류는 무시할 수 있을 정도로 작다.\n다대다(many-to-many) 매치에서 최대 면적 매치(single largest area match)가 적용된 경우(그림 7.4 참조)(역자주: 최대 면적 매치란, 겹치는 영역 중 면적이 가장 큰 영역에 모든 값을 할당하는 방식으로, 이러한 기준을 의도적으로 적용한 경우라면 일부 누락이 있더라도 결과가 만족스러울 수 있다.)\n\n보다 작은 에어리어를 보다 큰 에어리어로 합역하는 보다 포괄적인 접근 방법은 면적 가중 내삽을 적용하는 것이다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>속성과 서포트</span>"
    ]
  },
  {
    "objectID": "05.html#면적-가중-내삽",
    "href": "05.html#면적-가중-내삽",
    "title": "5  속성과 서포트",
    "section": "\n5.3 면적 가중 내삽",
    "text": "5.3 면적 가중 내삽\n두 개의 데이터셋의 지오메트리와 속성을 결합하여, 소스 데이터셋의 속성값을 타겟 데이터셋의 지오메트리에 기반한 요약값으로 변환하고자 한다면, 면적 가중 내삽(area-weighted interpolation)이 가장 간단한 접근 방법이 될 수 있다. 이 방법은 소스와 타겟의 지오메트리가 겹치는 면적을 고려하여, 소스 속성값을 타겟 속성값으로 전환하기 위한 가중치로 활용한다(Goodchild and Lam 1980; Do, Thomas-Agnan, and Vanhems 2015a, 2015b; Do, Laurent, and Vanhems 2021). 이 기법은 보수적 합역(conservative region aggregation) 또는 재그리딩(regridding)으로도 알려져 있다(Jones 1999). 여기서는 Do, Thomas-Agnan과 Vanhems(2015b)의 표기법을 따르도록 한다.\n면적 가중 내삽은 타깃 에어리어 \\(T_j\\)에 대한 가중평균값을 산출한다. 이 값은 \\(T_j\\)와 겹치는 \\(p\\)개의 소스 구역 \\(S_i\\)의 속성값 \\(Y_i\\)에 대한 가중평균으로 계산된다.\n\\[\n\\hat Y_j(T_j)=\\sum\\limits_{i=1}^pw_{ij}Y_i(S_i)\n\\tag{5.1}\\]\n여기서 \\(w_{ij}\\)는 \\(T_j\\)와 \\(S_i\\)의 겹침의 정도에 따라 달라지며, 겹침 정도는 \\(A_{ij}=T_j\\cap S_i\\)로 표현된다. \\(w_{ij}\\)와 \\(A_{ij}\\)의 관계는 아래에서 자세히 설명한다.\n가중치를 계산하는 방법에는 여러 가지가 있으며, 외부 변수를 활용하는 방법(예: 대시메트릭 매핑, Mennis 2003 참조)도 그중 하나이다. 외부 변수를 사용하지 않고 가중치를 계산하는 단순한 방법은 두 가지가 있으며, 변수 \\(Y\\)가 공간 외연 변수인지 공간 내포 변수인지에 따라 달라진다.\n\n5.3.1 공간 외연 변수와 공간 내포 변수\n공간 외연 변수(spatially extensive variable)는 길이, 면적, 부피, 카운트(count)와 같이 물리적 크기와 관련된 양을 나타낸다. 대표적인 예로 인구수를 들 수 있다. 인구수는 특정 크기의 영역과 관련된 값이며, 해당 영역을 더 작은 영역으로 분할하면 인구수도 함께 분할되어야 한다. 인구가 공간적으로 균일하지 분포하지 않은 경우가 많기 때문에, 이 분할이 반드시 면적에 비례할 필요는 없지만, 더 작은 영역의 인구수 합계는 전체 영역의 인구수와 일치해야 한다. 공간 내포 변수(spatially intensive variable)는 영역의 면적에 비례하여 변하지 않는 변수이다. 즉, 영역이 분할되더라도 평균적인 의미에서 값이 그대로 유지된다. 대표적인 예로 인구밀도를 들 수 있다. 영역을 더 작은 영역으로 분할하더라도 연구밀도 값이 면적에 비례하여 할당되지는 않는다. 더 작은 영역들의 인구밀도를 합산한 값은 아무런 의미가 없으며, 이들 인구밀도의 평균이 전체 영역의 인구밀도와 유사하게 나타날 것이다.\n공간 외연 변수 \\(Y\\)가 공간상에 균등하게 분포한다고 가정하면, 소스 데이터의 구역 \\(S_i\\)에 대한 변수값 \\(Y_i\\)로부터, 타깃 구역과의 겹침으로 생성된 하위 구역(\\(A_{ij}=T_j\\cap S_i\\))의 속성값 \\(Y_{ij}\\)는 다음과 같이 계산할 수 있다.\n\\[\n\\hat Y_{ij}(A_{ij})=\\frac{|A_{ij}|}{|S_i|}Y_i(S_i)\n\\]\n여기서 \\(|\\cdot|\\)는 면적을 의미한다. \\(Y_j(T_j)\\)를 추청하려면, \\(T_j\\)와 겹쳐 생성된 모든 하위 구역의 값을 합산하면 된다.\n\\[\n\\hat Y_j(T_j)=\\sum\\limits_{i=1}^p\\frac{|A_{ij}|}{|S_i|}Y_i(S_i)\n\\tag{5.2}\\]\n반면 공간 내포 변수의 경우, 해당 변수값이 개별 소스 구역 \\(S_i\\) 내에서 일정하다고 가정하므로, 겹침에 의해 생성된 하위 구역의 추정값은 소스 구역의 전체의 값과 동일하다.\n\\[\n\\hat Y_{ij}=Y_i(S_i)\n\\]\n따라서 소스 구역의 값을 면적 가중 평균으로 계산하면, 타깃 구역 \\(T_j\\)에 대한 추정값을 얻을 수 있다.\n\\[\n\\hat Y_j(T_j)=\\sum\\limits_{i=1}^p\\frac{|A_{ij}|}{|T_j|}Y_i(S_i)\n\\tag{5.3}\\]\n\n5.3.2 대시메트릭 매핑\n대시메트릭 매핑(dasymetric mapping)은 더 큰 구역 체계의 변수값(예: 인구수)을 더 작은 구역 체계의 변수값으로 분배하는 방법이다. 이때 인구 분포와 관련된 다른 변수(예: 토지이용, 건물 밀도, 도로 밀도 등)를 활용한다. 대시매트릭 매핑의 가장 간단한 방식은 식 5.2에서 나타난 비율 \\(|A_{ij}|/|S_i|\\) 대신 또 다른 공간 외연 변수와 관련된 비율 \\(X_{ij}(S_{ij})/X_i(S_i)\\)을 사용하는 것이다. 이 방법을 적용하려면 소스 구역과 겹침 구역 모두에 대해 해당 변수의 값을 알고 있어야 한다.(역자주: 대시메트릭 매핑은 보조 정보를 활용해 주어진 공간 단위를 더 작은 단위로 분할하고, 원래의 속성값을 분할된 단위에 재할당함으로써 현상을 보다 세밀하게 재현하려는 공간분석 기법이다. 예를 들어, 서울시 동별 인구수 자료가 있을 때 서울시 토지이용도를 이용해 각 동을 토지이용 상태에 따라 세분하고, 토지이용 유형과 인구 분포 간의 관계를 토대로 동 전체 인구를 토지이용별로 재할당할 수 있다.) Do, Thomas-Agnan과 Vanhems(2015b)는 \\(X\\)와 \\(Y\\) 중 적어도 하나가 공간 내포 변수일 때 적용할 수 있는 대안적 접근법과, \\(X\\) 데이터가 상이한 구역 체계에서 제공되는 경우에 대한 논의를 제시한다.\n\n5.3.3 파일 포맷과 서포트\nGDAL의 벡터 API는 필드 도메인(field domains)을 읽고 쓰는 기능을 지원한다. 필드 도메인은 지오메트리가 분할되거나 결합될 때 속성 변수를 어떻게 처리할지를 지정하는 ‘분할 정책(split policy)’과 ’병합 정책(merge policy)’을 포함한다. 예를 들어, 공간 내포 변수의 경우 분할 시에는 ’중복(duplicate)’, 병합 시에는 ‘기하 가중(geometry weighted)’을 적용한다. 반면, 공간 외연 변수의 경우 분할 시에는 ’기하 비율(geometry ratio)’, 병합 시에는 ‘합(sum)’을 적용한다.(역자주: 인구밀도와 같은 공간 내포 변수의 경우, 폴리곤이 분할될 때는 동일한 값을 ‘중복’ 할당하고, 폴리곤이 병합될 때는 면적 비중을 고려하여 가중 평균을 계산한다. 반면, 인구수와 같은 공간 외연 변수의 경우, 폴리곤이 분할될 때는 면적 비중에 따라 가중 분할하고, 폴리곤이 병합될 때는 값을 합산한다.) 이 기능을 지원하는 파일 형식에는 GeoPackage와 FileGDB가 있다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>속성과 서포트</span>"
    ]
  },
  {
    "objectID": "05.html#업스케일링과-다운스케일링",
    "href": "05.html#업스케일링과-다운스케일링",
    "title": "5  속성과 서포트",
    "section": "\n5.4 업스케일링과 다운스케일링",
    "text": "5.4 업스케일링과 다운스케일링\n업스케일링(upscaling)은 고해상도 데이터에서 저해상도 정보를 생성하는 과정을 의미하고, 다운스케일링(downscaling)은 저해상도 데이터에서 고해상도 정보를 추정하는 과정을 의미한다. 이 두 과정 모두 속성과 지오메트리의 관계, 즉 서포트의 변화를 수반하며, 각각 애그리게이션(aggregation)과 디스애그리게이션(disaggregation)과 동의어로 사용할 수 있다. 다운스케일링의 가장 단순한 형태는 폴리곤, 라인, 또는 그리드 셀의 값을 주어진 포인트 위치에서 표본 추출하는 것이다. 이 방법은 포인트 서포트를 가진 변수(예: ‘상수’ AGR)에는 적합하지만, 값이 합산값인 경우에는 대략적인 결과만 제공한다. 대표적인 도전 과제로는 (1) 저해상도 기상 예측 모형이나 기후 변화 모형에서 얻은 변수를 고해상도로 예측하는 작업, (2) 서로 다른 시공간 해상도를 가진 센서를 융합하여 위성 이미지에서 파생된 변수를 고해상도로 예측하는 작업이 있다.\n식 5.1과 이에 기반으로 한 식 5.2(공간 외연 변수) 및 식 5.3(공간 내포 변수)는 소스 구역 \\(S_i\\)와 타깃 구역 \\(T_j\\) 간에 겹침이 존재하기만 하면, 두 구역 간에 정보를 이동시킬 수 있음을 보여준다. 즉, 더 큰 구역 단위로의 이동(애그리게이션)이나 더 작은 구역 단위로의 이동(디스애그리게이션) 모두 가능하다는 의미다. 다만 이러한 방식의 타당성은 다음 가정이 성립하는 정도에 달려 있다. 소스 구역에서 공간 외연 변수는 균등하게 분포해야 하고, 공간 내포 변수는 일정한 값을 가져야 한다.\n디스애그리게이션은 라인이나 폴리곤 데이터로부터 포인트 값을 추출하는 것에서 시작된다. 포인트는 면적을 갖지 않으므로(\\(|A_{ij}|=0\\)) 식 5.2와 5.3은 적용할 수 없다. 그러나 지오메트리 내부의 값이 일정하다고 가정할 수 있다면, 공간 내포 변수인 경우 \\(Y_i(S_i)\\) 값을 포인트에 할당할 수 있다. 단, 모든 포인트가 고유하게 하나의 소스 지점 \\(S_i\\)에만 할당될 수 있어야 하며, 폴리곤 데이터의 경우 이는 \\(Y\\)가 커버리지 변수(3.4절)여야 함을 의미한다. 반면, 공간 외연 변수의 경우 포인트에 값을 추출하는 것은 무의미하다. 포인트는 면적이 없으므로 항상 0이 추출되기 때문이다(역자주: 공간 외연 변수는 면적에 비례하여 값이 커지는 변수이므로, 면적이 없는 포인트에서는 값이 정의되지 않는다).\n영역과 관련된 값이 해당 영역의 집계값일 경우, 면적 가중 내삽이나 대시매트릭 매핑에서 전제하는 ‘균일 분포’ 또는 ‘일정한 값’ 가정은 실제 상황과 차이가 있을 수 있다. 그럼에도 불구하고 이러한 단순한 접근법이 합리적인 근사치를 제공하는 경우가 있으며, 예를 들어 다음과 같은 상황이 있다.\n\n소스 구역과 타깃 구역이 거의 동일한 경우\n소스 구역 내의 변동성이 매우 작아, 변수값이 거의 균등 분포하거나 일정한 값을 보이는 경우\n\n다른 경우에는 이러한 방법으로 얻어진 결과가 타당성이 부족한 가정에 기반할 수 있다. 포인트나 더 작은 구역으로부터 더 큰 구역의 총량을 추정하기 위해 사용할 수 있는 통계적 애그리게이션 방법에는 다음이 있다.\n\n디자인 기반(design-based) 방법: 타깃 지역에서 확률 표본이 확보되어 있고, 포함 확률(inclusion probability)이 알려져 있어야 한다(Brus 2021, 10.4 절).\n모형 기반(model-based) 방법: 공간적 자기상관을 고려하는 랜덤 필드 모형을 가정한다(예: 블록 크리깅, 12.5절).\n\n또한 다른 디스애그리게이션 기법으로는 다음과 같은 것들이 있다.\n\n결정론적 평활화 기반 접근: 커널 기반 또는 스플라인 기반의 평활화 기법을 포함한다.\n통계적 모형 기반 접근: 에어리어-투-에어리어 크리깅과 에어리어-투-포인트 크리깅을 포함한다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>속성과 서포트</span>"
    ]
  },
  {
    "objectID": "05.html#연습문제",
    "href": "05.html#연습문제",
    "title": "5  속성과 서포트",
    "section": "\n5.5 연습문제",
    "text": "5.5 연습문제\n다음의 연습문제를 풀되, 적절한 부분에서 R을 활용하라.\n\n노스케롤라이나 데이터셋(nc)에 nc$State = \"North Carolina\"와 같이 변수를 추가한다고 가정하자(모든 카운티에 동일한 주 이름이 할당됨). 속성-지오메트리 관계(AGR) 측면에서 이 변수에 어떤 값을 지정할 수 있을지 설명하시오.\nst_union(nc)으로 얻은 지오메트리로를 기반으로 새로운 sf 객체를 생성하고, State 변수에 \"North Carolina\" 값을 할당하시오. 이 경우, 해당 속성 변수에 어떤 agr을 지정할 수 있을지 설명하시오.\nnc 데이터셋에 st_area를 사용하여 area 변수를 추가하시오. 그런 다음 area 변수와 AREA 변수를 비교하시오. AREA의 단위는 무엇인지, 두 변수는 선형적인 관련성을 가지는지 말하시오. 만약 불일치가 존재한다면, 그 원인은 무엇인지 설명하시오.\narea는 공간 내포 변수인지 공간 외연 변수인자 말하시오. area의 agr은 상수, 식별, 집계값 중 어느 것에 해당하는지 답하시오.\n그림 5.3에서 5.3.1 절에 나타나 있는 방정식을 이용하여 (a) 점선 셀과 (b)네 개의 실선 셀을 모두 포함하는 정사각형에 대해 면적 가중 내삽의 결과를 계산하시오. (b)의 경우, (i) 공간 외연 변수인 경우와 (ii) 공간 내포 변수인 경우로 나누어 계산하시오. 그림에서 빨간 숫자는 소스 구역의 데이터 값이다.\n\n\n\n\n\n\n그림 5.3: 면적 가중 내삽의 예시 데이터\n\n\n\n\n\n그림 5.1: SID74가 네 개의 지역별로 합산되었다.\n그림 5.2: 노스케롤라이나 카운티 상의 타깃 블록\n그림 5.3: 면적 가중 내삽의 예시 데이터",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>속성과 서포트</span>"
    ]
  },
  {
    "objectID": "07.html",
    "href": "07.html",
    "title": "7  sf와 stars 패키지",
    "section": "",
    "text": "7.1 sf 패키지\nR의 sf 패키지(Pebesma 2018)는 기존의 R 패키지인 sp, rgeos, rgdal의 벡터 처리 기능을 대체하고 이를 성공적으로 계승하기 위해 개발되었다. 또한 산업계 및 오픈소스 프로젝트에서 널리 사용되는 표준 기반 접근법에 보다 근접하고, 최신 버전의 오픈소스 지리공간 소프트웨어 스택(그림 1.7)에 기반하며, 필요 시 R 공간 소프트웨어와 타이디버스(Wickham et al. 2019)의 통합을 가능하게 한다.\n이를 위해 sf 패키지는 R에서 심플 피처 접근(Herring et al. 2011)을 네이티브(native)로 제공한다.(역자주: 여기서 ’네이티브’는 추가적인 변환 과정이나 별도의 중간 계층 없이, 해당 환경에서 직접 실행되거나 지원되는 방식을 의미한다.) 이 패키지는 여러 tidyverse 패키지, 특히 ggplot2, dplyr, tidyr와의 인터페이스를 제공하며, GDAL을 통해 데이터를 읽고 쓰고, GEOS(투영 좌표의 경우) 또는 s2geometry(타원체 좌표의 경우)를 이용해 기하학 연산을 수행하고, PROJ를 사용하여 좌표변환 및 전환 작업을 처리한다. 외부 C++ 라이브러리와 연동은 Rcpp 패키지(Eddelbuettel 2013)를 통해 이루어진다.\nsf 패키지는 sf 객체로 심플 피처를 표현하며, 이는 data.frame 또는 티블(tibble)의 하위 클래스이다.(역자주: 티블은 tidyverse 패키지에서 제안한, 개선된 형태의 데이터 프레임 포맷이다.) sf 객체는 최소한 하나 이상의 sfc 클래스 지오메트리 리스트 열(list-column)을 포함하며, 이 리스트 열의 각 요소는 sfg 클래스의 R 객체로서 지오메트리 정보를 담고 있다. 지오메트리 리스트 열은 data.frame이나 티블 내에서 변수처럼 작동하지만, 숫자형이나 문자형 변수와 같은 기본 벡터보다 복잡한 구조를 갖는다(부록 B.3 참조).\nsf 객체는 다음과 같은 메타데이터를 가진다.\nsfc 지오메트리 리스트 열은 st_geometry() 함수를 통해 sf 객체에서 추출할 수 있으며, 다음과 같은 메타데이터를 가진다\n이러한 속성들의 값을 확인하거나 수정하기 위해 st_bbox(), st_crs(), st_set_crs(), st_agr(), st_set_agr(), st_precision(), st_set_precision() 등의 함수를 사용할 수 있다.",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#sec-sf",
    "href": "07.html#sec-sf",
    "title": "7  sf와 stars 패키지",
    "section": "",
    "text": "(활성화된) 지오메트리 열의 이름: sf_column 속성에 저장됨.\n각 비기하 변수의 속성-지오메트리 관계(5.1절 참조): agr 속성에 저장됨.\n\n\n\n좌표참조계(CRS): crs 속성에 저장됨.\n바운딩 박스(bounding box): bbox 속성에 저장됨.\n정밀도: precision 속성에 저장됨.\n지오메트리 수: n_empty 속성에 저장됨.\n\n\n\n7.1.1 객체 생성\n다음과 같은 방법으로 sf 객체를 생성할 수 있다.\n\nlibrary(sf)\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\np1 &lt;- st_point(c(7.35, 52.42))\np2 &lt;- st_point(c(7.22, 52.18))\np3 &lt;- st_point(c(7.44, 52.19))\nsfc &lt;- st_sfc(list(p1, p2, p3), crs = 'OGC:CRS84')\nst_sf(elev = c(33.2, 52.1, 81.2), \n      marker = c(\"Id01\", \"Id02\", \"Id03\"), geom = sfc)\n# Simple feature collection with 3 features and 2 fields\n# Geometry type: POINT\n# Dimension:     XY\n# Bounding box:  xmin: 7.22 ymin: 52.2 xmax: 7.44 ymax: 52.4\n# Geodetic CRS:  WGS 84\n#   elev marker              geom\n# 1 33.2   Id01 POINT (7.35 52.4)\n# 2 52.1   Id02 POINT (7.22 52.2)\n# 3 81.2   Id03 POINT (7.44 52.2)\n\n\n\n\n\n\n그림 7.1: sf 객체의 구조\n\n\n그림 7.1은 출력된 구성 요소에 대한 설명을 보여준다. 객체를 처음부터 생성하는 경우도 있지만, R에서의 공간데이터는 대체로 외부 소스에서 읽어온다. 이러한 외부 소스에는 다음과 같은 것들이 있다.\n\n외부 파일\n데이터베이스 내의 테이블(또는 테이블 집합)\n웹서비스 호출을 통해 획득한 데이터셋\nR 패키지에 포함된 데이터셋\n\n7.1.2 읽기와 쓰기\n외부 ‘데이터 소스’(파일, 웹서비스, 문자열 등)에서 데이터셋을 읽어올 때는 st_read() 함수를 사용한다.\n\nlibrary(sf)\n(file &lt;- system.file(\"gpkg/nc.gpkg\", package = \"sf\"))\n# [1] \"/home/edzer/R/x86_64-pc-linux-gnu-library/4.3/sf/gpkg/nc.gpkg\"\nnc &lt;- st_read(file)\n# Reading layer `nc.gpkg' from data source \n#   `/home/edzer/R/x86_64-pc-linux-gnu-library/4.3/sf/gpkg/nc.gpkg' \n#   using driver `GPKG'\n# Simple feature collection with 100 features and 14 fields\n# Geometry type: MULTIPOLYGON\n# Dimension:     XY\n# Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6\n# Geodetic CRS:  NAD27\n\n여기서 사용된 파일 이름과 경로는 sf 패키지에 포함된 데이터를 가리키며, 이는 sf 패키지를 설치하는 과정에서 설정되므로 어떤 컴퓨터에서든 예외 없이 읽을 수 있다.\nst_read() 함수는 두 개의 인수, 즉 데이터 소스 이름(dsn)과 레이어(layer)를 가진다. 위의 예에서 사용된 지오패키지(GPKG) 파일은 단일 레이어만 포함하고 있으며, 해당 레이어가 불러와진 것이다. 만약 여러 레이어가 포함되어 있었다면, 첫 번째 레이어가 읽히고 경고 메시지가 출력되었을 것이다. 데이터셋에서 사용 가능한 레이어 목록은 다음과 같이 조회할 수 있다.\n\nst_layers(file)\n# Driver: GPKG \n# Available layers:\n#   layer_name geometry_type features fields crs_name\n# 1    nc.gpkg Multi Polygon      100     14    NAD27\n\n심플 피처 객체는 st_write() 함수를 사용하여 저장할 수 있다.\n\n(file = tempfile(fileext = \".gpkg\"))\n# [1] \"/tmp/Rtmpm9lGRF/file361e653fae4a9.gpkg\"\nst_write(nc, file, layer = \"layer_nc\")\n# Writing layer `layer_nc' to data source \n#   `/tmp/Rtmpm9lGRF/file361e653fae4a9.gpkg' using driver `GPKG'\n# Writing 100 features with 14 fields and geometry type Multi Polygon.\n\n여기서 파일 형식(GPKG)은 파일 이름 확장자에서 결정된다. st_write() 함수의 append 인수를 설정하면 기존 레이어에 레코드를 추가하거나, 기존 레이어를 교체할 수 있다. append 인수가 설정되지 않은 상태에서 동일한 레이어가 이미 존재하면 오류가 발생한다. 타이디버스 스타일의 write_sf() 함수는 append가 설정되지 않은 경우에도 오류 없이 레이어를 교체한다. 또한, st_delete() 함수를 사용하면 레이어를 삭제할 수 있으며, 이는 특히 데이터베이스의 테이블과 연결된 레이어를 다룰 때 유용하다.\nWKT-2 좌표참조계를 지원하는 파일 형식의 경우, st_read()와 st_write()를 통해 이를 읽고 쓸 수 있다. 그러나 csv와 같은 간단한 포맷에서는 이 기능이 지원되지 않는다. 셰이프파일(shapefile) 형식은 CRS 인코딩에 매우 제한적인 지원만 제공한다.(역자주: 셰이프파일은 ESRI가 개발한 벡터 데이터 포맷으로, 현재 가장 널리 사용되는 형식 중 하나이다.)\n\n7.1.3 서브세팅\n매우 일반적인 작업 중 하나는 객체의 일부를 추출하는 것인데 이를 서브세팅(subsetting)이라고 한다. 베이스 R에서는 이를 위해 대괄호 기호([])를 사용한다. data.frame 객체에 적용되는 규칙을 sf 객체에도 동일하게 적용할 수 있다. 예를 들어, 다음 같은 코드를 사용하면 레코드 2~5와 열 3~7을 선택할 수 있다.\n\nnc[2:5, 3:7]\n\n여기에 몇몇 옵션을 부가적으로 적용할 수 있다.\n\ndrop 인수는 기본값이 FALSE로 설정되어 있어, 지오메트리 열이 항상 선택되며 sf 객체가 반환된다. TRUE로 설정하면, 지오메트리 열이 선택되지 않은 경우 해당 열이 제거된 data.frame이 반환된다.\n공간(sf, sfc, sfg) 객체를 첫 번째 인수로 사용하여 선택하면, 해당 객체와 공간적으로 교차하는 피처가 선택된다(다음 절 참조). 다른 프레디케이트를 사용하려면 op 인수를 설정하여 st_covers()와 같은 함수나 3.2.2절에 나열된 다른 이항 프레디케이트 함수를 지정할 수 있다.\n\n7.1.4 이항 프레디케이트\nst_intersects(), st_covers()와 같은 이항 프레디케이트 함수(3.2.2절 참조)는 두 개의 피처 집합 또는 피처 지오메트리를 입력받아, 모든 쌍에 대해 조건이 TRUE인지 FALSE인지를 반환한다. 대규모 집합의 경우, 이러한 연산은 일반적으로 대부분이 FALSE 값으로 채워진 거대한 행렬을 생성하게 되며, 이 때문에 기본적으로 희소 표현(sparse representation)이 반환된다.(역자주: 희소 표현은 메모리 사용을 최적화하고 데이터 처리를 더욱 효율적으로 하는 방식으로, 일반적으로 TRUE 값만을 저장하고 FALSE 값은 저장하지 않는다.)\n\nnc5 &lt;- nc[1:5, ]\nnc7 &lt;- nc[1:7, ]\n(i &lt;- st_intersects(nc5, nc7))\n# Sparse geometry binary predicate list of length 5, where the\n# predicate was `intersects'\n#  1: 1, 2\n#  2: 1, 2, 3\n#  3: 2, 3\n#  4: 4, 7\n#  5: 5, 6\n\n\n\n\n\n\n그림 7.2: 노스케롤라이나의 처음 일곱개 카운티\n\n\n그림 7.2는 처음 다섯 개 카운티와 처음 일곱 개 카운티 간의 교차을 이해하는 방법을 보여준다. 다음과 같은 방법으로 희소 논리 행렬을 조밀한 행렬(dense matrix)로 변환할 수 있다.\n\nas.matrix(i)\n#       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]\n# [1,]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n# [2,]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n# [3,] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n# [4,] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE\n# [5,] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n\nnc5의 각 카운티와 교차하는 nc7 카운티의 개수는 다음과 같이 계산할 수 있다.\n\nlengths(i)\n# [1] 2 3 2 2 2\n\n역으로 nc7의 개별 카운티와 교차하는 nc5의 카운티의 개수는 다음과 같이 계산할 수 있다.\n\nlengths(t(i))\n# [1] 2 3 2 1 1 1 1\n\n객체 i 가 sgbp(sparse geometrical binary predicate) 클래스의 한 객체라고 할 때, 객체 i는 정수 벡터의 리스트로 표현되며, 이 리스트의 각 요소는 논리 프레디케이트 행렬의 한 행을 나타낸다. 논리 프레디케이트 행렬은 해당 행에 대해 TRUE 값을 갖는 열의 인덱스를 저장한다. 이 객체에는 사용된 프레디케이트와 총 열 수 등의 메타데이터도 포함된다. sgbp 객체에 적용할 수 있는 메서드에는 다음과 같은 것들이 있다.\n\nmethods(class = \"sgbp\")\n#  [1] as.data.frame as.matrix     coerce        dim          \n#  [5] initialize    Ops           print         show         \n#  [9] slotsFromS3   t            \n# see '?methods' for accessing help and source code\n\nsgbp 클래스 객체에서 사용 가능한 유일한 Ops 메서드는 !(부정 연산자)이다.\n\n7.1.5 타이디버스 패키지\ntidyverse 패키지는 다양한 데이터사이언스 패키지를 함께 로드한다(Wickham and Grolemund 2017; Wickham et al. 2019). sf 패키지는 tidyverse 스타일의 읽기 및 쓰기 함수인 read_sf()와 write_sf()를 제공하며, 이 함수들은 다음과 같은 특징을 가진다.\n\ndata.frame 대신 tibble을 반환한다.\n출력 내용을 콘솔에 인쇄하지 않는다.\n기본적으로 기본 데이터를 덮어쓴다.\n\nsf 객체에는 tidyverse 패키지의 filter(), select(), group_by(), ungroup(), mutate(), transmute(), rowwise(), rename(), slice(), summarise(), distinct(), gather(), pivot_longer(), spread(), nest(), unnest(), unite(), separate(), separate_rows(), sample_n(), sample_frac()등의 함수를 적용할 수 있다. 대부분의 함수는 sf 객체의 메타데이터만 처리하며, 지오메트리 정보는 변경하지 않는다. 사용자가 지오메트리를 제거하려면, st_drop_geometry() 함수를 사용하거나, 선택 작업 전에 간단히 tibble 또는 data.frame으로 강제 변환(coerce)하면 된다.\n\nlibrary(tidyverse) |&gt; suppressPackageStartupMessages()\nnc |&gt; as_tibble() |&gt; select(BIR74) |&gt; head(3)\n# # A tibble: 3 × 1\n#   BIR74\n#   &lt;dbl&gt;\n# 1  1091\n# 2   487\n# 3  3188\n\nsf 객체에 대한 summarise() 함수에는 두 가지 특별한 인수가 있다\n\ndo_union(기본값: TRUE): 그룹화된 지오메트리가 반환될 때 유니언(합집합)할지 여부를 결정하여, 이를 통해 밸리드한 지오메트리가 형성되도록 한다.\nis_coverage(기본값: FALSE): 그룹화된 지오메트리가 커버리지(겹침이 없는 경우)를 형성할 때, 이를 TRUE로 설정하면 유니언 과정이 더 빨라진다.\n\ndistinct() 함수는 고유한 레코드를 선택하며, st_equals() 함수는 지오메트리의 고유성을 평가한다.\nfilter() 함수는 일반적인 프레디케이트와 함께 사용할 수 있으며, 공간적 프레디케이트를 사용하고자 할 경우 예를 들어 오렌지 카운티에서 50 km 이내에 있는 모든 카운티를 선택하려면 다음과 같이 사용할 수 있다.\n\norange &lt;- nc |&gt; dplyr::filter(NAME == \"Orange\")\nwd &lt;- st_is_within_distance(nc, orange, \n                            units::set_units(50, km))\no50 &lt;- nc |&gt; dplyr::filter(lengths(wd) &gt; 0)\nnrow(o50)\n# [1] 17\n\n(여기서 dplyr::filter()를 사용하는 것은 베이스 R의 filter() 함수와의 혼동을 피하기 위함이다.)(역자주: 베이스 R과 패키지, 또는 서로 다른 패키지에서 동일한 이름의 함수를 제공하는 경우, 충돌을 방지하기 위해 패키지명::함수명 형식으로 함수를 명시한다.)\n그림 7.3은 이 분석의 결과를 보여주며, 카운티 경계 주위에 버퍼도 추가되어 있다. 이 버퍼는 설명을 위한 것이며, 카운티를 선택하는 데에는 사용되지는 않았음을 유의하라.\n\n\n\n\n\n그림 7.3: 오렌지 카운티(오렌지색), 반경 50 km 내의 카운티(검은색), 오랜지 카운티 주변의 버퍼(갈색), 나머지 카운티(회색)",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#공간적-조인",
    "href": "07.html#공간적-조인",
    "title": "7  sf와 stars 패키지",
    "section": "\n7.2 공간적 조인",
    "text": "7.2 공간적 조인\n일반적인 조인(왼쪽 조인, 오른쪽 조인, 내부 조인)에서는 두 테이블에서 하나 이상의 속성이 매치할 때 조인이 이루어진다. 공간적 조인도 이와 유사하지만, 레코드를 조인하는 기준이 속성의 매치가 아니라 공간적 프레디케이트라는 점이 다르다. 이로 인해 공간적으로 매치하는 레코드를 정의하는 데에는 여러 선택지가 있으며, 이는 3.2.2절에 나열된 이항 프레디케이트를 사용해 결정할 수 있다. ‘왼쪽’, ‘오른쪽’, ‘내부’, ‘전체’ 조인의 개념은 비공간 조인과 동일하게 유지되는데, 이는 공간적 매치를 고려하지 않고 레코드의 조인을 처리할 때 적용된다.(역자주: 왼쪽 조인(left join)은 왼쪽 데이터의 모든 레코드를 유지하고, 오른쪽 데이터와 매치되는 경우 해당 값을 결합한다. 오른쪽 조인(right join)은 오른쪽 데이터의 모든 레코드를 유지하고, 왼쪽 데이터와 매치되는 경우 해당 값을 결합한다. 내부 조인(Inner join)은 양쪽 데이터 모두에서 매치되는 레코드만 결합한다. 전체 조인(full join)은 양쪽 데이터의 모든 레코드를 유지하며, 매치되지 않는 값은 결측값(NA)으로 채운다.)\n공간적 조인을 실행할 때, 각 레코드에 여러 일치하는 레코드가 존재할 수 있으므로 결과 테이블이 매우 커질 수 있다. 이러한 복잡성을 줄이는 방법 중 하나는, 일치하는 레코드 가운데 타깃 지오메트리와 가장 넓은 면적이 겹치는 레코드 하나만 선택하는 것이다. 이 방법의 시각적 예시는 그림 7.4에 나와 있으며, st_join() 함수에서 largest = TRUE 인수를 설정해 이를 수행할 수 있다.\n\n\n\n\n\n그림 7.4: largest = TRUE 인수를 적용한 st_join() 함수의 예시. 아래쪽 그림의 폴리곤과 가장 넓은 면적이 겹치는 위쪽 그림의 폴리곤 라벨이 아래쪽 폴리곤에 할당되어 있다.\n\n\n결과의 복잡성을 줄이는 또 다른 방법은 조인 후에 aggregate 함수를 사용하여 모든 일치하는 레코드를 결합함과 동시에 지오메트리도 병합하는 것이다. 이에 대한 자세한 내용은 5.4절을 참고하라.\n\n7.2.1 표본추출, 그리드 생성, 내삽\nsf 패키지가 제공하는 몇 가지 유용한 함수를 소개한다. st_sample() 함수는 대상 지오메트리로부터 임의의 표본 포인트를 생성하며, 여기서 대상 지오메트리는 포인트, 라인, 폴리곤 등 다양할 수 있다. 표본추출 방식은 완전 무작위 방식, 규칙적 방식, 또는 폴리곤의 경우 삼각형 방식 중 선택할 수 있다. 11장에서 spatstat 패키지가 제공하는 공간적 표본추출(또는 포인트패턴 시뮬레이션) 방법이 st_sample() 함수를 통해 어떻게 구현되는지 설명한다.\nst_make_grid() 함수는 특정 영역 위에 정사각형, 직사각형, 또는 육각형의 그리드를 생성한다. 옵션 설정에 따라 그리드 자체가 아닌 그리드의 중심점이나 모서리점을 생성할 수도 있다. 이 함수는 그림 7.4에서 직사각형 그리드를 생성하는 데 사용되었다.\n함수 st_interpolate_aw() 함수는 5.3절에서 설명한 바와 같이, 공간 내포 변수와 공간 외연 변수를 새로운 구역으로 ’내삽’하는 기능을 제공한다.",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#타원체-좌표",
    "href": "07.html#타원체-좌표",
    "title": "7  sf와 stars 패키지",
    "section": "\n7.3 타원체 좌표",
    "text": "7.3 타원체 좌표\n비투영 데이터는 경위도로 표현된 타원체 좌표를 가진다. 4.1절에서 설명한 바와 같이, 포인트 간의 ’직선’은 최단 곡선 경로인 ’측지선(geodesic line)’이다. 기본적으로 sf 패키지는 s2geometry 라이브러리를 사용해 기하학적 연산을 수행하며, 이는 s2 패키지를 통해 구현된다(Dunnington, Pebesma, and Rubak 2023).\n\n\"POINT(50 50.1)\" |&gt; st_as_sfc(crs = \"OGC:CRS84\") -&gt; pt\n\n예를 들어, 아래의 지점은 특정 폴리곤 내부에 위치한다(그림 7.5의 왼쪽: 정사 도법).\n\n\"POLYGON((40 40, 60 40, 60 50, 40 50, 40 40))\" |&gt;\n  st_as_sfc(crs = \"OGC:CRS84\") -&gt; pol\nst_intersects(pt, pol)\n# Sparse geometry binary predicate list of length 1, where the\n# predicate was `intersects'\n#  1: 1\n\n\n\n\n\n\n그림 7.5: 교차의 결과는 측지선 혹은 대권호를 사용하느냐(왼쪽) 데카르트 좌표계를 사용하느냐에 따라 달라진다.\n\n\nsf 패키지가 타원체 좌표를 마치 데카르트 좌표처럼 처리하도록 하려면, s2 사용을 비활성화하면 된다.\n\nold &lt;- sf_use_s2(FALSE)\n# Spherical geometry (s2) switched off\nst_intersects(pol, pt)\n# although coordinates are longitude/latitude, st_intersects assumes\n# that they are planar\n# Sparse geometry binary predicate list of length 1, where the\n# predicate was `intersects'\n#  1: (empty)\nsf_use_s2(old) # restore\n# Spherical geometry (s2) switched on\n\n이렇게 하면 그림 7.5의 오른쪽(정거원통 도법)처럼, 엠프티 교차가 반환된다. 경고 메시지에는 타원체 좌표를 평면좌표으로 취급하고 있다는 내용이 명시된다.\ns2 사용은 성능상의 이유나 레거시 구현과의 호환성을 위해 비활성화할 수 있다. 데카르트 기하를 위한 GEOS 라이브러리와 구체 기하를 위한 s2geometry 라이브러리(그림 1.7)는 서로 다른 동기로 개발되었으며, sf 패키지를 통해 사용될 때 몇 가지 차이가 있다.\n\n특정 연산에서 속도 차이가 크게 발생할 수 있다.\n일부 함수는 특정 라이브러리에만 존재한다(예를 들어 st_relate() 함수는 GEOS 라이브러리에만 존재)\n변환자를 사용할 때, GEOS는 외부 폴리곤 링을 시계 방향으로 노드로 반환하며, 이를 반시계 방향으로 되돌리기 위해 st_sfc(..., check_ring_dir = TRUE)를 사용한다. 반면, s2geometry는 외부 폴리곤 링을 반시계 방향으로 반환한다.",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#stars-패키지",
    "href": "07.html#stars-패키지",
    "title": "7  sf와 stars 패키지",
    "section": "\n7.4 stars 패키지",
    "text": "7.4 stars 패키지\nsp 패키지가 래스터 데이터 지원 측면에서 정체되어 있는 동안, raster 패키지(Hijmans 2023a)는 지난 10여년간 래스터 분석을 위한 강력하고 유연하며 확장 가능한 패키지로서 지배적인 위치를 공고히 해왔다. raster 패키지(및 그 후속인 terra 패키지(Hijmans 2023b))는 2차원 규칙 래스터 또는 래스터 레이어 집합(‘래스터 스택’)이라는 래스터 데이터 모형에 기반한다. 이러한 모형은 세상이 수많은 레이어로 구성되어 있고, 각 레이어가 특정 주제를 반영한다는 고전적인 정적 ’GIS 뷰’와 일치한다. 그러나 오늘날의 많은 데이터는 동적이며, 시계열 래스터 또는 시계열 래스터 스택의 형태로 제공된다. 기존의 래스터 스택은 이러한 동적 특성을 제대로 반영하지 못하며, 사용자가 각 레이어가 무엇을 나타내는지 별도로 기록해야 한다.\n또한, raster 패키지와 그 후속인 terra 패키지는 데이터 크기가 로컬 저장소(컴퓨터의 하드 드라이브)보다 크지 않을 때에만 우수한 연산 성능을 발휘한다. 그러나 최근의 데이터셋—예를 들어 위성 이미지, 기후 모형, 기상 예보 데이터—은 로컬 저장소의 용량으로는 더 이상 감당하기 어려운 수준에 도달했다(9장 참조). spacetime 패키지(Pebesma 2012, 2022)는 벡터 지오메트리 또는 래스터 그리드 셀의 시계열 분석을 어느 정도 지원하지만, 더 높은 차원의 어레이나 메모리가 한계를 넘어서는 대규모 데이터셋은 여전히 처리하기 어렵다.\n여기서는 래스터 및 벡터 데이터 큐브 분석을 위한 패키지로 stars를 소개한다. 이 패키지는 다음과 같은 기능을 제공한다.\n\n동적(시간 변화) 래스터 스택을 재현할 수 있다.\n로컬 디스크 용량에 제한받지 않는 확장성을 목표로 한다.\nGDAL 라이브러리의 래스터 기능과 강력하게 통합된다.\n규칙 그리드 뿐만 아니라 회전형, 전단형, 직선형, 곡선형 래스터도 처리할 수 있다(그림 1.6 참조).\nsf 패키지와 긴밀하게 통합된다.\n비래스터 공간 디맨션을 가진 어레이 데이터(벡터 데이터 큐브)를 처리할 수 있다.\n타이디버스 디자인 원리를 따른다.\n\n벡터 데이터 큐브에는 심플 피처의 시계열이나 출발지-목적지 매트릭스(및 그 시계열)를 포함한 공간 그래프 데이터가 포함된다. 공간적 벡터 및 래스터 데이터 큐브의 개념은 6장에서 설명되었다. 불규칙 시공간 관측치는 sftime 패키지(Teickner, Pebesma, and Graeler 2022)에서 제공하는 sftime 객체로 재현할 수 있으며, 이는 시간 열을 추가하는 방식으로 sf 객체를 확장한 것이다(13.3절 참조).\n\n7.4.1 래스터 데이터의 읽기와 쓰기\n래스터 데이터는 일반적으로 파일에서 불러온다. 여기서는 브라질의 올린다 시에 대한 30 m 해상도의 Landsat 7 데이터셋(밴드 1~5 및 7번)을 사용한다. stars 패키지에서 규칙 비회전 그리드에 대한 예제 GeoTIFF 파일을 읽어올 수 있다.\n\ntif &lt;- system.file(\"tif/L7_ETMs.tif\", package = \"stars\")\nlibrary(stars)\n# Loading required package: abind\n(r &lt;- read_stars(tif))\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      54     69 68.9      86  255\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n\n여기서 우리는 오프셋, 셀 크기, 좌표참조계, 그리고 디멘션을 확인할 수 있다. 디멘션 테이블은 각 디멘션에 대해 다음과 같은 필드를 포함한다.\n\nfrom: 시작 인덱스 값\nto: 종료 인덱스 값\noffset: 첫 번째 픽셀의 시작(모서리)에서의 디멘션 값\ndelta: 셀 크기로 음의 값은 디멘션 값이 감소할수록 픽셀 인덱스 값이 증가함을 의미\nrefsys: 참조계\npoint: 셀 값이 포인트 서포트인지, 셀 서포트인지를 나타내는 논리 값\nx/y: 디멘션이 래스터의 x축과 관련되는지, y축과 관련되는지를 나타내는 값\n\n여기에는 사용되지 않기 때문에 숨겨진 또 다른 필드인 values가 있다. 규칙, 회전형, 또는 전단형 그리드와 같이 일정하게 이산화된 디멘션(예: 시간)의 경우, offset과 delta는 NA가 아니다. 반면 불규칙하게 이산화된 디멘션의 경우에는 offset과 delta가 NA이며, values 속성에는 다음 중 하나가 포함된다.\n\n값 또는 구간의 시퀀스: 직선형 공간 래스터 또는 불규칙 시간 디멘션의 경우\n공간 디멘션과 연결된 지오메트리: 벡터 데이트 큐브의 경우\n각 래스터 셀에 대한 좌표값이 포함된 매트릭스: 곡선형 래스터의 경우\n디멘션 값과 연결된 밴드 이름 또는 레이블: 이산형 디멘션의 경우\n\nstars 클래스 객체 r은 길이 1의 단순 리스트로 구성되어 있으며, 3차원 어레이를 포함한다.\n\nlength(r)\n# [1] 1\nclass(r[[1]])\n# [1] \"array\"\ndim(r[[1]])\n#    x    y band \n#  349  352    6\n\n또한 이 객체는 어레이 디멘션이 무엇을 나타내는지 파악하는 데 필요한 모든 메타데이터를 포함한 디멘션 테이블을 속성으로 가진다. 이는 다음을 통해 확인할 수 있다.\n\nst_dimensions(r)\n\n다음과 같은 방법으로 어레이의 공간적 범위를 확인할 수 있다.\n\nst_bbox(r)\n#    xmin    ymin    xmax    ymax \n#  288776 9110729  298723 9120761\n\nwrite_stars() 함수를 사용하여 래스터 데이터를 로컬 디스크에 저장할 수 있다.\n\ntf &lt;- tempfile(fileext = \".tif\")\nwrite_stars(r, tf)\n\n파일 확장자를 통해 데이터 형식(이 경우 GeoTIFF)이 지정된다. 심플 피처와 마찬가지로 읽기 및 쓰기 작업은 GDAL 라이브러리를 사용하며, 래스터 데이터에 사용할 수 있는 드라이버 목록은 다음과 같이 확인할 수 있다.\n\nst_drivers(\"raster\")\n\n\n7.4.2 stars 데이터 큐브의 서브세팅\n데이터 큐브는 [] 연산자를 사용하거나 타이디버스 동사를 사용하여 서브세팅할 수 있다. 첫 번째 방식인 [] 연산자를 사용할 때는 다음 인수를 쉼표로 구분하여 순서대로 지정한다.\n\n속성: 이름, 인덱스, 또는 논리 벡터\n디멘션\n\n예를 들어, r[1:2, 101:200, , 5:10]는 r에서 속성 1~2를 선택하고, 디멘션 1에 대해 인덱스 101~200, 차원 3에 대해 인덱스 5~10을 선택함을 의미한다. 이 경우 디멘션 2를 통한 선택은 이루어지지 않는다. 속성 선택 시에는 속성 이름, 인덱스, 또는 논리 벡터를 사용할 수 있다. 디멘션 선택 시에는 논리 벡터가 지원되지 않는다. 불연속 범위 선택은 규칙 시퀀스일 때만 가능하다. drop는 기본값이 FALSE이며, TRUE로 설정하면 단일 값을 가진 디멘션은 모두 제거된다.\n\nr[,1:100, seq(1, 250, 5), 4] |&gt; dim()\n#    x    y band \n#  100   50    1\nr[,1:100, seq(1, 250, 5), 4, drop = TRUE] |&gt; dim()\n#   x   y \n# 100  50\n\n특정 범위의 디멘션 값을 선택하려면 filter() 함수를 사용할 수 있으며, 이를 위해서는 dplyr 패키지를 먼저 로드해야 한다.\n\nlibrary(dplyr, warn.conflicts = FALSE)\nfilter(r, x &gt; 289000, x &lt; 290000)\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     5      51     63 64.3      75  242\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1  35  289004  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6       1     1                NA    NA\n\n이는 차원의 오프셋을 변경한다. 특정 큐브 슬라이스는 slice() 함수를 사용하여 얻을 수 있다.\n\nslice(r, band, 3)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    21      49     63 64.4      77  255\n# dimension(s):\n#   from  to  offset delta            refsys point x/y\n# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n\n이는 단일 디멘션인 band를 제거한다. mutate() 함수는 stars 객체에서 기존 어레이를 기반으로 새로운 어레이를 추가하는 데 사용되며, transmute() 함수는 여기에 더해 기존 어레이를 제거한다.\n\n7.4.3 크로핑\n일부를 추출하는 또 다른 방법으로, sf, sfc 또는 bbox 클래스의 공간 객체를 사용하는 방법이 있다.\n\nb &lt;- st_bbox(r) |&gt;\n    st_as_sfc() |&gt;\n    st_centroid() |&gt;\n    st_buffer(units::set_units(500, m))\nr[b]\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max. NA's\n# L7_ETMs.tif    22      54     66 67.7    78.2  174 2184\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x     157 193  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y     159 194 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n\n예를 들어, 해당 지역에 대한 직경 500 m의 원형 중심부를 추출할 수 있으며, 그림 7.6은 이를 첫 번째 밴드에 적용한 결과를 보여준다.\n\n\n\n\n\n그림 7.6: Landsat 7의 1번 밴드 이미지의 원형 중심부\n\n\n원형 공간 객체의 외부에 위치한 픽셀에는 NA 값이 할당되는 것을 확인할 수 있다. 이 원형 객체는 여전히 r의 offset과 delta 값에 대한 디멘션 인덱스를 가지고 있다. 다음과 같은 방법으로 offset 값을 재설정할 수 있다.\n\nr[b] |&gt; st_normalize() |&gt; st_dimensions()\n#      from to  offset delta            refsys point x/y\n# x       1 37  293222  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 36 9116258 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1  6      NA    NA                NA    NA\n\n기본적으로 결과 래스터는 선택 객체의 범위로 크로핑(cropping, 자르기)된다. 입력 객체와 동일한 디멘션을 가진 객체는 다음과 같은 방식으로 얻을 수 있다.\n\nr[b, crop = FALSE]\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.   NA's\n# L7_ETMs.tif    22      54     66 67.7    78.2  174 731280\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n\nstars 객체의 크로핑은 st_crop() 함수를 사용해 직접 수행할 수도 있다.\n\nst_crop(r, b)\n\n\n7.4.4 stars 객체의 디멘션 재설정 및 결합\nstars 패키지는 다양한 어레이 조작을 수행하기 위해 abind 패키지(Plate and Heiberger 2016)를 사용한다. 예를 들어, 어레이를 순열하여 전치하는 aperm() 함수가 있다.\n\naperm(r, c(3, 1, 2))\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      54     69 68.9      86  255\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# band    1   6      NA    NA                NA    NA    \n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n\nstars 객체에 대한 메서드가 제공되며, 이를 통해 결과 객체의 디멘션 순서를 재배열할 수 있다.\n속성과 디멘션을 교환할 수도 있으며, 이는 split()과 merge() 함수를 사용해 수행된다.\n\n(rs &lt;- split(r))\n# stars object with 2 dimensions and 6 attributes\n# attribute(s):\n#     Min. 1st Qu. Median Mean 3rd Qu. Max.\n# X1    47      67     78 79.1      89  255\n# X2    32      55     66 67.6      79  255\n# X3    21      49     63 64.4      77  255\n# X4     9      52     63 59.2      75  255\n# X5     1      63     89 83.2     112  255\n# X6     1      32     60 60.0      88  255\n# dimension(s):\n#   from  to  offset delta            refsys point x/y\n# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\nmerge(rs, name = \"band\") |&gt; setNames(\"L7_ETMs\")\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#          Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs     1      54     69 68.9      86  255\n# dimension(s):\n#      from  to  offset delta            refsys point    values x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE      NULL [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE      NULL [y]\n# band    1   6      NA    NA                NA    NA X1,...,X6\n\nsplit() 함수는 밴드 디멘션을 2차원 어레이의 여섯 개 속성으로 분리하며, merge() 함수는 그 반대 작업을 수행한다. st_redimension() 함수는 단일 어레이 디멘션을 두 개의 새로운 디멘션으로 분할하는 것과 같은 보다 일반적인 작업에 사용된다.\n\nst_redimension(r, c(x = 349, y = 352, b1 = 3, b2 = 2))\n# stars object with 4 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      54     69 68.9      86  255\n# dimension(s):\n#    from  to  offset delta            refsys point x/y\n# x     1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y     1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# b1    1   3      NA    NA                NA    NA    \n# b2    1   2      NA    NA                NA    NA\n\n동일한 디멘션을 가진 여러 개의 stars 객체는 c() 함수를 사용해 결합할 수 있다. 결합된 어레이는 기본적으로 추가 속성으로 취급되지만, along 인수를 지정하면 새로운 디멘션을 따라 병합할 수도 있다.\n\nc(r, r, along = \"new_dim\")\n# stars object with 4 dimensions and 1 attribute\n# attribute(s), summary of first 1e+05 cells:\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    47      65     76 77.3      87  255\n# dimension(s):\n#         from  to  offset delta            refsys point x/y\n# x          1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y          1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band       1   6      NA    NA                NA    NA    \n# new_dim    1   2      NA    NA                NA    NA\n\n이 사용 예시는 7.5.2절에서 설명한다.\n\n7.4.5 포인트 샘플추출과 애그리게이션\n래스터 데이터 큐브 분석에서 매우 흔한 작업 중 하나는 특정 위치에서 값을 추출하거나 지정된 지오메트리에 대해 집계값을 계산하는 것이다. st_extract() 함수는 포인트 위치의 값을 추출한다. 여기서는 r 객체의 바운딩 박스 범위 안에서 임의로 선택한 몇 개의 샘플링 포인트에 대해 이 연산을 수행한다.\n\nset.seed(115517)\npts &lt;- st_bbox(r) |&gt; st_as_sfc() |&gt; st_sample(20)\n(e &lt;- st_extract(r, pts))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    12    41.8     63   61    80.5  145\n# dimension(s):\n#          from to            refsys point\n# geometry    1 20 SIRGAS 2000 / ...  TRUE\n# band        1  6                NA    NA\n#                                           values\n# geometry POINT (293002 ...,...,POINT (290941 ...\n# band                                        NULL\n\n이는 20개의 포인트와 6개의 밴드를 가진 벡터 데이터 큐브를 생성한다. 시드를 설정하면 반복 실행 시 동일한 샘플을 사용할 수 있다. 따라서 포인트를 무작위로 다시 생성하고자 하는 경우는 시드를 설정하지 않아야 한다.\n데이터 큐브에서 정보를 추출하는 또 다른 방법은 집계값을 계산하는 것이다. 이를 수행하는 한 가지 방법은 공간 폴리곤이나 라인에 따라 값을 공간적으로 집계하는 것이다(6.4절 참조). 예를 들어, 그림 1.4(d)에 나타난 세 개의 원 각각에 대해, 여섯 개 밴드에서의 최대 픽셀 값을 계산할 수 있다.\n\ncircles &lt;- st_sample(st_as_sfc(st_bbox(r)), 3) |&gt;\n    st_buffer(500)\naggregate(r, circles, max)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    73    94.2    117  121     142  205\n# dimension(s):\n#          from to            refsys point\n# geometry    1  3 SIRGAS 2000 / ... FALSE\n# band        1  6                NA    NA\n#                                           values\n# geometry POLYGON ((2913...,...,POLYGON ((2921...\n# band                                        NULL\n\n이는 세 개의 지오메트리와 여섯 개의 밴드를 가진 (벡터) 데이터 큐브를 생성한다. 시간 디멘션에 대한 집계는 aggregate() 함수의 두 번째 인수로 시간 변수를 지정하여 수행한다. 시간 변수로는 다음과 같은 값들을 사용할 수 있다.\n\n시간 간격의 시작을 나타내는 타임스탬프 집합\nmake_intervals() 함수로 정의된 시간 간격 집합\n‘주’, ‘5일’, ’년’과 같이 기간을 나타내는 문자열\n\n7.4.6 예측모형\nR에서의 일반적인 모형 예측 워크플로우는 다음과 같다.\n\n응답변수와 예측변수(공변량)가 포함된 data.frame을 준비한다.\ndata.frame을 기반으로 모형 객체를 생성한다.\n모형 객체와 대상 예측변수 값이 포함된 data.frame을 사용하여 predict()함수를 호출한다.\n\nstars 패키지는 stars 객체에 대한 predict() 메서드를 제공하며, 이는 위 과정의 마지막 단계를 수행한다. 즉, stars 객체에서 data.frame을 생성한 뒤, predict()를 호출하고, 예측 값으로 다시 stars 객체를 재구성한다.\n이 과정을 설명하기 위해, Landsat 데이터셋과 앞에서 추출한 표본 포인트를 이용해, 육지를 바다에서 분리하는 간단한 이진 클래스 예제를 살펴본다. 결과는 그림 7.7에 제시되어 있다.\n\n\n\n\n\n그림 7.7: 훈련 데이터로 사용된 무작위 표본 포인트: 빨간색은 해양부이고 노란색을 육지부를 나타낸다.\n\n\n이 그림에서 포인트 8, 14, 15, 18, 19는 수부에, 나머지 포인트는 육지부에 위치함을 ‘육안’으로 확인할 수 있다. 선형판별(’최대우도’) 분류기를 적용한 결과, 그림 7.8과 같은 모형 예측 결과를 얻을 수 있다.\n\nrs &lt;- split(r)\ntrn &lt;- st_extract(rs, pts)\ntrn$cls &lt;- rep(\"land\", 20)\ntrn$cls[c(8, 14, 15, 18, 19)] &lt;- \"water\"\nmodel &lt;- MASS::lda(cls ~ ., st_drop_geometry(trn))\npr &lt;- predict(rs, model)\n\n여기서는 MASS:: 접두사를 사용하여 MASS 패키지를 로드하지 않았는데, 이는 dplyr 패키지의 select() 함수를 덮어쓰는 것을 방지하기 위함이다. split 단계는 밴드 디멘션을 속성으로 변환해 예측 변수로 사용하기 위해 필요한 과정이다.\n\n\n\n\n\n그림 7.8: 그림 7.7의 훈련 데이터를 기반으로 한 육지부/수부 구분 선형 판별 분류 결과\n\n\n또한, 그림 7.8에 표시된 레이어가 클래스 레이블을 가진 범주형 변수임을 확인할 수 있다.\n\n7.4.7 래스터 데이터 플로팅\n\n\n\n\n\n그림 7.9: 30 m 해상도의 Landsat 6개 밴드를 90 m로 다운샘플한 결과로 브라질의 올린다의 예시이다.\n\n\n베이스 플롯 함수를 stars 객체에 적용할 수 있으며, plot(r)로 생성된 결과는 그림 7.9에 나타나 있다. 기본 색상 스케일은 회색 톤을 사용하고, 모든 밴드의 데이터 분위수에 맞춰 명암 대비를 조정하는 ’히스토그램 평활화’가 적용된다.(역자주: 히스토그램 평활화는 데이터의 분포를 재조정하여 시각적으로 더 유용하게 하고 세부 사항을 더 잘 드르나게 하는 기법이다. 예를 들어, 어두운 영상에서는 어두운 영역의 픽셀 값이 한쪽에 몰려 있는데, 히스토그램 평활화를 적용하면 이 픽셀 값의 범위를 더 넓게 확장(stretch)시켜 이미지를 더 밝고 선명하게 만들 수 있다.) breaks = \"equal\"로 설정하면 급폭이 동일한 등간격 분류법이 적용되며, 계급 단절값을 임의로 지정하는 것도 가능하다. 그런데 더 익숙한 시각화 방식은 그림 7.10에 나타난 RGB 또는 폴스(false) 컬러 합성일 것이다.\n\n\n\n\n\n그림 7.10: 컬러 합성의 두 가지 예시\n\n\n보다 자세한 사항은 8장에서 다룬다.\n\n7.4.8 래스터 데이터 분석\nstars 객체의 개별 원소에는 수리 함수가 어레이에 직접 적용된다. 이는 사용자가 함수를 호출하여 표현식을 생성할 수 있음을 의미한다.\n\nlog(r)\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     0    3.99   4.23 4.12    4.45 5.54\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\nr + 2 * log(r)\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      62   77.5 77.1    94.9  266\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n\n또는 특정 값을 마스킹할 수도 있다.\n\nr2 &lt;- r\nr2[r &lt; 50] &lt;- NA\nr2\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.   NA's\n# L7_ETMs.tif    50      64     75   79      90  255 149170\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n\n또는 마스킹을 해제할 수도 있다.\n\nr2[is.na(r2)] &lt;- 0\nr2\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     0      54     69   63      86  255\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n\nstars 객체에서는 기본 R의 apply() 함수가 어레이에 동작하는 것처럼, 선택된 어레이 디멘션 단위로 함수를 적용할 수 있다(6.3.3절). 예를 들어, 각 픽셀에 대해 6개 밴드 값의 평균을 계산할 수 있다.\n\nst_apply(r, c(\"x\", \"y\"), mean)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#       Min. 1st Qu. Median Mean 3rd Qu. Max.\n# mean  25.5    53.3   68.3 68.9      82  255\n# dimension(s):\n#   from  to  offset delta            refsys point x/y\n# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n\n더 유의미한 함수의 예로는 NDVI(Normalized Difference Vegetation Index, 정규화 식생 지수) 계산이 있다.\n\nndvi &lt;- function(b1, b2, b3, b4, b5, b6) (b4 - b3)/(b4 + b3)\nst_apply(r, c(\"x\", \"y\"), ndvi)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#         Min. 1st Qu.  Median    Mean 3rd Qu.  Max.\n# ndvi  -0.753  -0.203 -0.0687 -0.0643   0.187 0.587\n# dimension(s):\n#   from  to  offset delta            refsys point x/y\n# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n\n또는 함수를 다음과 같이 정의할 수도 있다.\n\nndvi2 &lt;- function(x) (x[4]-x[3])/(x[4]+x[3])\n\n밴드 수가 많을 경우 이러한 방식은 더 편리하지만, 각 픽셀마다 호출해야 하므로 위에서 정의한 ndvi() 함수보다 훨씬 느리다. 반면 ndvi() 함수는 모든 픽셀이나 큰 픽셀 덩어리에 대해 한 번만 호출하면 된다. 전체 영상에 대해 각 밴드의 평균은 다음과 같이 계산된다.\n\nst_apply(r, c(\"band\"), mean) |&gt; as.data.frame()\n#   band mean\n# 1    1 79.1\n# 2    2 67.6\n# 3    3 64.4\n# 4    4 59.2\n# 5    5 83.2\n# 6    6 60.0\n\n결과는 data.frame의 형태로 바로 출력해 볼 수 있을 만큼 작다. 위의 두 예제에서는 전체 디멘션이 모두 사라지지만, 항상 그런 것은 아니다(6.3.2절). 예를 들어, 각 밴드에 대해 세 개의 사분위수를 계산할 수도 있다.\n\nst_apply(r, c(\"band\"), quantile, c(.25, .5, .75))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    32    60.8   66.5 69.8    78.8  112\n# dimension(s):\n#          from to        values\n# quantile    1  3 25%, 50%, 75%\n# band        1  6          NULL\n\n이렇게 하면 세 개의 값으로 이루어진 새로운 디멘션인 quantile이 생성된다. 또는, 각 픽셀에 대해 여섯 개 밴드 값의 세 사분위수를 다음과 같이 계산할 수도 있다.\n\nst_apply(r, c(\"x\", \"y\"), quantile, c(.25, .5, .75))\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     4      55   69.2 67.2    81.2  255\n# dimension(s):\n#          from  to  offset delta            refsys point\n# quantile    1   3      NA    NA                NA    NA\n# x           1 349  288776  28.5 SIRGAS 2000 / ... FALSE\n# y           1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE\n#                 values x/y\n# quantile 25%, 50%, 75%    \n# x                 NULL [x]\n# y                 NULL [y]\n\n\n7.4.9 곡선형 래스터\n불규칙 래스터가 발생하는 이유는 다양하다(그림 1.6). 우선, 데이터가 지구의 곡면 형태를 그대로 반영하는 경우, 규칙 래스터는 곡면인 지구의 표면에 정확히 맞지 않는다. 다른 이유로는 다음과 같은 것들이 있다.\n\n규칙 래스터 데이터를 다른 좌표참조계로 변환하거나 재투영할 때, 워핑(7.8절)을 수행하지 않으면 곡선 형태로 나타난다. 그러나 워핑은 항상 데이터 손실을 수반하며, 이는 가역적이지 않다.\n관측 방식 자체가 불규칙 래스터를 만들어 낼 수 있다. 예를 들어 품질이 낮은 위성 영상의 경우, 위성의 진행 방향에서는 규칙 래스터 형태를 유지 하지만(\\(x\\) 또는 \\(y\\) 축과 정렬되지 않음), 진행 방향과 직각인 방향에서는 직교형 래스터가 된다(예: 센서가 시야각을 일정 간격으로 분할하여 관측하는 경우).\n\n7.4.10 GDAL 유틸리티\nGDAL 라이브러리는 일반적으로 데이터 변환과 처리를 위한 여러 실행 파일, 즉 GDAL 명령줄 유틸리티와 함께 제공된다. 이들 유틸리티 가운데 상당수(Python으로 작성된 것을 제외한 모든 유틸리티)는 ’GDAL Algorithms C API’를 통해 GDAL 라이브러리의 C 함수로도 제공된다. GDAL 라이브러리와 연동된 R 패키지(예: sf 패키지)가 이러한 C API 알고리즘을 사용한다면, 사용자는 별도로 GDAL 명령줄 유틸리티를 설치하지 않아도 된다.\nsf 패키지는 gdal_utils() 함수를 통해 이러한 C API 알고리즘을 호출할 수 있다. 이때 첫 번째 인수에는 gdal 접두사를 제외한 이름을 지정한다. 주요 명령과 기능은 다음과 같다.\n\ninfo: GDAL 래스터 데이터셋에 대한 정보를 출력한다.\nwarp: 래스터를 새로운 래스터로 변환한다(CRS의 전환 포함).\nrasterize: 벡터 데이터셋을 래스터화한다.\ntranslate: 래스터 파일을 다른 형식으로 변환한다.\nvectortranslate: 벡터 파일을 다른 형식으로 변환한다(ogr2ogr에 해당).\nbuildvrt: 가상 래스터 타일(여러 파일의 결합하여 생성된 단일 래스터)을 생성한다.\ndemprocessing: DEM(digital data model)에 대한 다양한 처리를 수행한다.\nnearblack: 거의 검정색 또는 흰색인 경계 부분을 검정색으로 변환한다.\ngrid: 흩어진 데이터로부터 규칙 그리드를 생성한다.\nmdiminfo: 다차원 어레이에 대한 정보를 출력한다.\nmdimtranslate: 다차원 어레이를 다른 형식으로 변환한다.\n\n이러한 유틸리티는 기본적으로 파일 단위로 작동하며, sf 또는 stars 객체에 직접 작용되지는 않는다. 그러나 stars_proxy 객체는 본질적으로 파일에 대한 포인터 역할을 하므로, 다른 객체들도 파일로 저장하여 사용할 수 있다. 이러한 유틸리티 중 일부는(항상 혹은 선택적으로) st_mosaic(), st_warp(), 또는 st_write() 등의 함수를 통해 호출된다. R의 gdalUtilities(O’Brien 2022) 패키지는 sf::gdal_utils() 함수에 기반하여, 명령줄 유틸리티 인수 이름과 동일한 인수 이름을 사용하는 편의성 래퍼 함수를 제공한다.",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#벡터-데이터-큐브-예제",
    "href": "07.html#벡터-데이터-큐브-예제",
    "title": "7  sf와 stars 패키지",
    "section": "\n7.5 벡터 데이터 큐브 예제",
    "text": "7.5 벡터 데이터 큐브 예제\n\n7.5.1 예제: 대기질 시계열 데이터 애그리게이션 실행\n유럽 대기질 데이터를 사례로, 벡터 데이터 큐브의 애그리게이션 작업을 설명한다. 이 데이터는 Gräler, Pebesma와 Heuvelink(2016)에서 사용된 것과 동일하며, 12장과 13장에서도 다시 사용될 예정이다. 독일 농촌 지역 관측소에서 1998~2009년 동안 수집한 데이터를 바탕으로 일평균 \\(\\text{PM}_{10}\\) 값을 계산하였다.\nair 데이터 매트릭스, 날짜 벡터 dates, 그리고 SpatialPoints 객체 stations을 결합하여 stars 객체를 생성할 수 있다.\n\nload(\"data/air.rda\") # this loads several datasets in .GlobalEnv\ndim(air)\n# space  time \n#    70  4383\nstations |&gt;\n    st_as_sf(coords = c(\"longitude\", \"latitude\"), crs = 4326) |&gt;\n    st_geometry() -&gt; st\nd &lt;- st_dimensions(station = st, time = dates)\n(aq &lt;- st_as_stars(list(PM10 = air), dimensions = d))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#       Min. 1st Qu. Median Mean 3rd Qu. Max.   NA's\n# PM10     0    9.92   14.8 17.7      22  274 157659\n# dimension(s):\n#         from   to     offset  delta refsys point\n# station    1   70         NA     NA WGS 84  TRUE\n# time       1 4383 1998-01-01 1 days   Date FALSE\n#                                          values\n# station POINT (9.59 53.7),...,POINT (9.45 49.2)\n# time                                       NULL\n\n그림 7.11에서는 시간 시계열이 상당히 길지만, 큰 결측 구간도 존재함을 확인할 수 있다. 그림 7.12는 평균 \\(\\text{PM}_{10}\\) 값과 함께 측정소의 공간 분포를 보여준다.\n\n\n\n\n\n그림 7.11: 시간과 관측소별로 계산된 PM10 값에 대한 시공간 다이어그램\n\n\n\n\n\n\n\n그림 7.12: 관측소별 PM10 평균값\n\n\n간단한 실습 차원에서, 관측소별 시간 시계열 데이터를 지역 평균으로 애그리게이션할 수 있다. 이를 위해 stars 객체에 대한 aggregate() 메서드를 사용한다.\n\n(a &lt;- aggregate(aq, de_nuts1, mean, na.rm = TRUE))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#       Min. 1st Qu. Median Mean 3rd Qu. Max.  NA's\n# PM10  1.08    10.9   15.3 17.9    21.8  172 25679\n# dimension(s):\n#      from   to     offset  delta refsys point\n# geom    1   16         NA     NA WGS 84 FALSE\n# time    1 4383 1998-01-01 1 days   Date FALSE\n#                                       values\n# geom MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# time                                    NULL\n\n또한, 아래 코드를 통해 임의로 선택한 여섯 날짜의 지도를 표시할 수 있다(그림 7.13).\n\nlibrary(tidyverse)\na |&gt; filter(time &gt;= \"2008-01-01\", time &lt; \"2008-01-07\") |&gt; \n    plot(key.pos = 4)\n\n\n\n\n\n\n그림 7.13: 임의의 여섯 날짜에 대한 지역 평균 PM10\n\n\n또한, 아래 코드를 이용해 단일 주(state)의 평균값 시계열 플롯을 생성할 수 있다(그림 7.14).\n\nlibrary(xts) |&gt; suppressPackageStartupMessages()\nplot(as.xts(a)[,4], main = de_nuts1$NAME_1[4])\n\n\n\n\n\n\n그림 7.14: 단일 주에 대한 지역 평균 PM10의 시계열 플롯\n\n\n\n7.5.2 예제: 브리스톨 출발지-도착지 데이터 큐브\n이 예제에 사용된 데이터는 Lovelace, Nowosad와 Muenchow(2019)에서 가져온 출발지-목적지(OD) 매트릭스로, A 지역에서 B 지역으로 이동하는 인구수를 교통수단별로 나타낸 것이다. 102개 지역의 피처 지오메트리는 sf 객체인 bristol_zones에 포함되어 있다.\n\n\n\n\n\n그림 7.15: 영국 브리스톨의 102개 구역 현황(33번 구역(E02003043)이 빨간색으로 표시되어 있음)\n\n\nbristol_od 테이블에 OD 쌍(이동량이 0인 경우는 제외)이 레코드로 저장되어 있으며, 서로 다른 교통수단이 변수로 포함되어 있다.\n\nhead(bristol_od)\n# # A tibble: 6 × 7\n#   o         d           all bicycle  foot car_driver train\n#   &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n# 1 E02002985 E02002985   209       5   127         59     0\n# 2 E02002985 E02002987   121       7    35         62     0\n# 3 E02002985 E02003036    32       2     1         10     1\n# 4 E02002985 E02003043   141       1     2         56    17\n# 5 E02002985 E02003049    56       2     4         36     0\n# 6 E02002985 E02003054    42       4     0         21     0\n\n제외된 무이동 OD 쌍의 개수는 모든 OD 조합 수에서 데이터에 포함된 OD 쌍 수를 빼서 구할 수 있다.\n\nnrow(bristol_zones)^2 - nrow(bristol_od) \n# [1] 7494\n\n우리는 출발지, 목적지, 교통수단을 디멘션으로 하는 3차원 벡터 데이터 큐브를 만들 것이다. 이를 위해 먼저 pivot_longer() 함수를 사용하여 bristol_od 테이블을 정리해, 출발지(o), 목적지(d), 교통수단(mode), 빈도(n) 변수를 갖도록 한다.\n\n# create O-D-mode array:\nbristol_tidy &lt;- bristol_od |&gt; \n    select(-all) |&gt; \n    pivot_longer(3:6, names_to = \"mode\", values_to = \"n\")\nhead(bristol_tidy)\n# # A tibble: 6 × 4\n#   o         d         mode           n\n#   &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;\n# 1 E02002985 E02002985 bicycle        5\n# 2 E02002985 E02002985 foot         127\n# 3 E02002985 E02002985 car_driver    59\n# 4 E02002985 E02002985 train          0\n# 5 E02002985 E02002987 bicycle        7\n# 6 E02002985 E02002987 foot          35\n\n그리고 나서 0으로 채워진 3차원 어레이 a를 생성한다.\n\nod &lt;- bristol_tidy |&gt; pull(\"o\") |&gt; unique()\nnod &lt;- length(od)\nmode &lt;- bristol_tidy |&gt; pull(\"mode\") |&gt; unique()\nnmode = length(mode)\na = array(0L,  c(nod, nod, nmode), \n    dimnames = list(o = od, d = od, mode = mode))\ndim(a)\n# [1] 102 102   4\n\n해당 어레이의 세 차원에 구역 이름(o, d)과 교통수단 이름(mode)이 부여되어 있음을 확인할 수 있다. 이렇게 함으로써 bristol_tidy의 각 행은 해당 어레이의 한 단위(엔트리)에 해당하게 된다. bristol_tidy 테이블에 있는 인덱스(o, d 및 mode)와 값(n)을 이용해 해당 어레이(a)의 0이 아닌 부분을 채울 수 있다.\n\na[as.matrix(bristol_tidy[c(\"o\", \"d\", \"mode\")])] &lt;- \n        bristol_tidy$n\n\nbristol_zones의 구역과 bristol_tidy의 구역명이 서로 다른 순서를 가질 수 있으므로, 아래와 같이 인덱스를 일치 시키는 정렬 절차를 수행한다.\n\norder &lt;- match(od, bristol_zones$geo_code)\nzones &lt;- st_geometry(bristol_zones)[order]\n\n순서가 이미 올바를 수도 있지만, 그런 가정은 배제하고 위 코드를 그대로 실행하는 편이 안전하다. 다음으로, 구역과 교통수단을 이용해 stars 디멘션 객체를 생성한다.\n\nlibrary(stars)\n(d &lt;- st_dimensions(o = zones, d = zones, mode = mode))\n#      from  to refsys point                                  values\n# o       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# d       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# mode    1   4     NA FALSE                       bicycle,...,train\n\n마지막으로, 어레이 a와 디멘션 d를 이용해 최종 stars 객체를 생성한다.\n\n(odm &lt;- st_as_stars(list(N = a), dimensions = d))\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#    Min. 1st Qu. Median Mean 3rd Qu. Max.\n# N     0       0      0  4.8       0 1296\n# dimension(s):\n#      from  to refsys point                                  values\n# o       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# d       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# mode    1   4     NA FALSE                       bicycle,...,train\n\n이 3차원 어레이에서 단일 슬라이스를 추출할 수 있다. 예를 들어, 구역 33에 대한 데이터를 odm[ , , 33]으로 추출한 뒤 플롯을 그릴 수 있다(그림 7.16).\n\nplot(adrop(odm[,,33]) + 1, logz = TRUE)\n\n\n\n\n\n\n그림 7.16: 33번 존에 대한 OD 데이터를 추출한 후 교통수단별로 지도화하였다.\n\n\n이렇게 서브세팅을 수행하면, 첫 번째 인수가 비어 있으므로 모든 속성(여기서는 하나만 존재: N)을 선택하고, 두 번째 인수가 비어 있어 모든 출발지를 선택하며, 세 번째 인수로 목적지 구역 33을 선택하고, 네 번째 인수가 비어 있어 모든 교통 수단을 선택하게 된다.\n이 특정 구역을 목적지로 선택한 이유는 해당 구역이 가장 많은 여행자를 보유하고 있기 때문이다. 이는 목적지별로 모든 출발지와 여행 수단을 합산해 확인할 수 있다.\n\nd &lt;- st_apply(odm, 2, sum)\nwhich.max(d[[1]])\n# [1] 33\n\n다른 애그리게이션도 수행할 수 있다. 예를 들어, OD(102 × 102)의 총통행량은 다음과 같이 구할 수 있다.\n\nst_apply(odm, 1:2, sum)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#      Min. 1st Qu. Median Mean 3rd Qu. Max.\n# sum     0       0      0 19.2      19 1434\n# dimension(s):\n#   from  to refsys point                                  values\n# o    1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# d    1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n\n교통수단별로 출발지 총계를 구할 수 있다.\n\nst_apply(odm, c(1,3), sum)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#      Min. 1st Qu. Median Mean 3rd Qu. Max.\n# sum     1    57.5    214  490     771 2903\n# dimension(s):\n#      from  to refsys point                                  values\n# o       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# mode    1   4     NA FALSE                       bicycle,...,train\n\n교통수단별로 도착지 총계를 구할 수 있다.\n\nst_apply(odm, c(2,3), sum)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#      Min. 1st Qu. Median Mean 3rd Qu.  Max.\n# sum     0      13    104  490     408 12948\n# dimension(s):\n#      from  to refsys point                                  values\n# d       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# mode    1   4     NA FALSE                       bicycle,...,train\n\n모드별 합산 출발지 총계를 구할 수 있다.\n\no &lt;- st_apply(odm, 1, sum)\n\n모드별 합산 도착지 총계를 구할 수 있다.\n\nd &lt;- st_apply(odm, 2, sum)\n\no와 d를 결합한 뒤 함께 플롯할 수 있다(그림 7.17).\n\nx &lt;- (c(o, d, along = list(od = c(\"origin\", \"destination\"))))\nplot(x, logz = TRUE)\n\n\n\n\n\n\n그림 7.17: 출발지별 총통근(왼쪽)과 목적지별 총통근(오른쪽)\n\n\n이 지도는 현상의 본질을 왜곡할 수 있다는 우려가 있다. 그 이유는 실질적인 값의 크기(컬러) 뿐만 아니라 구역의 면적 역시 시각적으로 인지되는 양의 크기에 영향을 미치기 때문이다. 이를 감안해 밀도값(카운트/\\(\\text{km}^2\\))을 계산해 나타낼 수 있다(그림 7.18).(역자주: 지도학적 원칙에 따르면, 총통근과 같은 카운트 변수를 코로플레스 맵으로 표현하는 것은 적절하지 않다. 보다 바람직한 방법은 도형표현도로 나타내는 것이다.)\n\nlibrary(units)\na &lt;- set_units(st_area(st_as_sf(o)), km^2)\no$sum_km &lt;- o$sum / a\nd$sum_km &lt;- d$sum / a\nod &lt;- c(o[\"sum_km\"], d[\"sum_km\"], along = \n        list(od = c(\"origin\", \"destination\")))\nplot(od, logz = TRUE)\n\n\n\n\n\n\n그림 7.18: 출발지별 총통근 밀도(왼쪽)와 목적지별 총통근 밀도(오른쪽)\n\n\n카운트 속성을 정규화하는 또 다른 방법은 값을 면적이 아닌 인구수로 나누는 것이다.\n\n7.5.3 타이디 어레이 데이터\nWickham(2014)의 타이디 데이터 논문은 3차원 데이터를 어레이 데이터 형식보다는 각 행이 (지역, 클래스, 연도, 값)으로 구성된 긴(비정규화된) 테이블 형식으로 처리되는 것이 더 바람직하다고 제안한다. 이는 가능하다면 항상 좋은 접근이다. 그러나 기본 처리나 저장 목적에서는 이 방법을 적용할 수 없는 경우가 있으며, 그 이유는 다음과 같다.\n\n많은 어레이 데이터는 처음부터 어레이 형식으로 수집되거나 생성된다. 예를 들어, 원격탐사를 통해 수집된 데이터나 기후 모형을 통해 생성된 데이터가 이에 해당한다.\n어레이 형식을 긴 테이블 형태로 변환하는 것이 그 반대보다 훨씬 쉽다.\n긴 테이블 형식의 데이터는 훨씬 더 많은 메모리를 요구한다. 디멘션 \\(i\\)의 기수(크기)를 \\(n_i\\)라고 할 때, 디멘션 값이 차지하는 메모리 공간은 \\(O(\\sum{n_i})\\)가 아니라 \\(O(\\prod{n_i})\\)로 주어진다.\n결측값이 있는 셀을 삭제하면, 긴 테이블 형식은 어레이 형식이 내재하고 있는 인덱싱을 상실하게 된다.\n\n이 주장을 극단적으로 표현하자면, 모든 이미지, 비디오, 음성 데이터가 어레이 형식으로 저장된다고 가정해 보자. 실제로 이를 긴 테이블 형식으로 저장해야 한다고 주장하는 사람은 거의 없을 것이다. 그럼에도 불구하고 tsibble(Wang et al. 2022)과 같은 R 패키지는 긴 테이블 형식을 취하고 있으며, 동일한 시간 스텝을 가진 다수의 공간적 피처에 순서를 매기는 작업이 매우 모호함에도 불구하고 어쨋든 인덱싱을 해야 한다는 문제점이 있다. 이러한 문제는 stars 패키지에서 제공하는 어레이 형식을 사용함으로써 자동으로 해결된다. 물론 이는 조밀한 어레이를 사용해야한다는 대가를 치루는 것이기도 하다.\nstars 패키지는 어레이 집합을 처리하는 문제에 있어 타이디 데이터 원칙(tidy manifesto)을 따르려 하며, 특히 하나 이상의 디멘션이 공간 및/또는 시간을 참조하는 경우에 그러하다.\n\n7.5.4 벡터 데이터 큐브를 위한 파일 포맷\n규칙 테이블 형식(긴 테이블 형식을 포함)은 하나의 대안이지만 사용하기에는 불편하다. 위의 출발지-목적지 데이터 예제와 13장에서 다룰 내용은 테이블 형식에서 벡터 데이터 큐브를 재구성하는 작업이 매우 복잡하다는 점을 잘 보여준다. NetCDF나 Zarr와 같은 어레이 형식은 어레이 데이터를 저장하기 위해 설계되었으나, 사실상 모든 데이터 구조를 저장할 수 있다. 다만, 한 번 작성된 파일은 재사용하기 어렵다는 위험이 있다. 포인트, (멀티)라인스트링, (멀티)폴리곤으로 구성된 단일 지오메트리 디멘션을 가진 벡터 데이터 큐브의 경우, CF 규칙(Eaton et al. 2022)은 이러한 지오메트리를 인코딩하는 방법을 설명한다. stars::read_mdim() 함수와 stars::write_mdim() 함수는 이 규칙을 따르는 벡터 데이터 큐브를 읽고 쓸 수 있다.",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#래스터-벡터-전환과-벡터-래스터-전환",
    "href": "07.html#래스터-벡터-전환과-벡터-래스터-전환",
    "title": "7  sf와 stars 패키지",
    "section": "\n7.6 래스터-벡터 전환과 벡터-래스터 전환",
    "text": "7.6 래스터-벡터 전환과 벡터-래스터 전환\n1.3절에서 래스터-벡터 전환과 벡터-래스터 전환의 몇 가지 예제를 이미 다루었다. 이 절에서는 이에 대한 코드와 예제를 추가로 제시한다.\n\n7.6.1 벡터-래스터 전환\nst_as_stars() 함수는 객체를 stars 객체로 변환하도록 설계된 메서드이다. 그러나 모든 stars 객체가 래스터 객체인 것은 아니며, sf 객체에 이 메서드들 적용하면 지오메트리를 공간적(벡터) 디멘션으로, 속성을 속성 디멘션으로 가지는 벡터 데이터 큐브가 생성된다. 피처 지오메트리(sfc) 객체가 주어지면, st_as_stars() 함수는 이를 래스터화한다(7.8절과 그림 7.19).\n\nfile &lt;- system.file(\"gpkg/nc.gpkg\", package=\"sf\")\nread_sf(file) |&gt; \n    st_geometry() |&gt;\n    st_as_stars() |&gt;\n    plot(key.pos = 4)\n\n\n\n\n\n\n그림 7.19: st_as_stars() 함수를 활용한 백터 지오메트리의 래스터화\n\n\nst_as_stars() 함수는 셀 크기, 셀 수 그리고/또는 범위를 제어하는 파라미터를 설정할 수 있다. 반환되는 셀 값은 중심점이 지오메트리 외부에 있는 경우 0이고, 지오메트리 내부 또는 경계에 있는 경우 1이다. 기존 피처를 래스터화하는 작업은 st_rasterize() 함수를 사용해 수행하며, 이는 그림 1.5에서도 확인할 수 있다.\n\nlibrary(dplyr)\nread_sf(file) |&gt;\n    mutate(name = as.factor(NAME)) |&gt;\n    select(SID74, SID79, name) |&gt;\n    st_rasterize()\n# stars object with 2 dimensions and 3 attributes\n# attribute(s):\n#      SID74           SID79            name       \n#  Min.   : 0      Min.   : 0      Sampson :  655  \n#  1st Qu.: 3      1st Qu.: 3      Columbus:  648  \n#  Median : 5      Median : 6      Robeson :  648  \n#  Mean   : 8      Mean   :10      Bladen  :  604  \n#  3rd Qu.:10      3rd Qu.:13      Wake    :  590  \n#  Max.   :44      Max.   :57      (Other) :30952  \n#  NA's   :30904   NA's   :30904   NA's    :30904  \n# dimension(s):\n#   from  to offset   delta refsys point x/y\n# x    1 461  -84.3  0.0192  NAD27 FALSE [x]\n# y    1 141   36.6 -0.0192  NAD27 FALSE [y]\n\n라인과 포인트 지오메트리도 이와 유사하게 래스터화할 수 있다(그림 7.20).\n\nread_sf(file) |&gt;\n    st_cast(\"MULTILINESTRING\") |&gt;\n    select(CNTY_ID) |&gt;\n    st_rasterize() |&gt;\n    plot(key.pos = 4)\n\n\n\n\n\n\n그림 7.20: 노스캐롤라이나 카운티 경계를 래스터로 전환하기",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#좌표변환-및-좌표전환",
    "href": "07.html#좌표변환-및-좌표전환",
    "title": "7  sf와 stars 패키지",
    "section": "\n7.7 좌표변환 및 좌표전환",
    "text": "7.7 좌표변환 및 좌표전환\n\n7.7.1 st_crs() 함수\nsf 또는 stars 클래스의 공간 객체는 CRS(좌표참조계)를 포함하고 있다. st_crs() 함수를 사용하여 해당 객체의 CRS를 확인하거나 다른 CRS로 교체할 수 있다. 또한, st_set_crs()함수를 사용하여 CRS를 설정하거나 교체할 수 있다. CRS는 EPSG 코드로 설정할 수 있으며, 예를 들어 st_crs(4326)는 st_crs('EPSG:4326')로 변환된다. 또는 \"+proj=utm +zone=25 +south\"와 같은 PROJ.4 문자열, \"WGS84\"와 같은 이름, \"OGC:CRS84\"처럼 기관명이 앞에 붙은 이름으로도 설정할 수 있다. 대안으로 WKT, WKT-2(2.5절), 또는 PROJJSON 형식의 CRS 정의를 사용할 수 있다. st_crs() 함수가 반환하는 객체는 다음 두 개의 필드를 포함한다.\n\nwkt: WKT-2 형식으로 표현된 CRS\ninput: 사용자 입력(있는 경우), 또는 CRS에 대한 인간 가독 설명(가능한 경우)\n\nPROJ.4 문자열은 일부 CRS을 정의하는 데는 사용할 수 있지만, CRS 전체를 대표하는 용도로는 적합하지 않다. 예를 들어, crs 객체의 WKT-2를 $proj4string 메서드를 사용해 proj4string으로 전환하려면 다음과 같이 한다.\n\nx &lt;- st_crs(\"OGC:CRS84\")\nx$proj4string\n# [1] \"+proj=longlat +datum=WGS84 +no_defs\"\n\n그러나, 이 과정이 성공적으로 이루어졌다 하더라도, 일반적으로 정보 손실이 수반되며 가역적으로 전환되지 않는다. PROJ.4 문자열을 사용해 CRS를 정의하는 경우(예: 파라미터가 지정된 투영 CRS), 해당 투영 CRS가 WGS84 데이텀과 관련되는 한에는 문제가 없다.\n\n7.7.2 st_transform()함수와 st_project() 함수\nsf 또는 stars 객체의 좌표변환이나 좌표전환은 st_transform()함수를 사용해 수행한다. 이 함수의 첫 번째 인수는 CRS가 설정된 sf 또는 stars 클래스의 공간 객체이고, 두 번째 인수는 crs 객체(또는 st_crs() 함수로 변환 가능한 값이다. 소스 crs에서 타깃 crs로 변환 또는 전환하는 방법이 여러 가지인 경우, PROJ는 가장 높은 명시(declared) 정확도를 가진 방법을 선택한다. 더 세밀한 옵션은 7.7.5절에서 설명된다. 규칙 래스터 디멘션을 가진 stars 객체의 경우, st_transform() 함수는 좌표만 변환하며 항상 곡선형 그리드를 생성한다. 새로운 CRS에서 규칙 래스터를 생성하려면, 재그리딩(regridding)을 수행하는 st_warp() 함수를 사용하면 된다(7.8절).\nsf나 stars 객체가 아닌 경우의 좌표변환이나 좌표전환은 저수준(lower-level) 함수인 sf_project()를 통해 수행된다. 이 함수는 좌표가 담긴 행렬과 소스 및 타깃 CRS(crs)를 입력받아, 변환 또는 전환된 좌표를 반환한다.\n\n7.7.3 sf_proj_info() 함수\nsf_proj_info() 함수는 PROJ 소프트웨어에서 사용 가능한 투영, 타원체, 단위 및 본초 자오선에 대한 정보를 조회하는 데 사용된다. 이 함수는 단일 매개변수 type을 받으며, type에는 다음과 같은 값을 지정할 수 있다.\n\ntype = \"proj\": 사용 가능한 투영법의 짧은 이름과 긴 이름을 나열한다. 짧은 이름은 “+proj=name” 문자열에서 사용할 수 있다.\ntype = \"ellps\": 사용 가능한 타원체를 나열하며, 이름, 긴 이름 및 타원체의 파라미터 정보를 포함한다.\ntype = \"units\": 사용 가능한 길이 단위를 나열하며, 미터로의 변환 상수 정보를 포함한다.\ntype = \"prime_meridians\": 본초 자오선을 나열하고, 그리니치 자오선과의 상대적 위치 정보를 포함한다.\n\n7.7.4 데이텀 그리드, proj.db, cdn.proj.org. 로컬 캐쉬\n데이텀 그리드(2.4절 참조)는 로컬에 설치하거나 PROJ 측량 그리드 CDN(https://cdn.proj.org/)에서 불러 올 수 있다. 로컬에 설치된 경우, 데이텀 그리드는 PROJ 검색 경로를 통해 불러오며, 이 경로는 다음과 같이 표시된다.\n\nsf_proj_search_paths()\n# [1] \"/home/edzer/.local/share/proj\" \"/usr/share/proj\"\n\n핵심 PROJ 데이터베이스는 proj.db이며, 일반적으로 다음 위치에서 불러올 수 있는 sqlite3 데이터베이스이다.\n\npaste0(tail(sf_proj_search_paths(), 1), .Platform$file.sep, \n       \"proj.db\")\n# [1] \"/usr/share/proj/proj.db\"\n\n각 PROJ 릴리스에 포함된 EPSG 데이터베이스 스냅샷의 버전은 proj.db의 \"metadata\" 테이블에 명시되어 있으며, sf 패키지에서 사용되는 PROJ 런타임 버전은 다음과 같이 표시된다.\n\nsf_extSoftVersion()[\"PROJ\"]\n#    PROJ \n# \"9.1.1\"\n\n특정 좌표변환에 필요한 데이텀 그리드가 로컬에 없을 경우, PROJ는 PROJ CDN에서 온라인 데이텀 그리드를 검색한다. 단, 아래의 결과가 TRUE인 경우에 한한다.\n\nsf_proj_network()\n# [1] FALSE\n\n기본값은 FALSE로 설정되어 있지만, 이를 TRUE로 변경하면 해당 네트워크 리소스의 URL을 반환한다. 이 리소스는 더 빠르거나 제한이 덜한 다른 리소스로 변경할 수도 있다.\n\nsf_proj_network(TRUE)\n# [1] \"https://cdn.proj.org\"\n\nCDN에서 데이텀 그리드를 조회한 후, PROJ는 조회된 그리드의 일부만(기본값은 전체 그리드가 아님) 로컬 캐시에 기록한다. 이 캐시는 사용자 디렉터리에 저장된 또 다른 sqlite3 데이터베이스이며, 다음과 같이 표시된다.\n\nlist.files(sf_proj_search_paths()[1], full.names = TRUE)\n# [1] \"/home/edzer/.local/share/proj/cache.db\"\n\n차후의 데이텀 그리드 조회는 이 데이터베이스를 우선적으로 참조한다.\n\n7.7.5 변환 파이프라인\n내부적으로 PROJ는 소스 CRS에서 타겟 CRS로 변환하는 연산 시퀀스를 나타내기 위해, 이른바 좌표 연산 파이프라인(coordinate operation pipeline)을 사용한다. 소스에서 타겟으로 가는 여러 옵션이 있을 경우, st_transform() 함수는 가장 높은 정확도의 옵션을 선택한다. 사용 가능한 옵션을 조회하려면 sf_proj_pipelines() 함수를 사용하면 된다.\n\n(p &lt;- sf_proj_pipelines(\"OGC:CRS84\", \"EPSG:22525\"))\n# Candidate coordinate operations found:  5 \n# Strict containment:     FALSE \n# Axis order auth compl:  FALSE \n# Source:  OGC:CRS84 \n# Target:  EPSG:22525 \n# Best instantiable operation has accuracy: 2 m\n# Description: axis order change (2D) + Inverse of Corrego Alegre\n#              1970-72 to WGS 84 (2) + UTM zone 25S\n# Definition:  +proj=pipeline +step +proj=unitconvert +xy_in=deg\n#              +xy_out=rad +step +inv +proj=hgridshift\n#              +grids=br_ibge_CA7072_003.tif +step\n#              +proj=utm +zone=25 +south +ellps=intl\n\n해당 변환에서 가장 높은 정확도를 보이는 연산 파이프라인이 요약되어 있으며, 특정 데이텀 그리드의 사용이 지정되어 있음을 확인할 수 있다. 네트워크 검색을 활성화하지 않았다면 다른 결과가 나왔을 것이다.\n\nsf_proj_network(FALSE)\n# character(0)\nsf_proj_pipelines(\"OGC:CRS84\", \"EPSG:22525\")\n# Candidate coordinate operations found:  5 \n# Strict containment:     FALSE \n# Axis order auth compl:  FALSE \n# Source:  OGC:CRS84 \n# Target:  EPSG:22525 \n# Best instantiable operation has accuracy: 2 m\n# Description: axis order change (2D) + Inverse of Corrego Alegre\n#              1970-72 to WGS 84 (2) + UTM zone 25S\n# Definition:  +\n\n이 경우에는 데이텀 그리드 관련 정보가 누락되어 있음을 확인할 수 있다. sf_proj_pipelines() 함수가 반환하는 객체는 서브클래스화된 data.frame으로, 다음과 같은 열을 포함한다.\n\nnames(p)\n# [1] \"id\"           \"description\"  \"definition\"   \"has_inverse\" \n# [5] \"accuracy\"     \"axis_order\"   \"grid_count\"   \"instantiable\"\n# [9] \"containment\"\n\n예를 들어 다음과 같이 정확도를 나열할 수 있다.\n\np |&gt; pull(accuracy)\n# [1]  2  5  5  8 NA\n\n여기서 NA는 ’대략적인 정확도’를 의미하며, 이는 30~120 m 범위 내의 값을 가진다.\n\np |&gt; filter(is.na(accuracy))\n# Candidate coordinate operations found:  1 \n# Strict containment:     FALSE \n# Axis order auth compl:  FALSE \n# Source:  OGC:CRS84 \n# Target:  EPSG:22525 \n# Best instantiable operation has only ballpark accuracy \n# Description: Ballpark geographic offset from WGS 84 (CRS84) to\n#              Corrego Alegre 1970-72 + UTM zone 25S\n# Definition:  +proj=pipeline +step +proj=unitconvert +xy_in=deg\n#              +xy_out=rad +step +proj=utm +zone=25\n#              +south +ellps=intl\n\nst_transform() 함수가 선택한 가장 정확한 오프레이션 파이프라인이 기본값이지만, pipeline 인수를 지정하면 결과를 변경할 수도 있다. 이 경우 p$definition에 있는 옵션 중 하나를 선택하면 된다.\n\n7.7.6 축 순서와 방향\n2.5절에서 언급했듯이, EPSG:4326은 첫 번째 축을 위도에, 두 번째 축을 경도에 대응하도록 정의한다. 이는 많은 다른 타원체 CRS에서도 동일하다. 이러한 방식은 해당 기관(EPSG)이 규정한 것이지만, 현재 대부분의 데이터셋은 이러한 방식을 따르지 않는다. 대부분의 다른 소프트웨어와 마찬가지로, sf 패키지는 이를 무시하고 기본값으로 타원체 좌표 쌍을 (경도, 위도)로 해석한다. 그러나 해당 기관의 규정을 준수하는 데이터 원천(예: WFS 서비스)에서 생성된 데이터를 읽어야 하는 경우, 다음과 같이 지정할 수 있다.\n\nst_axis_order(TRUE)\n\n이렇게 하면 sf 패키지가 GDAL과 PROJ 루틴을 호출할 때, 규정 준수(위도, 경도 순서)가 항상 전제되도록 할 수 있다. 그러나 이러한 규정 준수 과정에서 많은 문제가 발생할 수 있으며, 예를 들어 데이터를 플로팅할 때 그 문제가 드러난다. sf 객체를 위한 플롯 메서드는 축 순서 규정을 준수하며, 플로팅 전에 변환 파이프라인 \"+proj=pipeline +step +proj=axisswap +order=2,1\"을 사용해 위도, 경도 순서를 바꾸지만, ggplot2 패키지의 geom_sf는 이러한 수정 과정을 거치지 않는다. 앞서 언급했듯이, EPSG:4326에서 발견되는 축 순서의 모호성은 OGC:CRS84를 사용하면 모두 해결된다.\n축 순서와는 별개의 문제로, 모든 CRS가 북쪽과 동쪽 방향을 양의 값으로 지정하는 것은 아니라는 점도 매우 중요하다. R의 대부분의 플로팅 함수는 이와 반대로 정의된 축을 가진 데이터에서는 제대로 작동하지 않는다. 축의 방향과 단위에 대한 정보는 다음과 같이 확인할 수 있다.\n\nst_crs(4326)$axes\n#                 name orientation\n# 1  Geodetic latitude           1\n# 2 Geodetic longitude           3\nst_crs(4326)$ud_unit\n# 1 [°]\nst_crs(\"EPSG:2053\")$axes\n#       name orientation\n# 1  Westing           4\n# 2 Southing           2\nst_crs(\"EPSG:2053\")$ud_unit\n# 1 [m]",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#래스터-변환-및-워프",
    "href": "07.html#래스터-변환-및-워프",
    "title": "7  sf와 stars 패키지",
    "section": "\n7.8 래스터 변환 및 워프",
    "text": "7.8 래스터 변환 및 워프\n래스터 데이터셋에 대해 st_transform() 함수를 사용할 때는 다음과 같이 한다.\n\ntif &lt;- system.file(\"tif/L7_ETMs.tif\", package = \"stars\")\nread_stars(tif) |&gt;\n    st_transform('OGC:CRS84')\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      54     69 68.9      86  255\n# dimension(s):\n#      from  to refsys point                    values x/y\n# x       1 349 WGS 84 FALSE [349x352] -34.9,...,-34.8 [x]\n# y       1 352 WGS 84 FALSE [349x352] -8.04,...,-7.95 [y]\n# band    1   6     NA    NA                      NULL    \n# curvilinear grid\n\n이제 곡선형 그리드가 생성된 것을 확인할 수 있다 이는 새로운 CRS에 따라 모든 그리드 셀의 좌표가 재계산되므로 더 이상 규칙 그리드로 존재할 수 없음을 의미한다. 이러한 데이터를 플로팅하면 속도가 극도로 느려지는데, 그 이유는 각 그리드 셀에 대해 작은 폴리곤을 먼저 계산한 뒤 플로팅하기 때문이다. 장점은 정보가 손실되지 않는다는 점으로, 투영 이후에도 그리드 셀의 값은 그대로 유지된다.\n규칙 그리드를 입력하여 새로운 CRS에서도 규칙 그리드를 산출하려면 워프 연산을 적용해야 한다. 즉, 새로운 위치에 그리드를 재생성하고 새로운 그리드 셀에 값을 할당하는 특정 규칙을 사용해야 한다. 이 과정에는 가장 가까운 값을 사용하거나 방법이나, 어떤 형태의 보간법을 적용하는 방법도 포함될 수 있다.(역자주: 이러한 작업은 GIS 래스터 분석인 원격탐사 분야에서는 재샘플링(resampling)이라고 하는데, 최근린(nearest neighbor), 양선형(bilibear), 3차 회선(cubic convolution) 등의 내삽 기법이 사용된다.) 다만, 이 연산은 정보 손실이 발생하며, 한 번 수행되면 원래 데이터로 되돌릴 수 없다.\n워핑을 할 때 가장 좋은 방법은 타깃 그리드를 stars 객체로 명시하는 것이다. 타깃 CRS만 지정하면, 타깃 그리드의 기본 옵션이 자동으로 선택되는데, 이는 실제 작업 상황에 전혀 맞지 않을 수도 있다. 아래 예시는 목표 CRS만 지정했을 때의 워크플로를 보여준다.\n\nread_stars(tif) |&gt;\n    st_warp(crs = st_crs('OGC:CRS84')) |&gt;\n    st_dimensions()\n#      from  to offset     delta refsys x/y\n# x       1 350  -34.9  0.000259 WGS 84 [x]\n# y       1 352  -7.95 -0.000259 WGS 84 [y]\n# band    1   6     NA        NA     NA\n\n이 방법은 원본과 상당히 비슷한 래스터를 생성하지만, 변환 정도도 비교적 작다. 소스 래스터와 정확히 동일한 행과 열을 갖는 타깃 래스터를 먼저 생성하려는 워크플로우의 경우, 다음과 같이 하면 된다.\n\nr &lt;- read_stars(tif)\ngrd &lt;- st_bbox(r) |&gt;\n        st_as_sfc() |&gt;\n        st_transform('OGC:CRS84') |&gt;\n        st_bbox() |&gt;\n        st_as_stars(nx = dim(r)[\"x\"], ny = dim(r)[\"y\"])\nst_warp(r, grd)\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max. NA's\n# L7_ETMs.tif     1      54     69 68.9      86  255 6180\n# dimension(s):\n#      from  to offset     delta refsys x/y\n# x       1 349  -34.9   0.00026 WGS 84 [x]\n# y       1 352  -7.95 -0.000259 WGS 84 [y]\n# band    1   6     NA        NA     NA\n\n여기서 \\(x\\)와 \\(y\\)의 방향의 그리드 해상도가 조금 달라졌음을 확인할 수 있다.",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "07.html#연습문제",
    "href": "07.html#연습문제",
    "title": "7  sf와 stars 패키지",
    "section": "\n7.9 연습문제",
    "text": "7.9 연습문제\nR을 사용하여 다음 연습문제를 해결하시오.\n\nnc 카운티 중 LINESTRING(-84 35,-78 35)와 인턱센션하는 카운티의 이름을 찾으시오. 이를 위해 []를 사용하고, 대안으로 st_join() 함수를 사용하시오.\nsf_use_s2(FALSE)를 설정한 후 위 작업을 반복하고, 차이를 계산하시오(힌트: setdiff()사용). 차이가 나타나는 카운티는 색상 ‘#88000088’로 채색하시오.\n두 지점 사이의 직선과 대권을 하나의 플롯에 그리시오. 현재 사용 중인 투영법에서는 R이 직선을 항상 직선으로 그린다는 점을 명심하시오. st_segmentize() 함수를 사용하여 직선 또는 타원 좌표의 대권 상에 포인트를 추가하시오.\nNDVI는 (NIR-R)/(NIR+R)로 계산되며, 여기서 NIR은 근적외선 밴드, R은 적색 밴드이다. L7_ETMs.tif 파일을 객체 x로 읽고, split(x, \"band\")를 사용하여 밴드 디멘션을 속성으로 분리하시오. 그런 다음 NIR(밴드 4)과 R(밴드 3) 속성을 직접 사용하는 표현식을 이용해 이 객체에 NDVI 속성을 추가하시오.\nL7_ETMs.tif 이미지의 밴드 디맨션을 축소하여 NDVI를 계산하시오. 이를 위해 st_apply() 함수와 ndvi = function(x) { (x[4]-x[3])/(x[4]+x[3]) } 함수를 사용하시오. 결과를 플로팅하고, GeoTIFF 형식으로 저장하시오.\nL7_ETMs.tif에서 읽은 stars 객체를 st_transform() 함수를 사용하여 OGC:CRS84로 변환하시오. 객체를 출력하시오. 이것이 규칙 그리드인지 확인하시오. 첫 번째 밴드를 axes=TRUE, border=NA 인수와 함께 플로팅하고, 왜 이렇게 시간이 오래 걸리는지 설명하시오.\nL7_ETMs.tif 객체를 st_warp() 함수를 사용하여 OGC:CRS84로 변환하시오. 결과 객체를 axes=TRUE로 플로팅하시오. 왜 st_transform() 함수에 비해 플롯이 훨씬 더 빨리 생성되는지 설명하시오.\n래스터 L7_ETMs의 벡터 표현을 사용하여 POINT(293716 9113692)를 중심으로 반지름 75 m인 원형 영역과의 교차를 플로팅하고, 이 원의 면적 가중 평균 픽셀 값을 계산하시오. 벡터 데이터에 aggregate() 함수를 적용하여 얻은 결과와 래스터 데이터에 aggregate() 함수를 적용하여 얻은 결과(exact=FALSE 및 exact=TRUE 각각)를 비교하고, 차이점을 설명하시오.\n\n\n\n\n그림 7.1: sf 객체의 구조\n그림 7.2: 노스케롤라이나의 처음 일곱개 카운티\n그림 7.3: 오렌지 카운티(오렌지색), 반경 50 km 내의 카운티(검은색), 오랜지 카운티 주변의 버퍼(갈색), 나머지 카운티(회색)\n그림 7.4: largest = TRUE 인수를 적용한 st_join() 함수의 예시. 아래쪽 그림의 폴리곤과 가장 넓은 면적이 겹치는 위쪽 그림의 폴리곤 라벨이 아래쪽 폴리곤에 할당되어 있다.\n그림 7.5: 교차의 결과는 측지선 혹은 대권호를 사용하느냐(왼쪽) 데카르트 좌표계를 사용하느냐에 따라 달라진다.\n그림 7.6: Landsat 7의 1번 밴드 이미지의 원형 중심부\n그림 7.7: 훈련 데이터로 사용된 무작위 표본 포인트: 빨간색은 해양부이고 노란색을 육지부를 나타낸다.\n그림 7.8: 그림 7.7의 훈련 데이터를 기반으로 한 육지부/수부 구분 선형 판별 분류 결과\n그림 7.9: 30 m 해상도의 Landsat 6개 밴드를 90 m로 다운샘플한 결과로 브라질의 올린다의 예시이다.\n그림 7.10: 컬러 합성의 두 가지 예시\n그림 7.11: 시간과 관측소별로 계산된 PM10 값에 대한 시공간 다이어그램\n그림 7.12: 관측소별 PM10 평균값\n그림 7.13: 임의의 여섯 날짜에 대한 지역 평균 PM10\n그림 7.14: 단일 주에 대한 지역 평균 PM10의 시계열 플롯\n그림 7.15: 영국 브리스톨의 102개 구역 현황(33번 구역(E02003043)이 빨간색으로 표시되어 있음)\n그림 7.16: 33번 존에 대한 OD 데이터를 추출한 후 교통수단별로 지도화하였다.\n그림 7.17: 출발지별 총통근(왼쪽)과 목적지별 총통근(오른쪽)\n그림 7.18: 출발지별 총통근 밀도(왼쪽)와 목적지별 총통근 밀도(오른쪽)\n그림 7.19: st_as_stars() 함수를 활용한 백터 지오메트리의 래스터화\n그림 7.20: 노스캐롤라이나 카운티 경계를 래스터로 전환하기",
    "crumbs": [
      "공간데이터사이언스와 R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>sf와 stars 패키지</span>"
    ]
  },
  {
    "objectID": "11.html",
    "href": "11.html",
    "title": "11  포인트 패턴 분석",
    "section": "",
    "text": "11.1 관측 윈도우\n포인트 패턴은 관측 윈도우(observation window)를 가진다. 관측 윈도우는 포인트가 기록될 수 있는 공간적 범위를 정의하며, 분석에서 중요한 역할을 한다. 다음 코드는 무작위 포인트 패턴을 생성하는 예시이다.\nlibrary(sf)\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\nn &lt;- 30\nset.seed(13531) # remove this to create another random sequence\nxy &lt;- data.frame(x = runif(n), y = runif(n)) |&gt; \n    st_as_sf(coords = c(\"x\", \"y\"))\n이 포인트들은 \\([0,1]\\times[0,1]\\) 영역 내에 고르게 분포하고 있으며, 완전한 공간적 무작위 분포로도 표현할 수 있다. 그러나 영역의 크기가 커지면 ’고르게 분포한다’고 말하기는 어려워 진다. 예를 들어, 아래 코드로 두 개의 정사각형 영역(w1과 w2)을 생성하는 예시를 보여준다(그림 11.1).\nw1 &lt;- st_bbox(c(xmin = 0, ymin = 0, xmax = 1, ymax = 1)) |&gt; \n        st_as_sfc() \nw2 &lt;- st_sfc(st_point(c(1, 0.5))) |&gt; st_buffer(1.2)\nspatstat 패키지는 포인트 패턴을 ppp 클라스의 객체로 저장한다. 모든 ppp 객체는 포인트의 위치 정보와 관측 윈도우(owin 클라스의 객체)를 함께 가진다. 다음 예시는 포인트 데이터를 이용해 ppp 객체를 생성하는 방법을 보여준다.\nlibrary(spatstat) |&gt; suppressPackageStartupMessages()\nas.ppp(xy)\n# Planar point pattern: 30 points\n# window: rectangle = [0.009, 0.999] x [0.103, 0.996] units\n여기서 관측 윈도우를 별도로 지정되지 않으면, 포인트들의 바운딩 박스가 자동으로 관측 윈도우로 설정된다. 데이터셋의 첫 번째 피처로 폴리곤 지오메트리를 추가하면, 해당 폴리곤이 관측 윈도우로 사용된다.\n(pp1 &lt;- c(w1, st_geometry(xy)) |&gt; as.ppp())\n# Planar point pattern: 30 points\n# window: polygonal boundary\n# enclosing rectangle: [0, 1] x [0, 1] units\nc1 &lt;- st_buffer(st_centroid(w2), 1.2)\n(pp2 &lt;- c(c1, st_geometry(xy)) |&gt; as.ppp())\n# Planar point pattern: 30 points\n# window: polygonal boundary\n# enclosing rectangle: [-0.2, 2.2] x [-0.7, 1.7] units\n포인트 패턴의 등질성(homogeneity)을 검정하기 위해, 적절한 방격 레이아웃을 설정할 수 있다.(역자주: 포인트 패턴의 등질성은 기대 밀도가 모든 지점에서 동일한지를 의미한다.) 예를 들어, 그림 11.2에는 3 × 3 레이아웃이 나타나 있다. 이를 사용하여 방격 빈도(quadrat count), 즉 방격별 포인트 수를 구할 수 있다.\npar(mfrow = c(1, 2), mar = rep(0, 4))\nq1 &lt;- quadratcount(pp1, nx=3, ny=3)\nq2 &lt;- quadratcount(pp2, nx=3, ny=3)\nplot(q1, main = \"\")\nplot(xy, add = TRUE)\nplot(q2, main = \"\")\nplot(xy, add = TRUE)\n이 방격 빈도 정보를 이용하여 다음과 같이 \\(\\chi^2\\) 검정을 수행한다.\nquadrat.test(pp1, nx=3, ny=3)\n# Warning: Some expected counts are small; chi^2 approximation may be\n# inaccurate\n# \n#   Chi-squared test of CSR using quadrat counts\n# \n# data:  pp1\n# X2 = 8, df = 8, p-value = 0.9\n# alternative hypothesis: two.sided\n# \n# Quadrats: 9 tiles (irregular windows)\nquadrat.test(pp2, nx=3, ny=3)\n# Warning: Some expected counts are small; chi^2 approximation may be\n# inaccurate\n# \n#   Chi-squared test of CSR using quadrat counts\n# \n# data:  pp2\n# X2 = 43, df = 8, p-value = 2e-06\n# alternative hypothesis: two.sided\n# \n# Quadrats: 9 tiles (irregular windows)\n이는 두 번째 사례가 완전공간무작위성(CSR, complete spatial randomness) 패턴이 아님을 시사한다. 경고 메시지에 언급된 대로 기대빈도가 너무 작으므로 유의확률(\\(p\\) 값)의 해석에는 각별한 주의가 필요하다.\ndensity() 함수를 사용하면 커널 밀도를 계산할 수 있으며, 커널의 형태와 탐색반경을 조정할 수 있다. 탐색반경을 결정하는 파라미터 sigma 값은 bw.diggle() 함수의 교차검증을 통해 지정되며, 그림 11.3에 이렇게 생성된 밀도면이 나타나 있다.\nden1 &lt;- density(pp1, sigma = bw.diggle)\nden2 &lt;- density(pp2, sigma = bw.diggle)\n이러한 방식으로 생성된 밀도 지도는 본질적으로 래스터 이미지이므로, 이를 stars 객체로 변환할 수 있다.\nlibrary(stars)\n# Loading required package: abind\ns1 &lt;- st_as_stars(den1)\n(s2 &lt;- st_as_stars(den2))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#        Min.  1st Qu. Median Mean 3rd Qu. Max. NA's\n# v  6.28e-15 0.000153  0.304 6.77    13.1 42.7 3492\n# dimension(s):\n#   from  to offset   delta x/y\n# x    1 128   -0.2  0.0187 [x]\n# y    1 128    1.7 -0.0187 [y]\n밀도면 하부 체적을 계산하면, 다음 코드에서 확인할 수 있듯이 표본크기(30)와 유사한 값을 얻을 수 있다.(역자주: ’밀도면 하부 체적’이란 각 셀별로 면적과 밀도값을 곱하여 셀 체적을 구하고 모든 셀에 대한 이 체적값을 합한 값을 의미한다.)\ns1$a &lt;- st_area(s1) |&gt; suppressMessages()\ns2$a &lt;- st_area(s2) |&gt; suppressMessages()\nwith(s1, sum(v * a, na.rm = TRUE))\n# [1] 29\nwith(s2, sum(v * a, na.rm = TRUE))\n# [1] 30.7\n여기에 밀도면을 외부 변수의 함수로 나타내는 모형화를 적용하면 더 흥미로운 결과를 얻을 수 있다. 예를 들어, pp2의 밀도를 푸아송 포인트 패턴 프로세스로 모형화한다고 가정해 보자(즉, 포인트 간에 상호작용이 없다고 가정). 이때 밀도의 변화는 ‘클러스터’ 중심으로부터의 거리의 함수로 설명되며, 해당 거리값은 stars 객체에 포함되어 있다.\npt &lt;- st_sfc(st_point(c(0.5, 0.5)))\nst_as_sf(s2, as_points = TRUE, na.rm = FALSE) |&gt;\n  st_distance(pt) -&gt; s2$dist\n그런 다음 ppm() 함수를 사용하여 밀도를 모형화할 수 있으며, formula의 왼쪽에는 포인트 패턴 객체의 이름이 위치한다.\n(m &lt;- ppm(pp2 ~ dist, data = list(dist = as.im(s2[\"dist\"]))))\n# Nonstationary Poisson process\n# Fitted to point pattern dataset 'pp2'\n# \n# Log intensity:  ~dist\n# \n# Fitted trend coefficients:\n# (Intercept)        dist \n#        4.54       -4.24 \n# \n#             Estimate  S.E. CI95.lo CI95.hi Ztest  Zval\n# (Intercept)     4.54 0.341    3.87    5.21   *** 13.32\n# dist           -4.24 0.700   -5.62   -2.87   *** -6.06\n반환된 객체는 ppm 클래스이며, 이를 플로팅할 수 있다. 그림 11.4는 예측된 밀도면을 보여주며, 예측 표준오차 역시 플로팅할 수 있다.\n모형에는 predict() 메서드도 있어, 이를 통해 im 객체를 반환하며, 이 객체는 다음과 같이 stars 객체로 전환될 수 있다.\npredict(m, covariates = list(dist = as.im(s2[\"dist\"]))) |&gt;\n    st_as_stars()\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#      Min. 1st Qu. Median Mean 3rd Qu. Max. NA's\n# v  0.0698   0.529   2.13 6.62     7.3 89.7 3492\n# dimension(s):\n#   from  to offset   delta x/y\n# x    1 128   -0.2  0.0187 [x]\n# y    1 128    1.7 -0.0188 [y]",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포인트 패턴 분석</span>"
    ]
  },
  {
    "objectID": "11.html#관측-윈도우",
    "href": "11.html#관측-윈도우",
    "title": "11  포인트 패턴 분석",
    "section": "",
    "text": "그림 11.1: 관찰 윈도우(회색)에 따라 동일한 포인트 패턴이 공간적으로 완전히 무작위로 나타날 수도 있고(왼쪽), 군집을 이루고 있는 것으로 나타날 수도 있다(오른쪽).\n\n\n\n\n\n\n\n\n\n\n\n\n\n그림 11.2: 두 포인트 패턴의 3 × 3 방격 빈도\n\n\n\n\n\n\n\n\n\n\n\n\n그림 11.3: 두 포인트 패턴에 대한 커널 밀도면\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n그림 11.4: ppm 모형에 기반한 예측 밀도면",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포인트 패턴 분석</span>"
    ]
  },
  {
    "objectID": "11.html#crs",
    "href": "11.html#crs",
    "title": "11  포인트 패턴 분석",
    "section": "\n11.2 CRS",
    "text": "11.2 CRS\nspatstat 패키지의 모든 루틴은 데카르트 좌표계를 사용하는 2차원 데이터에 맞게 설계되어 있다. 따라서 타원체 좌표계(위도, 경도)를 가진 객체를 변환하려고 시도하면 오류가 발생한다.\n\nsystem.file(\"gpkg/nc.gpkg\", package = \"sf\") |&gt; \n    read_sf() |&gt;\n    st_geometry() |&gt;\n    st_centroid() |&gt;\n    as.ppp()\n# Error: Only projected coordinates may be converted to spatstat\n# class objects\n\nspatstat 패키지의 데이터 구조로 변환되면, 원래의 CRS(coordinate reference system, 좌표참조계) 정보가 손실된다. 이를 다시 sf 또는 stars 객체로 복원하려면 st_set_crs() 함수를 사용해야 된다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포인트 패턴 분석</span>"
    ]
  },
  {
    "objectID": "11.html#마크-포인트-패턴과-선형-네트워크-상의-포인트",
    "href": "11.html#마크-포인트-패턴과-선형-네트워크-상의-포인트",
    "title": "11  포인트 패턴 분석",
    "section": "\n11.3 마크 포인트 패턴과 선형 네트워크 상의 포인트",
    "text": "11.3 마크 포인트 패턴과 선형 네트워크 상의 포인트\nspatstat 패키지에서는 몇 가지 확장된 데이터 유형을 상호 변환할 수 있다. 마크(marked) 포인트 패턴은 각 포인트에 범주형 레이블 또는 숫자형 레이블이 ‘부여된’ 포인트 패턴을 말한다. 예를 들어, spatstat 패키지에 포함된 longleaf 소나무 데이터셋은 가슴 높이에서 측정한 나무 직경 값을 숫자형 마크로 포함하고 있다.\n\nlongleaf\n# Marked planar point pattern: 584 points\n# marks are numeric, of storage type  'double'\n# window: rectangle = [0, 200] x [0, 200] metres\nll &lt;- st_as_sf(longleaf)\nprint(ll, n = 3)\n# Simple feature collection with 585 features and 2 fields\n# Geometry type: GEOMETRY\n# Dimension:     XY\n# Bounding box:  xmin: 0 ymin: 0 xmax: 200 ymax: 200\n# CRS:           NA\n# First 3 features:\n#    spatstat.geom..marks.x.  label                           geom\n# NA                      NA window POLYGON ((0 0, 200 0, 200 2...\n# 1                     32.9  point                POINT (200 8.8)\n# 2                     53.5  point                 POINT (199 10)\n\n해당 값은 다음과 같이 ppp 객체로 다시 변환할 수 있다.\n\nas.ppp(ll)\n# Warning in as.ppp.sf(ll): only first attribute column is used for\n# marks\n# Marked planar point pattern: 584 points\n# marks are numeric, of storage type  'double'\n# window: polygonal boundary\n# enclosing rectangle: [0, 200] x [0, 200] units\n\nspatstat 패키지의 psp 클래스에 속하는 선분은 LINESTRING 지오메트리를 가진 sf 피처로 상호 변환할 수 있으며, 관측 윈도우를 나타내는 POLYGON 피처가 하나 포함된다.\n\nprint(st_as_sf(copper$SouthLines), n = 5)\n# Simple feature collection with 91 features and 1 field\n# Geometry type: GEOMETRY\n# Dimension:     XY\n# Bounding box:  xmin: -0.335 ymin: 0.19 xmax: 35 ymax: 158\n# CRS:           NA\n# First 5 features:\n#     label                           geom\n# 1  window POLYGON ((-0.335 0.19, 35 0...\n# 2 segment LINESTRING (3.36 0.19, 10.4...\n# 3 segment LINESTRING (12.5 0.263, 11....\n# 4 segment LINESTRING (11.2 0.197, -0....\n# 5 segment LINESTRING (6.35 12.8, 16.5...\n\n마지막으로, 선형 네트워크상의 포인트 패턴은 spatstat 패키지에서 lpp 객체로 표현되며, 다음과 같이 sf 객체로 변환할 수 있다.\n\nprint(st_as_sf(chicago), n = 5)\n# Simple feature collection with 620 features and 4 fields\n# Geometry type: GEOMETRY\n# Dimension:     XY\n# Bounding box:  xmin: 0.389 ymin: 153 xmax: 1280 ymax: 1280\n# CRS:           NA\n# First 5 features:\n#     label seg tp marks                           geom\n# 1  window  NA NA  &lt;NA&gt; POLYGON ((0.389 153, 1282 1...\n# 2 segment  NA NA  &lt;NA&gt; LINESTRING (0.389 1254, 110...\n# 3 segment  NA NA  &lt;NA&gt; LINESTRING (110 1252, 111 1...\n# 4 segment  NA NA  &lt;NA&gt; LINESTRING (110 1252, 198 1...\n# 5 segment  NA NA  &lt;NA&gt; LINESTRING (198 1277, 198 1...\n\n여기서는 처음 다섯 개 피처만 표시되어 있어 쉽게 눈에 띄지는 않지만, label 변수를 보면 포인트들도 이 객체에 포함되어 있음을 알 수 있다.\n\ntable(st_as_sf(chicago)$label)\n# \n#   point segment  window \n#     116     503       1\n\n네트워크의 구조에 관한 정보, 즉 LINESTRING 지오메트리가 어떻게 연결되어 있는지는 sf 객체에 포함되지 않는다. 이런 측면에서 sfnetworks 패키지(van der Meer et al. 2022)는 좋은 대안이 될 수 있다. 이 패키지는 네트워크 위상 정보를 다룰 수 있을 뿐 아니라 OpenStreetMap에서 불러온 네트워크 데이터를 spatstat 패키지로 전달하는 기능도 제공한다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포인트 패턴 분석</span>"
    ]
  },
  {
    "objectID": "11.html#공간적-표본추출과-포인트-프로세스-시뮬레이션하기",
    "href": "11.html#공간적-표본추출과-포인트-프로세스-시뮬레이션하기",
    "title": "11  포인트 패턴 분석",
    "section": "\n11.4 공간적 표본추출과 포인트 프로세스 시뮬레이션하기",
    "text": "11.4 공간적 표본추출과 포인트 프로세스 시뮬레이션하기\nsf 패키지에는 MULTIPOINT, 선형, 또는 폴리곤 지오메트리에서 포인트를 표본추출하는 st_sample() 메서드가 있으며, 여러 가지 공간적 표본추출 전략을 지원한다. 기본적으로 ‘random’, ‘hexagonal’, ‘Fibonacci’(11.5절 참고), ‘regular’ 옵션을 제공한다. ‘regular’는 정사각형 격자에서의 표본추출을, ’hexagonal’은 사실상 삼각형 격자에 해당하는 표본추출을 의미한다. ’random’ 유형만 요청한 포인트 수를 정확히 반환하며, 다른 유형은 근사값을 반환한다.\nst_sample() 함수는 표본추출 유형에 다른 값을 지정할 경우, spatstat 패키지의 포인트 프로세스 시뮬레이션 함수와도 연동된다. 예를 들어, type = Thomas로 설정하면 spatstat 패키지의 rThomas() 함수가 호출된다(그림 11.5).\n\nkappa &lt;- 30 / st_area(w2) # intensity\nth &lt;- st_sample(w2, kappa = kappa, mu = 3, scale = 0.05, \n    type = \"Thomas\")\nnrow(th)\n# [1] 90\n\n\n\n\n\n\n그림 11.5: mu =3, scale = 0.05로 설정한 Thomas 프로세스\n\n\n?rThomas를 실행하면 함수 rThomas()의 매개변수 kappa, mu, scale의 의미를 자세히 확인할 수 있다. 포인트 프로세스 시뮬레이션에서는 표본크기를 지정하는 대신 강도를 지정한다. 이때 관측 윈도우 내에서 실제로 생성되는 표본크기는 확률변수가 된다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포인트 패턴 분석</span>"
    ]
  },
  {
    "objectID": "11.html#구체-상에서-포인트-시뮬레이션하기",
    "href": "11.html#구체-상에서-포인트-시뮬레이션하기",
    "title": "11  포인트 패턴 분석",
    "section": "\n11.5 구체 상에서 포인트 시뮬레이션하기",
    "text": "11.5 구체 상에서 포인트 시뮬레이션하기\nsf 패키지에서 기본적으로 제공하는 또 다른 공간적 무작위 표본추출 유형은 구면에서의 무작위 포인트 시뮬레이션이다. 그림 11.6은 그 한 예시로, 생성된 포인트들이 모두 해양에 위치해 있다. 구면에서 규칙적인 포인트 패턴을 시뮬레이션하려면 st_sample() 함수에서 인수를 type = \"Fibonacci\"로 지정하면 된다(González 2010).\n\n\n\n\n\n그림 11.6: 구면에서 해양부에만 제한된 표본 포인트: 무작위 패턴(왼쪽)과 규칙 패턴(오른쪽)이 정사 도법 지도에 표시되어 있다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포인트 패턴 분석</span>"
    ]
  },
  {
    "objectID": "11.html#연습문제",
    "href": "11.html#연습문제",
    "title": "11  포인트 패턴 분석",
    "section": "\n11.6 연습문제",
    "text": "11.6 연습문제\n\nspatstat 패키지에서 plot(longleaf)로 생성되는 플롯과 동일한 결과를 ggplot2 패키지의 geom_sf() 함수 및 sf::plot() 함수를 사용하여 구현하시오.\n12장에서 사용된 NO\\(_2\\) 데이터의 표본 위치를 적절한 관측 윈도우와 함께 ppp 객체로 변환하시오.\nNO\\(_2\\) 데이터셋을 사용하여 밀도를 계산하고, 밀도면을 플로팅하시오. 이어서 밀도면을 stars 객체로 변환하고, 표면 하부 체적을 계산하시오.\n\n\n\n\n그림 11.1: 관찰 윈도우(회색)에 따라 동일한 포인트 패턴이 공간적으로 완전히 무작위로 나타날 수도 있고(왼쪽), 군집을 이루고 있는 것으로 나타날 수도 있다(오른쪽).\n그림 11.2: 두 포인트 패턴의 3 × 3 방격 빈도\n그림 11.3: 두 포인트 패턴에 대한 커널 밀도면\n그림 11.4: ppm 모형에 기반한 예측 밀도면\n그림 11.5: mu =3, scale = 0.05로 설정한 Thomas 프로세스\n그림 11.6: 구면에서 해양부에만 제한된 표본 포인트: 무작위 패턴(왼쪽)과 규칙 패턴(오른쪽)이 정사 도법 지도에 표시되어 있다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>포인트 패턴 분석</span>"
    ]
  },
  {
    "objectID": "12.html",
    "href": "12.html",
    "title": "12  공간적 내삽",
    "section": "",
    "text": "12.1 첫 번째 데이터셋\ngstat 패키지에 포함된 평균 NO₂ 데이터셋을 불러온다. 이 데이터셋은 13장에서 준비된 것이다.\nlibrary(tidyverse) |&gt; suppressPackageStartupMessages()\nno2 &lt;- read_csv(system.file(\"external/no2.csv\", \n    package = \"gstat\"), show_col_types = FALSE)\n이 데이터셋에 UTM 투영을 적용한 뒤, 이를 sf 객체로 변환한다.\nlibrary(sf)\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\ncrs &lt;- st_crs(\"EPSG:32632\")\nst_as_sf(no2, crs = \"OGC:CRS84\", coords = \n    c(\"station_longitude_deg\", \"station_latitude_deg\")) |&gt;\n    st_transform(crs) -&gt; no2.sf\n그다음, 국가 행정 경계를 불러오고, ggplot2 패키지를 사용해 지도를 작성한다(그림 12.1).\nread_sf(\"data/de_nuts1.gpkg\") |&gt; st_transform(crs) -&gt; de\n이 데이터를 바탕으로 공간적 내삽을 수행하려면, 먼저 예측을 수행할 위치를 결정해야 한다. 일반적으로는 연구 대상 지역 전체를 덮는 규칙 그리드를 사용한다. 객체 de의 국가 윤곽에 맞추어, 독일 전역을 커버하는 10 km × 10 km의 규칙적 그리드를 생성한다. 그리드 셀의 크기를 너무 세밀하게 설정하지 않은 것은, 플롯에서 결과를 눈으로 확인하기 위함이다.\nlibrary(stars) |&gt; suppressPackageStartupMessages()\nst_bbox(de) |&gt;\n  st_as_stars(dx = 10000) |&gt;\n  st_crop(de) -&gt; grd\ngrd\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#         Min. 1st Qu. Median Mean 3rd Qu. Max. NA's\n# values     0       0      0    0       0    0 2076\n# dimension(s):\n#   from to  offset  delta            refsys x/y\n# x    1 65  280741  10000 WGS 84 / UTM z... [x]\n# y    1 87 6101239 -10000 WGS 84 / UTM z... [y]\n가장 단순한 공간적 내삽 기법 중 하나는 역거리 가중법(IDW, inverse distance weighted)이다. 이 방법은 예측 지점으로부터의 거리에 반비례하는 가중치를 부여하여, 이를 기반으로 가중평균을 계산한다.\n\\[\n\\hat{z}(s_0)=\\frac{\\sum^n_{i=1} w_iz(s_i)}{\\sum^n_{i=1}w_i}\n\\]\n여기서 가중치는 \\(w_i=|s_0-s_i|^{-p}\\)로 주어지며, 지수(\\(p\\))는 일반적으로 2를 사용하지만 교차검증을 통해 최적값을 찾을 수도 있다. gstat 패키지의 idw() 함수를 사용하면 역거리 가중 내삽을 쉽게 수행할 수 있다.\nlibrary(gstat)\ni &lt;- idw(NO2~1, no2.sf, grd)\n# [inverse distance weighted interpolation]\n그 결과는 그림 12.2에 나타나 있다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "12.html#첫-번째-데이터셋",
    "href": "12.html#첫-번째-데이터셋",
    "title": "12  공간적 내삽",
    "section": "",
    "text": "그림 12.1: 독일의 농촌 지역 관측소들에 높은 평균 NO\\(_2\\) 값이 집중해 있다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n그림 12.2: 독일 NO\\(_2\\) 집중도에 대한 역거리가중 내삽의 결과",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "12.html#표본-베리오그램",
    "href": "12.html#표본-베리오그램",
    "title": "12  공간적 내삽",
    "section": "\n12.2 표본 베리오그램",
    "text": "12.2 표본 베리오그램\n지구통계학적 방법으로 공간 예측을 수행하려면 먼저 평균과 공간적 자기상관을 설명할 수 있는 모형을 설정해야 한다. 가장 단순한 모형은 \\(Z(s)=m+e(s)\\)로, 여기서 \\(m\\)은 알려지지 않은 상수 평균값이며, 공간적 자기상관은 \\(\\gamma (h)=0.5E(Z(s)-Z(s+h))^2\\) 형태의 베리오그램(variogram)으로 표현된다. 유한한 분산 \\(C(0)\\)를 가지는 경우에는 \\(\\gamma (h)=C(0)-C(h)\\)가 성립하며, 이를 통해 베리오그램이 코베리오그램(covariogram) 또는 공분산 함수와 밀접하게 연결되어 있음을 알 수 있다.\n표본 베리오그램은 거리 구간 \\(h_i=[h_{i,0},h_{i,1}]\\)별 \\(\\gamma(h)\\)의 추정값을 계산하여 얻는다.\n\\[\n\\hat{\\gamma}(h_i)=\\frac{1}{2N(h_i)}\\sum^{N(h_i)}_{j=1}(z(s_i)-z(s_i+h'))^2,\\quad h_{i,0}\\le h' \\lt h_{i,1}\n\\tag{12.1}\\]\n여기에서 \\(N(h_i)\\)는 거리 구간 \\(h_i\\)에 속하는 모든 표본 쌍의 개수를 의미한다.(역자주: 즉, 표본 쌍 간의 거리가 해당 구간 내에 포함되는 경우의 개수를 의미한다.) gstat 패키지의 variogram() 함수를 사용하면 이러한 표본 베리오그램을 계산할 수 있다.\n\nv &lt;- variogram(NO2~1, no2.sf)\n\n그림 12.3은 계산된 베리오그램 결과를 플롯으로 나타낸 것이다.\n\n\n\n\n\n그림 12.3: 표본 베리오그램 플롯\n\n\nvariogram() 함수는 기본적으로 최대 거리(cutoff)를 바운딩 박스의 대각선 길이의 1/3로, 구간 너비(width)를 cutoff를 15로 나눈 값으로 설정한다. 이러한 기본값은 다음과 같이 변경할 수 있다.\n\nv0 &lt;- variogram(NO2~1, no2.sf, cutoff = 100000, width = 10000)\n\n변경된 설정값을 적용한 결과는 그림 12.4에 나타나 있다.\n\n\n\n\n\n그림 12.4: 변경된 설정값을 적용하여 생성한 표본 베리오그램\n\n\n공식 NO₂~1은 데이터 파일(NO₂)에서 관심 변수를 선택하고 평균 모형을 지정하는 데 사용된다. 여기서 ~1은 절편만 포함된(알려지지 않은 상수 평균을 가정하는) 모형을 의미한다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "12.html#베리오그램-모형-적합",
    "href": "12.html#베리오그램-모형-적합",
    "title": "12  공간적 내삽",
    "section": "\n12.3 베리오그램 모형 적합",
    "text": "12.3 베리오그램 모형 적합\n공간 예측을 수행하려면, 앞에서 도출한 거리 구간별 추정값이 아니라 이론적으로 모든 거리 \\(h\\)에 적용할 수 있는 베리오그램 모형 \\(\\gamma(h)\\)이 필요하다. 구간별 추정값을 단순히 직선으로 연결하거나 각 구간에서 일정한 값이라고 가정하면 문제가 발생한다. 이는 비양수 정의 공분산 행렬(non-positive definite covariance matrices)을 전제하게 되며, 이러한 행렬을 기반으로 한 통계 모형은 예측에 사용할 수 없다(역자주: 표본 베리오그램의 구간별 평균값(위의 그림 12.3과 12.4의 포인트들)을 단순히 직선으로 연결하거나 각 구간에서 일정한 값으로 고정하면, 이를 바탕으로 계산된 공분산 행렬이 양의 정부호(positive definite) 조건이라는 수학적 제약을 만족하지 못할 수 있다.)\n이 문제를 피하기 위해, 파라메트릭 형태의 \\(\\gamma (h)\\)를 적합하여 추정값 \\(\\hat{\\gamma} (h_i)\\)를 구한다. 여기서 \\(h_i\\)는 \\(\\hat{\\gamma} (h_i)\\)를 추정하는 데 사용된 모든 \\(h'\\) 값의 평균값으로 설정된다. 예를 들어, 다음과 같은 지수형 베리오그램 모형을 적합할 수 있다.\n\nv.m &lt;- fit.variogram(v, vgm(1, \"Exp\", 50000, 1))\n\n결과는 그림 12.5에 제시되어 있다.\n\n\n\n\n\n그림 12.5: 표본 베리오그램(가운데가 비어 있는 점) 위에, 가중 최소제곱법(실선) 및 최대우도추정법(점선)으로 적합한 모형이 함께 표시되어 있다.\n\n\n선의 적합에는 다음 식을 최소화하는 가중 최소제곱법이 적용되었다.\n\\[\n\\sum^n_{i=1}w_i(\\gamma (h_i)-\\hat{\\gamma}(h_i))^2\n\\tag{12.2}\\]\n여기에서 가중치 \\(w_i\\)의 기본값은 \\(N(h_i)/h^2\\)로 주어지며, fit.method 인수를 통해 다른 가중치 옵션을 선택할 수 있다.\n가중 최소제곱법 적합의 대안으로 최대우도 또는 제한 최대우도 모수추정법(Kitanidis and Lane 1985)을 사용할 수 있다. 이 사례에서는 그림 12.5에서 점선으로 나타난 것처럼, 비교적 유사한 적합 모형이 도출되었다. 최대우도추정법의 장점은 식 12.1에서 거리 구간 \\(h_i\\)나 식 12.2에서 가중치 \\(w_i\\)를 선택할 필요가 없다는 것이다. 반면, 단점은 데이터가 다변량 정규 분포를 따른다는 강한 가정을 전제로 하며, 대규모 데이터셋의 경우 관측 수에 해당하는 크기의 선형 시스템을 반복적으로 풀어야 한다는 점이다. Heaton 등(2018)은 대규모 데이터셋에 모형을 적합하는 데 특화된 접근법을 비교한다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "12.html#크리깅-내삽",
    "href": "12.html#크리깅-내삽",
    "title": "12  공간적 내삽",
    "section": "\n12.4 크리깅 내삽",
    "text": "12.4 크리깅 내삽\n일반적으로 내삽은 연구 대상 지역을 덮는 규칙 그리드 지점들을 대상으로 수행된다. 먼저, 해당 지역을 포함하되 외부 영역은 NA로 채워진 래스터(stars 객체)를 생성한다.\n크리깅은 연구 대상 지역 내 임의 지점 \\(Z(s_0)\\)의 속성값을 예측하는 방법이다. gstat 패키지의 krige() 함수를 사용하면 NO₂ 값을 크리깅할 수 있으며, 이때 경향 모형(아래 참조), 데이터, 예측 그리드, 베리오그램 모형을 인수로 함께 전달한다(그림 12.6).\n\nk &lt;- krige(NO2~1, no2.sf, grd, v.m)\n# [using ordinary kriging]\n\n\nggplot() + geom_stars(data = k, aes(fill = var1.pred, x = x, y = y)) + \n    xlab(NULL) + ylab(NULL) +\n    geom_sf(data = st_cast(de, \"MULTILINESTRING\")) + \n    geom_sf(data = no2.sf) +\n    coord_sf(lims_method = \"geometry_bbox\")\n\n\n\n\n\n\n그림 12.6: 독일의 NO\\(_2\\) 농도 크리깅의 결과",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "12.html#에어리어-평균-블록-크리깅",
    "href": "12.html#에어리어-평균-블록-크리깅",
    "title": "12  공간적 내삽",
    "section": "\n12.5 에어리어 평균: 블록 크리깅",
    "text": "12.5 에어리어 평균: 블록 크리깅\n에어리어 평균을 계산하는 방법에는 여러 가지가 있다. 그중 가장 간단한 방법은 대상 폴리곤 내부에 포함된 포인트 표본들의 값을 평균하는것이다.\n\na &lt;- aggregate(no2.sf[\"NO2\"], by = de, FUN = mean)\n\n더 복잡한 방법으로는 블록 크리깅(block kriging, Journel and Huijbregts 1978)이 있으며, 이는 타깃 에어리어의 평균값을 추정하기 위해 모든 데이터를 활용한다. krige() 함수의 newdata 인수에 타깃 에어리어(폴리곤)을 전달하면 된다.\n\nb &lt;- krige(NO2~1, no2.sf, de, v.m)\n# [using ordinary kriging]\n\n두 지도를 하나의 객체로 병합해 단일 플롯으로 표현한다(그림 12.7).\n\nb$sample &lt;- a$NO2\nb$kriging &lt;- b$var1.pred\n\n\nb |&gt; select(sample, kriging) |&gt; \n        pivot_longer(1:2, names_to = \"var\", values_to = \"NO2\") -&gt; b2\nb2$var &lt;- factor(b2$var, levels = c(\"sample\", \"kriging\"))\nggplot() + geom_sf(data = b2, mapping = aes(fill = NO2)) + facet_wrap(~var) +\n     scale_fill_gradientn(colors = sf.colors(20))\n\n\n\n\n\n\n그림 12.7: 단순 평균 계산법(왼쪽)과 블록 크리깅(오른쪽)을 통해 계산한 NO\\(_2\\) 농도 집계값\n\n\n패턴은 유사하지만, 단순 평균을 통한 표본 평균이 블록 크리깅 결과보다 변동성이 더 크다. 이는 크리깅에서 집계 영역 외부의 데이터 포인트에도 가중치를 부여함으로써 발생하는 평활화 효과 때문일 수 있다.\n표준오차의 대략적인 추정치는 \\(\\sqrt{(\\sigma^2 /n)}\\)으로 계산할 수 있다.\n\nSE &lt;- function(x) sqrt(var(x)/length(x))\na &lt;- aggregate(no2.sf[\"NO2\"], de, SE)\n\n표본이 공간적으로 무작위 표본 추출을 통해 얻어진 경우, 디자인 기반 추론(10.4절)에서 실제 추정치는 위와 같았을 것이다. 블록 크리깅 분산은 모형 기반 추정치이며, 크리깅의 부산물로 계산된다. 그림 12.8에서 두 값을 비교하면, 단순 평균 접근법이 블록 크리깅에 비해 구역 평균의 예측 오차에서 변동성이 더 클 뿐 아니라, 그 값 자체도 더 크다는 것을 확인할 수 있다.\n\n\n\n\n\n그림 12.8: 단순 평균 계산법(왼쪽)과 블록 크리깅(오른쪽)을 통해 산출한 평균 NO\\(_2\\) 농도의 표준 오차",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "12.html#조건부-시뮬레이션",
    "href": "12.html#조건부-시뮬레이션",
    "title": "12  공간적 내삽",
    "section": "\n12.6 조건부 시뮬레이션",
    "text": "12.6 조건부 시뮬레이션\n필드 \\(Z(s)\\)의 조건부 평균이 아니라, 하나 또는 여러 개의 조건부 실현이 필요한 경우, 조건부 시뮬레이션을 활용한다.(역자주: ‘조건부 실현’이란, 이미 관측된 자료를 조건으로 하여 공간 필드 \\(Z(s)\\)의 가능한 한 가지 구체적인 분포 패턴을 생성한 결과를 의미한다. 반면 ’조건부 시뮬레이션’은 이러한 조건부 실현을 여러 번 생성하는 과정을 말한다. 조건부 평균이 하나의 ’가장 그럴듯한’ 값만 제공하는 데 비해, 조건부 시뮬레이션은 불확실성을 반영한 다양한 가능성을 탐색할 수 있다는 장점이 있다. 이를 통해 단순 평균값 예측만으로는 얻기 어려운 확률적 특성이나 극단값 발생 가능성 등을 평가할 수 있다.) 이러한 조건부 실현이 필요한 상황은, 비선형 함수 \\(g(\\cdot)\\)을 통해 \\(Z(s)\\)의 구역 평균 값 \\(g(Z(s))\\)를 추정해야 하는 경우에 해당된다. 간단한 예로는 \\(Z(s)\\)가 특정 임계값을 초과하는 지역이 존재하는지를 평가하는 경우를 들 수 있다.\ngstat 패키지의 기본 접근법은 이를 위해 순차(sequential) 시뮬레이션 알고리즘을 사용한다. 이 알고리즘은 예측 대상 위치들을 무작위로 순회하며, 각 위치에서 다음 단계를 수행한다.\n\n해당 위치에서 크리깅 예측을 수행한다.\n크리깅 분산과 동일한 평균과 분산을 갖는 정규 분포로부터 난수를 생성한다.\n이 값을 조건부 데이터셋에 추가한다.\n새로운 무작위 시뮬레이션 위치를 찾는다.\n\n위 과정을 모든 위치에 대해 반복한다.\ngstat 패키지의 krige() 함수가 이를 수행하며, nsim 인수를 양수로 설정하면 조건부 시뮬레이션이 실행된다. set.seed()를 설정한 것은 시뮬레이션 결과가 실행될 때마다 달라지지 않도록, 즉 재현 가능성을 확보하기 위함이다.\n\nset.seed(13341)\n(s &lt;- krige(NO2~1, no2.sf, grd, v.m, nmax = 30, nsim = 6))\n# drawing 6 GLS realisations of beta...\n# [using conditional Gaussian simulation]\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#       Min. 1st Qu. Median Mean 3rd Qu. Max.  NA's\n# var1  -5.7    6.12   8.68 8.88    11.5 23.9 12456\n# dimension(s):\n#        from to  offset  delta            refsys        values x/y\n# x         1 65  280741  10000 WGS 84 / UTM z...          NULL [x]\n# y         1 87 6101239 -10000 WGS 84 / UTM z...          NULL [y]\n# sample    1  6      NA     NA                NA sim1,...,sim6\n\n크리깅 추정 시 포함할 최근접 이웃의 최대 개수는 nmax 인수를 통해 제한할 수 있다. 이는 단계가 진행됨에 따라 조건부 데이터셋이 계속 증가하면서 계산 시간이 길어지고 메모리 사용량이 커지기 문제를 방지하기 위함이다. 조건부 시뮬레이션 결과가 그림 12.9에 나타나 있다.\n\n\n\n\n\n그림 12.9: NO\\(_2\\) 농도에 대한 여섯 가지 조건부 시뮬레이션 결과\n\n\ngstat 패키지에는 최근 조건부 시뮬레이션의 대안 기법이 추가되었으며, 원형 임베딩(circular embedding) 기법을 구현한 함수 krigeSimCE()(Davies and Bryant, 2013)와 터닝 밴드(turning band) 기법을 구현한 함수 krigeSTSimTB()(Schlather, 2011)가 있다. 이러한 기법들은 대규모 데이터셋이나 시공간 데이터셋의 조건부 시뮬레이션에 특히 유용하다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "12.html#경향-모형",
    "href": "12.html#경향-모형",
    "title": "12  공간적 내삽",
    "section": "\n12.7 경향 모형",
    "text": "12.7 경향 모형\n이 장에서 사용된 크리깅과 조건부 시뮬레이션은 모든 공간 변동성이 공간 공분산 모형으로 특징지어지는 무작위 과정이라고 가정한다. 그러나 타깃 변수와 의미 있게 상관된 다른 변수가 있는 경우, 이러한 변수를 경향 모형(trend model)을 위한 선형 회귀 모형에 포함될 수 있다.(여기서 ’경향 모형’은 공간데이터의 평균 구조를 설명하는 회귀 기반 모형을 의미한다. 즉, 타깃 변수와 상관된 하나 이상의 보조 변수를 설명변수로 포함하여 기대값을 추정하고, 잔차에 대해 공간적 자기상관 구조를 모형화한다. 이는 공간적 내삽 기법인 경향면 분석(trend surface analysis)과는 다른 개념이다.)\n\\[\nZ(s)=\\sum^p_{j=0} \\beta_jX_j(s)+e(s)\n\\]\n여기서 \\(X_0(s)=1\\), \\(\\beta_0\\)는 절편, \\(\\beta_j\\)는 각 변수에 대한 회귀계수이다. 변수를 추가하면 일반적으로 잔차 \\(e(s)\\)의 공간적 자기상관과 분산이 모두 감소하여, 더 정확한 예측과 유사한 조건부 시뮬레이션 결과를 얻을 수 있다. NO\\(_2\\)의 변동에 대한 설명변수로 인구 밀도 변수를 사용하는 예를 살펴본다.\n\n12.7.1 인구 밀도 그리드\n대기 중 NO\\(_2\\)의 예측변수로 인구 밀도를 사용한다. NO\\(_2\\)는 주로 교통에서 발생하며, 교통량은 인구 밀도가 높은 지역에서 더 집중된다. 인구 밀도 데이터는 2011년 인구 조사에서 얻어진 것으로, 100 m × 100 m 그리드 셀당 거주자 수가 CSV 파일에 포함되어 있다. 이 데이터를 타깃 그리드 셀에 맞춰 합산하여 새로운 집계 데이터를 생성할 수 있다.\n\nv &lt;- vroom::vroom(\"aq/pop/Zensus_Bevoelkerung_100m-Gitter.csv\")\nv |&gt; filter(Einwohner &gt; 0) |&gt; \n    select(-Gitter_ID_100m) |&gt;\n    st_as_sf(coords = c(\"x_mp_100m\", \"y_mp_100m\"), crs = 3035) |&gt;\n    st_transform(st_crs(grd)) -&gt; b\na &lt;- aggregate(b, st_as_sf(grd, na.rm = FALSE), sum)\n\n위의 코드를 통해 집계된 타깃 그리드 셀의 인구수가 a에 저장된다. 인구 밀도를 계산하려면 각 셀의 면적이 필요한데, 국경과 겹치는 셀의 경우 면적이 10 km × 10 km보다 작을 수 있다.\n\ngrd$ID &lt;- 1:prod(dim(grd)) # to identify grid cells\nii &lt;- st_intersects(grd[\"ID\"],\n  st_cast(st_union(de), \"MULTILINESTRING\"), as_points = FALSE)\ngrd_sf &lt;- st_as_sf(grd[\"ID\"], na.rm = FALSE)[lengths(ii) &gt; 0,]\nst_agr(grd_sf) = \"identity\"\niii &lt;- st_intersection(grd_sf, st_union(de))\ngrd$area &lt;- st_area(grd)[[1]] + \n    units::set_units(grd$values, m^2)\ngrd$area[iii$ID] &lt;- st_area(iii)\n\n위의 두 단계 과정(먼저 국경에 걸친 셀을 찾은 뒤 면적을 계산하는 과정)을 거치지 않고, 모든 셀에 바로 st_intersection() 함수를 적용하는 방법도 있다. 그러나 이 방법은 연산 시간이 오래 걸린다는 단점이 있다. 인구수와 면적을 이용해 인구 밀도를 계산하고(그림 12.10), 총계가 맞는지 확인해 본다.\n\ngrd$pop_dens &lt;- a$Einwohner / grd$area\nsum(grd$pop_dens * grd$area, na.rm = TRUE) # verify\n# 80323301 [1]\nsum(b$Einwohner)\n# [1] 80324282\n\n두 값이 상당히 잘 일치하는 것을 확인할 수 있다. st_interpolate_aw() 함수를 사용했다면, 완전히 동일한 결과를 얻었을 것이다. 인구수를 인구 밀도로 변환하려면 해당 인구수를 100 m × 100 m 그리드 셀의 면적으로 나누어야 한다.\n\n\n\n\n\n그림 12.10: 100 m × 100 m 그리드 셀별 인구 밀도\n\n\n대기질 관측소가 위치한 지점의 인구 밀도 값을 추출하기 위해 st_extract() 함수를 사용한다.\n\ngrd |&gt;\n  select(\"pop_dens\") |&gt;\n  st_extract(no2.sf) |&gt;\n  pull(\"pop_dens\") |&gt; \n  mutate(no2.sf, pop_dens = _) -&gt; no2.sf\n\n그런 다음, 관측소 위치에서 NO\\(_2\\)와 인구 밀도 사이의 선형 관계를 살펴볼 수 있다.\n\nsummary(lm(NO2~sqrt(pop_dens), no2.sf))\n# \n# Call:\n# lm(formula = NO2 ~ sqrt(pop_dens), data = no2.sf)\n# \n# Residuals:\n#    Min     1Q Median     3Q    Max \n# -7.990 -2.052 -0.505  1.610  8.095 \n# \n# Coefficients:\n#                Estimate Std. Error t value Pr(&gt;|t|)    \n# (Intercept)       4.537      0.685    6.62  5.5e-09 ***\n# sqrt(pop_dens)  326.154     49.366    6.61  5.8e-09 ***\n# ---\n# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n# \n# Residual standard error: 3.13 on 72 degrees of freedom\n# Multiple R-squared:  0.377,   Adjusted R-squared:  0.369 \n# F-statistic: 43.7 on 1 and 72 DF,  p-value: 5.82e-09\n\n두 변수 간의 선형 관계는 그림 12.11의 산점도에서 확인할 수 있다.\n\n\n\n\n\n그림 12.11: 2017년 농촌 지역 대기질 관측소의 연평균 NO\\(_2\\) 농도와 인구 밀도의 산점도\n\n\n이 새로운 모형을 사용해 예측을 수행하려면, 먼저 잔차 베리오그램을 모형화해야 한다(그림 12.12).\n\nno2.sf &lt;- no2.sf[!is.na(no2.sf$pop_dens),]\nvr &lt;- variogram(NO2~sqrt(pop_dens), no2.sf)\nvr.m &lt;- fit.variogram(vr, vgm(1, \"Exp\", 50000, 1))\n\n\n\n\n\n\n그림 12.12: 인구 밀도 경향을 제거한 후 잔차에 대해 계산한 베리오그램\n\n\n그리고 나서 아래의 코드를 사용해 크리깅 예측을 수행한다. 이 때 중요한 점은, 예측 대상 위치에 대해서도 pop_dens 값이 계산되어 새로 생성되는 객체 grd에 포함된다는 것이다. 예측 결과는 그림 12.13에 나타나 있다.\n\nkr &lt;- krige(NO2 ~ sqrt(pop_dens), no2.sf, \n            grd[\"pop_dens\"], vr.m)\n# [using universal kriging]\n\n\n\n\n\n\n그림 12.13: 인구 밀도를 경향 변수로 활용한 크리깅 기반 NO\\(_2\\) 농도 예측값\n\n\n(오디너리) 크리깅과 비교하면 몇 가지 뚜렷한 차이가 나타난다. 인구 밀도를 경향 변수로 사용한 크리깅 결과 지도는 측정소의 극단적인 값보다는 인구 밀도의 극단적인 값을 따르는 경향을 보이며, 값의 범위도 오디너리 크리깅보다 넓다. 그러나 사용된 측정소가 모두 ‘농촌 배경’ 범주에 속해 전반적으로 인구 밀도가 낮다는 점에서, 결과 해석에는 주의가 필요하다. 그림 12.11의 산점도에서 x축을 보면, 측정소의 인구 밀도 값이 인구 밀도 지도에 나타난 값의 범위보다 훨씬 좁다는 사실을 알 수 있다. 따라서 오른쪽 지도는 그림 12.11의 관계를 강하게 반영하여 내삽한 결과라 할 수 있다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "12.html#연습문제",
    "href": "12.html#연습문제",
    "title": "12  공간적 내삽",
    "section": "\n12.8 연습문제",
    "text": "12.8 연습문제\n\n그림 12.13과 동일한 플롯을 생성하되, 왼쪽 패널에 그림 12.2의 역거리 가중 내삽 지도를 추가하시오.\n역거리 가중 내삽 결과와 크리깅 결과 간 산점도를 작성하고, 역거리 가중 내삽 결과와 잔차 크리깅 결과 간 산점도를 작성하시오.\n그리드 셀을 중심으로 하는 블록 평균을 예측하기 위해 krige() 함수의 block 인수를 사용하여 블록 크기 10 km(그리드 셀 크기), 50 km, 200 km로 설정한 블록 크리깅을 수행하시오. 세 가지 블록 크기에 대한 추정치 결과 지도를 포인트 크리깅 결과 지도와 비교하고, 각 경우에 해당하는 크리깅 표준 오차 지도도 동일하게 비교하시오.\n위에서 얻은 잔차 크리깅 결과를 기반으로, 크리깅 오차가 정규 분포를 따른다고 가정하여 95% 신뢰구간의 하한선과 상한선에 해당하는 지도를 산출하고, 이를 단일(공통) 범례를 사용하여 플로팅하시오.\n크리깅 오차가 정규 분포를 따른다고 가정할 때, NO\\(_2\\)의 포인트 값이 15 ppm을 초과할 확률을 계산하여 이를 지도로 표현하시오.\n\n\n\n\n그림 12.1: 독일의 농촌 지역 관측소들에 높은 평균 NO\\(_2\\) 값이 집중해 있다.\n그림 12.2: 독일 NO\\(_2\\) 집중도에 대한 역거리가중 내삽의 결과\n그림 12.3: 표본 베리오그램 플롯\n그림 12.4: 변경된 설정값을 적용하여 생성한 표본 베리오그램\n그림 12.5: 표본 베리오그램(가운데가 비어 있는 점) 위에, 가중 최소제곱법(실선) 및 최대우도추정법(점선)으로 적합한 모형이 함께 표시되어 있다.\n그림 12.6: 독일의 NO\\(_2\\) 농도 크리깅의 결과\n그림 12.7: 단순 평균 계산법(왼쪽)과 블록 크리깅(오른쪽)을 통해 계산한 NO\\(_2\\) 농도 집계값\n그림 12.8: 단순 평균 계산법(왼쪽)과 블록 크리깅(오른쪽)을 통해 산출한 평균 NO\\(_2\\) 농도의 표준 오차\n그림 12.9: NO\\(_2\\) 농도에 대한 여섯 가지 조건부 시뮬레이션 결과\n그림 12.10: 100 m × 100 m 그리드 셀별 인구 밀도\n그림 12.11: 2017년 농촌 지역 대기질 관측소의 연평균 NO\\(_2\\) 농도와 인구 밀도의 산점도\n그림 12.12: 인구 밀도 경향을 제거한 후 잔차에 대해 계산한 베리오그램\n그림 12.13: 인구 밀도를 경향 변수로 활용한 크리깅 기반 NO\\(_2\\) 농도 예측값",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>공간적 내삽</span>"
    ]
  },
  {
    "objectID": "14.html",
    "href": "14.html",
    "title": "14  근접성과 에어리어 데이터",
    "section": "",
    "text": "14.1 근접성의 재현: spdep 패키지의 경우\n공간적 자기상관을 그래프상의 이웃 관계를 통해 다루는 접근에서는, 해당 그래프가 주어진 것이며 연구자가 이를 선택한 것으로 간주한다. 이는 지구통계학적 접근과는 다른데, 지구통계학에서는 연구자는 경험적 베리오그램에서 거리를 어떻게 구간화할지, 어떤 함수를 적용할지, 그리고 베리오그램 적합을 어떻게 수행할지를 모두 선택한다. 두 접근법 모두 사전 선택을 포함하지만, 기저 상관성을 재현하는 방식에서는 서로 다르다(Wall 2004). 또한, 그래프 기반 이웃 규정 방식을 보다 넓은 맥락에서 설명하는 시도도 있다(Bavaud, 1998).\n이웃 관계 객체를 생성할 때, 이웃이 없는 구역 단위의 존재는 문제를 야기할 수 있다(Bivand and Portnov 2004). 섬이나 강으로 분리된 구역 단위가 이러한 무이웃 구역 단위에 해당하며, 이는 구역 단위에 에어리어 스포트가 적용되고 공유 경계와 같은 위상 관계가 사용되는 경우에 발생한다. 예를 들어, mgcv::gam과 같은 모형 적합 함수에서 mrf(마르코프 랜덤 필드) 항을 사용할 때, 방향은 필요하지 않지만 그래프가 분리된 하위 그래프들로 구성되는 있으면 에러가 발생한다.\n이러한 무이웃 문제는 포인트 간 거리를 기준으로 이웃을 규정하는 경우에도 발생할 수 있다. 예를 들어, 거리 임계값이 최근린 이웃 거리보다 작은 경우가 이에 해당한다. 공유 경계 기반의 연접성 규정은 좌표계의 종류(투영 좌표계이든 비투영 경위도 좌표이든)에 영향을 받지 않지만, 모든 포인트 기반 접근법은 결국 거리를 사용하므로, 적용하는 투영법의 선택이 결과에 영향을 미칠 수 있다.\nspdep 패키지는 이웃을 규정하는 nb 클래스를 제공한다. nb 클래스는 관측 개체 수를 길이로 하는 리스트이며, 각 구성 요소는 정수 벡터로 이루어진다. 이웃이 없는 경우는 0L이 단일 요소로 포함된 정수 벡터로 인코딩된다. 이웃이 있는 경우는 1L:n 범위 내의 값이 포함된 정수 벡터로 인코딩되며, 해당 값들은 이웃으로 정의된 관측 개체의 인덱스 값이다. 이러한 구조는 소위 ‘행 기반 희소 표현(row-oriented sparse representation)’ 방식이다.(역자주: ’행 기반 희소 표현’은 희소 행렬(전체 원소 중 대부분이 0인 행렬)을 행 단위로 저장하면서, 각 행에서 0이 아닌 원소의 위치와 값을 함께 기록하는 방식이다. 공간가중치행렬처럼 대부분의 원소가 0인 행렬을 메모리 효율적으로 저장하고, 관측 단위별 이웃 정보와 가중치를 빠르게 조회할 수 있다.) spdep 패키지는 nb 객체를 생성하는 다양한 방법을 제공하며, 이 표현과 생성 함수는 다른 패키지에서도 널리 사용된다.\nspdep 패키지는 nb 클래스(무방향 혹은 유방향 그래프)를 기반으로 listw 객체를 구성한다. listw 객체는 세 가지 구성 요소를 갖는 리스트로, nb 객체, 가중치 리스트, 그리고 가중치 계산 방식을 나타내는 단일 요소 문자 벡터가 포함된다. 사회과학 연구에서 가장 흔히 사용되는 방식은 ’행표준화가중치(row-standardized weights)’를 계산하는 것이며, 이 때 개별 관측 개체의 한 이웃 가중치는 해당 관측 개체의 이웃 수(즉, 카디널리티)의 역수, 즉, 1/card(nb)[i])로 변환된다.\n이 장에서는 2015년 폴란드 대통령 선거 데이터를 사용한다. 연구 지역은 총 2,495개의 지방자치단체와 바르샤바 구역으로 구성되어 있다(그림 14.1 참조). 이 지도는 tmap 패키지(8.5절)를 활용해 작성되었으며, 지방자치단체 유형이 표시되어 있다. 구역 단위는 sf 패키지의 sf 객체이며, 투표소 단위의 결과를 구역 단위로 집계한 데이터이다.\nlibrary(sf)\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\ndata(pol_pres15, package = \"spDataLarge\")\npol_pres15 |&gt;\n    subset(select = c(TERYT, name, types)) |&gt;\n    head()\n# Simple feature collection with 6 features and 3 fields\n# Geometry type: MULTIPOLYGON\n# Dimension:     XY\n# Bounding box:  xmin: 235000 ymin: 367000 xmax: 281000 ymax: 413000\n# Projected CRS: ETRS89 / Poland CS92\n#    TERYT                name       types\n# 1 020101         BOLESŁAWIEC       Urban\n# 2 020102         BOLESŁAWIEC       Rural\n# 3 020103            GROMADKA       Rural\n# 4 020104        NOWOGRODZIEC Urban/rural\n# 5 020105          OSIECZNICA       Rural\n# 6 020106 WARTA BOLESŁAWIECKA       Rural\n#                         geometry\n# 1 MULTIPOLYGON (((261089 3855...\n# 2 MULTIPOLYGON (((254150 3837...\n# 3 MULTIPOLYGON (((275346 3846...\n# 4 MULTIPOLYGON (((251770 3770...\n# 5 MULTIPOLYGON (((263424 4060...\n# 6 MULTIPOLYGON (((267031 3870...\nlibrary(tmap, warn.conflicts = FALSE)\n# Breaking News: tmap 3.x is retiring. Please test v4, e.g. with\n# remotes::install_github('r-tmap/tmap')\ntm_shape(pol_pres15) + tm_fill(\"types\")\nsf 객체의 위상 구조가 밸리드한지 확인한다.\nif (!all(st_is_valid(pol_pres15)))\n        pol_pres15 &lt;- st_make_valid(pol_pres15)\n2002년 초부터 2019년 4월까지 spdep 패키지에는 이웃 및 공간가중치 객체를 생성하고 처리하는 함수, 공간적 자기상관을 검정하는 함수, 그리고 모형 적합과 관련된 함수 등이 포함되어 있었다. 이 중 모형 적합과 관련 함수는 spatialreg 패키지로 분리되었으며, 이에 대해서는 이후 장에서 다룰 예정이다. 현재 spdep 패키지(Bivand 2022)는 sf 클래스와 sp 클래스 객체 모두를 지원한다.\nlibrary(spdep) |&gt; suppressPackageStartupMessages()",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>근접성과 에어리어 데이터</span>"
    ]
  },
  {
    "objectID": "14.html#근접성의-재현-spdep-패키지의-경우",
    "href": "14.html#근접성의-재현-spdep-패키지의-경우",
    "title": "14  근접성과 에어리어 데이터",
    "section": "",
    "text": "그림 14.1: 2015년 폴란드 구역 단위 유형",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>근접성과 에어리어 데이터</span>"
    ]
  },
  {
    "objectID": "14.html#연접성에-기반한-이웃의-규정",
    "href": "14.html#연접성에-기반한-이웃의-규정",
    "title": "14  근접성과 에어리어 데이터",
    "section": "\n14.2 연접성에 기반한 이웃의 규정",
    "text": "14.2 연접성에 기반한 이웃의 규정\nspdep 패키지의 poly2nb() 함수는 pl 인수를 통해 입력된 객체에서 폴리곤 경계를 구성하는 경계 포인트들을 이용한다. 입력 객체는 일반적으로 POLYGON 또는 MULTIPOLYGON 지오메트리를 가진 sf 또는 sfc 객체이다. 각 관측 개체에 대해, 최소 하나의 포인트(기본값인 퀸 방식, queen = TRUE) 또는 최소 두 개의 포인트(루크 방식, queen = FALSE)가 snap 거리 내에 다른 폴리곤의 경계 포인트에 위치하는 지를 확인한다. 거리 계산은 투영법에 관계없이 원 길이 단위에 기반한 평면 거리로 수행된다. 필요한 수의 충분히 가까운 점을 찾으면 검색이 중단된다.\n\nargs(poly2nb)\n\n#  function (pl, row.names = NULL, snap = sqrt(.Machine$double.eps),\n#    queen = TRUE, useC = TRUE, foundInBox = NULL)\nspdep 패키지 1.1-7부터 poly2nb() 함수는 후보 이웃을 찾고 foundInBox를 내부적으로 채우기 위해 sf 패키지의 GEOS 인터페이스를 사용한다. 이 경우, sf 패키지를 통한 GEOS의 공간 인덱싱(STRtree 쿼리 사용)이 기본값으로 설정된다.\n\npol_pres15 |&gt; poly2nb(queen = TRUE) -&gt; nb_q\n\nprint 메서드는 이웃 객체의 요약 구조를 출력한다.\n\nnb_q\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14242 \n# Percentage nonzero weights: 0.229 \n# Average number of links: 5.71\n\nsf 패키지 버전 1.0-0부터는 구체 지오메트리에 대해 기본적으로 s2 패키지(Dunnington, Pebesma, and Rubak 2023)가 사용된다. 이는 poly2nb() 함수에서 사용하는 st_intersects() 함수가 계산을 s2::s2_intersects_matrix() 함수로 전달하기 때문이다(4장 참조). spdep 패키지 버전 1.1-9부터는 sf_use_s2()가 TRUE일 경우 구체 인터섹션을 사용하여 후보 이웃을 찾는다. GEOS와 마찬가지로 s2 라이브러리도 빠른 공간 인덱싱을 사용한다.\n\nold_use_s2 &lt;- sf_use_s2()\n\n\nsf_use_s2(TRUE)\n\n\n(pol_pres15 |&gt; st_transform(\"OGC:CRS84\") -&gt; pol_pres15_ll) |&gt; \n    poly2nb(queen = TRUE) -&gt; nb_q_s2\n\n이 예시에서는 구면 인터섹션과 평면 인터섹션이 동일한 인접 이웃을 생성한다. 두 경우 모두 입력 지오메트리가 밸리드해야 한다.\n\nall.equal(nb_q, nb_q_s2, check.attributes=FALSE)\n# [1] TRUE\n\nnb 객체는 대칭적인 이웃 관계인 i에서 j, j에서 i를 모두 기록한다. 이는 nb 객체가 비대칭적인 관계도 허용하기 때문이다. 그러나 객체 생성 단계에서 이러한 중복은 큰 의미가 없다.\n대부분의 spdep 패키지 함수는 이웃 객체를 생성할 때 row.names 인수를 사용하며, 이 값은 region.id 속성으로 저장된다. row.names 인수가 지정되지 않으면, 첫 번째 인수의 row.names에서 값을 가져온다. region.id 속성은 nb 객체가 원 데이터와 동일한 순서로 정리되어 있는지를 확인하는 데 사용된다. nb 객체의 일부만 추출할 경우, 인덱스는 1:length(subsetted_nb) 범위 내 값으로 재설정되지만, region.id 속성을 통해 원본 객체와의 정확한 연결 정보를 확인할 수 있다. 이는 17.4절에서 간략히 논의할 공간적 회귀 모형의 표본 외 예측에서 사용된다.\n또는 n.comp.nb() 함수를 사용해 이 무방향 그래프의 연결성을 확인할 수도 있다. 일부 모형 추정 기법은 비연결 그래프를 지원하지 않지만, 비연결 그래프가 초래할 문제를 인지하는 것은 중요하다(Freni-Sterrantino, Ventrucci, and Rue 2018).\n\n(nb_q |&gt; n.comp.nb())$nc\n# [1] 1\n\n이 접근법은 이웃 객체를 그래프로 취급한 뒤, 해당 그래프에 대해 그래프 분석을 수행하는 것과 동일하다(Csardi and Nepusz 2006; Nepusz 2022). 먼저 이웃 객체를 이진 희소 행렬로 변환한 후, 그래프 분석을 수행한다(Bates, Maechler, and Jagan 2022).\n\nlibrary(Matrix, warn.conflicts = FALSE)\nlibrary(spatialreg, warn.conflicts = FALSE)\nnb_q |&gt; \n    nb2listw(style = \"B\") |&gt; \n    as(\"CsparseMatrix\") -&gt; smat\nlibrary(igraph, warn.conflicts = FALSE)\n(smat |&gt; graph.adjacency() -&gt; g1) |&gt; \n    count_components()\n# [1] 1\n\n다른 소프트웨어와의 호환성을 위해 이웃 객체를 GAL 형식으로 내보내거나 가져올 수 있다. 이를 위해 write.nb.gal()함수와 read.gal() 함수를 사용한다.\n\ntf &lt;- tempfile(fileext = \".gal\")\nwrite.nb.gal(nb_q, tf)",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>근접성과 에어리어 데이터</span>"
    ]
  },
  {
    "objectID": "14.html#그래프에-기반한-이웃의-규정",
    "href": "14.html#그래프에-기반한-이웃의-규정",
    "title": "14  근접성과 에어리어 데이터",
    "section": "\n14.3 그래프에 기반한 이웃의 규정",
    "text": "14.3 그래프에 기반한 이웃의 규정\n구역 단위가 적합한 재현이지만 평면상의 포인트로 관찰된 경우, 연접성은 그래프 기반 이웃을 사용해 근사할 수 있다. 이때 평면은 폴리곤 테셀레이션으로 분할되며, 각 폴리곤 내 모든 지점은 해당 포인트를 가장 가까운 포인트로 갖는다. 가장 간단한 형태는 삼각망(triangulation)을 사용하는 것이며, 여기서는 deldir 패키지의 deldir() 함수를 사용한다.(역자주: 주어진 포인트를 이용해 들로네 삼각망을 형성하고, 그것을 바탕으로 티센 폴리곤을 생성한 후 연접성에 기반하여 포인트 간 이웃 관계를 규정한다.) 이 함수는 \\(i\\)와 \\(j\\) 식별자를 반환하므로, 세로(긴) 형식으로 listw 객체를 구성하기가 용이하다. 이는 과거 S-Plus SpatialStats 모듈에서 사용된 방식이며, nb 객체(가로 형식)를 생성하기 위해 내부적으로 sn2listw() 함수에서 사용되는 방식이기도 하다. 한편 GEOS와 같은 다른 대안은 이웃을 식별하기 위한 충분한 정보를 반환하지 못한다.\n이러한 함수들이 반환한 결과는 graph2nb() 함수를 통해 nb 객체로 변환된다. 이때 sym 인수를 사용해 이웃 관계의 대칭성을 지정할 수 있다. 그래프 기반 방식을 적용하기 위해 폴리곤의 센트로이드(다중 폴리곤의 경우 가장 큰 폴리곤의 센트로이드)를 포인트 재현으로 활용한다. 물론 인구 가중 센트로이드를 구할 수 있다면 더 바람직하다.\n\npol_pres15 |&gt; \n    st_geometry() |&gt; \n    st_centroid(of_largest_polygon = TRUE) -&gt; coords \n(coords |&gt; tri2nb() -&gt; nb_tri)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14930 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 5.98\n\n평균 이웃 수의 측면에서 보면 퀸 방식의 경계 연접성과 유사한 결과가 나타났다. 그러나 nbdists() 함수를 사용해 엣지 길이의 분포를 살펴보면, 상위 4분위수는 약 15 km이지만 최대값은 거의 300 km에 달한다. 이는 전체 지역을 포괄하는 컨벡스헐(convex hull)의 한쪽 변 길이에 버금가는 수준이다.(역자주: 컨벡스헐은 평면 또는 다차원 공간에 분포한 점 집합을 완전히 포함하는 가장 작은 볼록 다각형(또는 볼록 다면체)을 말한다. 쉽게 말해, 모든 점을 고무줄로 감싼 뒤 고무줄이 팽팽하게 당겨져 형성된 경계선이 컨벡스헐에 해당한다. 공간분석에서는 관측 지점의 외곽 경계를 정의하거나, 데이터 범위를 시각화하고 공간적 패턴을 파악하는 데 자주 활용된다. 컨벡스헐은 볼록다각형(convex polygon)의 성질을 가지므로, 내부의 임의의 두 점을 연결한 선분은 항상 헐 내부에 존재한다.) 최소 거리 역시 중요한데, 많은 도시 구역의 센트로이드가 주변 농촌 구역의 센트로이드와 매우 근접해 있기 때문이다.\n\nnb_tri |&gt; \n    nbdists(coords) |&gt; \n    unlist() |&gt; \n    summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    9847   12151   13485   14994  296974\n\n삼각망에 의거한 이웃 규정도 연결 그래프를 생성한다.(역자주: 여기서 ’연결 그래프’란 그래프상의 모든 지점이 직ㆍ간접적으로 연결되어 있는 그래프를 말한다.)\n\n(nb_tri |&gt; n.comp.nb())$nc\n# [1] 1\n\n그래프 기반 접근법에는 soi.graph(), relativeneigh(), gabrielneigh() 등의 메서드가 있으며, 여기서는 soi.graph() 함수만 살펴본다.\nsoi.graph() 함수에서 SOI는 영향권(sphere of influence)의 약자이다. 이 함수는 삼각망 이웃에서 비정상적으로 긴 엣지로 표현된 이웃 관계를 제거하여, 실질적인 의미를 갖는 이웃 관계만 남긴다. 이러한 비정상적으로 긴 엣지는 컨벡스헐의 가장자리에서 흔히 나타난다(Avis and Horton, 1985).\n\n(nb_tri |&gt; \n        soi.graph(coords) |&gt; \n        graph2nb() -&gt; nb_soi)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 12792 \n# Percentage nonzero weights: 0.205 \n# Average number of links: 5.13\n\n그러나 삼각망 기반 이웃 관계의 일부를 해체하면, 연결 그래프로서의 전체 특성은 사라지게 된다.\n\n(nb_soi |&gt; n.comp.nb() -&gt; n_comp)$nc\n# [1] 16\n\n이 알고리즘은 비정상적으로 긴 엣지를 제거하도록 설계되었지만, 농촌 구역이 하나의 도시 구역을 완전히 둘러싸고 있는 경우, 매우 가까운 도시-농촌 쌍의 엣지도 잘못 삭제될 수 있다. 이로 인해 15개의 도시-농촌 쌍이 메인 그래프로부터 분리되는 결과가 발생하였다.\n\ntable(n_comp$comp.id)\n# \n#    1    2    3    4    5    6    7    8    9   10   11   12   13 \n# 2465    2    2    2    2    2    2    2    2    2    2    2    2 \n#   14   15   16 \n#    2    2    2\n\n컨벡스헐에서 가장 긴 엣지들이 제거되었지만, 연결되지 않은 이웃 쌍이 발생하면서 ’구멍’이 형성되었다. nb_tri와 nb_soi의 차이는 그림 14.2에서 주황색으로 표시되어 있다.\n\n\n\n\n\n그림 14.2: 삼각망 이웃(오렌지색과 검은색)과 영향권 이웃(검은색)의 비교. 곳곳에 형성된 구멍은 모두 도시 구역이 농촌 구역으로 완전히 둘러싸여 있는 경우에 해당한다(그림 14.1 참조).",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>근접성과 에어리어 데이터</span>"
    ]
  },
  {
    "objectID": "14.html#거리에-기반한-이웃의-규정",
    "href": "14.html#거리에-기반한-이웃의-규정",
    "title": "14  근접성과 에어리어 데이터",
    "section": "\n14.4 거리에 기반한 이웃의 규정",
    "text": "14.4 거리에 기반한 이웃의 규정\n거리 기반 이웃은 dnearneigh() 함수를 사용해 생성할 수 있다. bounds 인수를 통해 거리 구간을 설정할 수 있으며, d1과 d2는 각각 거리의 하한값과 상한값이다. 경위도 좌표계를 사용하고 좌표 객체 x가 주어지며 longlat = TRUE로 설정된 경우, WGS84 기준 타원체를 가정해 킬로미터 단위의 대권 거리를 계산한다. use_s2 = TRUE(기본값)로 설정하면 구체를 가정한 거리 계산을 수행한다(4장 참조). dwithin이 FALSE이고 s2 패키지 버전이 1.0.7보다 크면 s2_closest_edges() 함수가 사용되며, dwithin이 TRUE이고 use_s2 = TRUE이면 s2_dwithin_matrix() 함수가 사용된다. 두 방법 모두 빠른 구형 공간 인덱싱을 사용하지만, s2_closest_edges() 함수의 경우 최소 및 최대 경계를 지정하므로 dnearneigh() 함수의 R 코드에서 한 번의 실행만으로 충분하다.\ndbscan 패키지(Hahsler and Piekenbrock 2022)에 새로운 인수가 추가되어, 2차원 또는 3차원에서 평면 공간 인덱싱을 사용해 이웃을 찾는 기능이 보강되었으며, 대칭성을 확인하는 절차가 필요 없어졌다. 또한, 구면 기하학적 거리 측정을 위한 세 가지 인수도 추가되었다.\n\\(k\\)-최근린 이웃을 위한 knearneigh() 함수는 knn 객체를 반환하며, 이를 knn2nb() 함수를 사용해 nb 객체로 변환된다. 이 함수는 구면 거리 계산도 지원하는데, 이는 평면 거리와는 다른 최근린 이웃을 산출할 수 있기 때문이다. k 값은 작은 숫자로 설정하는 것이 일반적이다. 투영 좌표계에서는 dbscan 패키지를 사용해 최근린 이웃을 더 효율적으로 계산할 수 있다. 이렇게 생성된 nb 객체는 대개 대칭적이지 않으므로, knn2nb() 함수는 대칭성을 강제할 수 있는 sym 인수를 제공한다. 대칭성을 강제하면 모든 단위가 최소 k개의 이웃을 갖게 되지만, 모든 단위가 정확히 k개의 이웃을 갖는 것은 아니다. sf_use_s2() 함수가 TRUE인 경우, 입력 객체가 sf 또는 sfc 클래스일 때 knearneigh() 함수는 빠른 구형 공간 인덱싱을 사용한다.\nnbdists() 함수는 투영 좌표를 사용할 경우 좌표 단위로, 그렇지 않으면 킬로미터 단위로 이웃 관계 엣지의 길이를 반환한다. 거리 밴드의 상한을 설정하려면 먼저 첫 번째 최근린 이웃 거리의 최대값을 찾아야 하며, 이때 반환된 객체의 리스트 구조를 제거하기 위해 unlist() 함수를 사용할 수 있다. sf_use_s2() 함수가 TRUE이면, 입력 객체가 sf 또는 sfc 클래스일 때 nbdists() 함수는 빠른 구형 거리 계산을 사용한다.\n\ncoords |&gt; \n    knearneigh(k = 1) |&gt; \n    knn2nb() |&gt; \n    nbdists(coords) |&gt; \n    unlist() |&gt; \n    summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    6663    8538    8275   10124   17979\n\n여기서 첫 번째 최근린 이웃 거리의 최대값은 약 18 km이며, 이를 거리 상한으로 설정하면 모든 단위가 최소 하나 이상의 이웃을 갖게 된다.\n\ncoords |&gt; dnearneigh(0, 18000) -&gt; nb_d18\n\n이 사례에서 보듯, 관측 개체의 수가 많지 않으면 공간 인덱싱을 사용하더라도 실행 시간에서 큰 이점을 얻지 어렵다.\n\ncoords |&gt; dnearneigh(0, 18000, use_kd_tree = FALSE) -&gt; nb_d18a\n\n그리고 산출되는 객체 역시 동일하다.\n\nall.equal(nb_d18, nb_d18a, check.attributes = FALSE)\n# [1] TRUE\n\n\nnb_d18\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 20358 \n# Percentage nonzero weights: 0.327 \n# Average number of links: 8.16\n\n이웃이 없는 관측값은 없지만(이는 nb 객체의 print 메소드에서 확인할 수 있음), 그래프는 완전 연결 상태가 아니다. 한 쌍의 관측 개체가 서로의 유일한 이웃인 경우가 있기 때문이다.\n\n(nb_d18 |&gt; n.comp.nb() -&gt; n_comp)$nc\n# [1] 2\n\n\ntable(n_comp$comp.id)\n# \n#    1    2 \n# 2493    2\n\n임계값에 300m를 추가하면, 비이웃 관측 단위가 없는 이웃 객체가 생성되며 모든 관측 단위가 그래프를 통해 서로 도달 가능해진다.\n\n(coords |&gt; dnearneigh(0, 18300) -&gt; nb_d183)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21086 \n# Percentage nonzero weights: 0.339 \n# Average number of links: 8.45\n\n\n(nb_d183 |&gt; n.comp.nb())$nc\n# [1] 1\n\n거리 기반 이웃의 특징 중 하나는, 면적이 작은 단위가 밀집된 지역일수록 이웃 수가 많아진다는 점이다. 예를 들어, 바르샤바 구역은 평균 면적이 훨씬 작지만 이 거리 기준으로 약 30개의 이웃을 가진다. 이웃 수가 많아지면, 개별 이웃의 영향이 더 많은 이웃에게 분산되어 관계가 완화된다.(역자주: 여기서 ’관계가 완화된다’는 것은 공간 가중 행렬에서 특정 관측 단위의 영향이 소수의 이웃에 집중되는 대신, 더 많은 이웃에 분산되어 각 이웃이 받는 영향이 상대적으로 약해지는 것을 의미한다.)\n나중에 사용하기 위해, 16 km의 임계값을 사용하여 비이웃 단위가 포함된 이웃 객체도 생성한다.\n\n(coords |&gt; dnearneigh(0, 16000) -&gt; nb_d16)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 15850 \n# Percentage nonzero weights: 0.255 \n# Average number of links: 6.35 \n# 7 regions with no links:\n# 569 1371 1522 2374 2385 2473 2474\n\n\\(k\\)-최근린 이웃을 사용하면 이웃의 수를 직접적으로 제어할 수 있으며, 비대칭 이웃을 허용하는 것도 가능하다.\n\n((coords |&gt; knearneigh(k = 6) -&gt; knn_k6) |&gt; knn2nb() -&gt; nb_k6)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14970 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 6 \n# Non-symmetric neighbours list\n\n또는 대칭성을 부여할 수도 있다.\n\n(knn_k6 |&gt; knn2nb(sym = TRUE) -&gt; nb_k6s)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 16810 \n# Percentage nonzero weights: 0.27 \n# Average number of links: 6.74\n\n여기서 k 값은 완전 연결성을 보장할 만큼 크지만, 그래프가 반드시 평면성을 가지는 것은 아니다. 이는 엣지가 노드가 아닌 지점에서 교차하기 때문이며, 이러한 현상은 연접성 기반 이웃이나 그래프 기반 이웃에서는 발생하지 않는다.(역자주: 여기서 ’평면성을 가지지 않는다’는 것은, 네트워크를 2차원 평면 위에 배치했을 때 엣지가 서로 교차하는 경우가 발생함을 의미한다. 평면 그래프에서는 엣지가 반드시 노드에서만 교차해야 하지만, \\(k\\)-최근린 이웃 그래프는 거리 기준으로 연결되기 때문에 노드가 아닌 위치에서 엣지가 교차하는 비평면 구조가 나타날 수 있다.)\n\n(nb_k6s |&gt; n.comp.nb())$nc\n# [1] 1\n\n구체 상의 포인트인 경우(4장 참조), st_centroid() 함수의 출력이 달라질 수 있으므로, 포인트를 직접 역투영하기 보다는 역투영된 폴리곤 지오메트리에서 경위도 좌표를 추출한다.\n\nold_use_s2 &lt;- sf_use_s2()\n\n\nsf_use_s2(TRUE)\n\n\npol_pres15_ll |&gt; \n    st_geometry() |&gt; \n    st_centroid(of_largest_polygon = TRUE) -&gt; coords_ll\n\n구면 좌표의 경우, 이웃 판정을 위한 거리 구간의 경계값은 킬로미터 단위로 지정된다.\n\n(coords_ll |&gt; dnearneigh(0, 18.3, use_s2 = TRUE, \n                         dwithin = TRUE) -&gt; nb_d183_ll)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21140 \n# Percentage nonzero weights: 0.34 \n# Average number of links: 8.47\n\n이 이웃들은 예상한 바와 같이 구면 거리 18.3 km 기준의 이웃들과는 다르다.\n\nisTRUE(all.equal(nb_d183, nb_d183_ll, check.attributes = FALSE))\n# [1] FALSE\n\ns2 패키지가 더 빠른 거리 기반 이웃 인덱싱을 제공하는 경우, 경위도 좌표에서는 기본적으로 s2_closest_edges() 함수가 사용된다.\n\n(coords_ll |&gt; dnearneigh(0, 18.3) -&gt; nb_d183_llce)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21140 \n# Percentage nonzero weights: 0.34 \n# Average number of links: 8.47\n\n이 경우, 두 s2 기반 이웃 객체는 동일하다.\n\nisTRUE(all.equal(nb_d183_llce, nb_d183_ll,\n                 check.attributes = FALSE))\n# [1] TRUE\n\ns2 패키지를 사용해 빠른 구형 공간 인덱싱으로 \\(k\\)-최근린 이웃을 찾는다.\n\n(coords_ll |&gt; knearneigh(k = 6) |&gt; knn2nb() -&gt; nb_k6_ll)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14970 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 6 \n# Non-symmetric neighbours list\n\n이 이웃들은 예상대로 평면 기준 k = 6 최근린 이웃과는 다르며, 전통적인 브루트포스(brute-force) 방식의 타원체 거리 계산 결과와도 약간 차이가 날 것이다.(역자주: 브루트포스 방식의 타원체 거리 계산은 지구를 타원체로 가정했을 때 두 지점 간 거리를 구하는 공식을 최적화 없이 모든 점 쌍에 대해 직접 적용하는 전수검사식 방법이다. 계산량이 많아 속도가 느리지만, 알고리즘이 단순하고 결과가 정확하다는 장점이 있다.)\n\nisTRUE(all.equal(nb_k6, nb_k6_ll, check.attributes = FALSE))\n# [1] FALSE\n\nnbdists() 함수도 sf 또는 sfc 클래스의 투입 객체가 경위도 좌표값을 가질 경우, s2 패키지를 사용해 구면 거리를 계산하며, 반환 거리는 킬로미터 단위로 표시된다.\n\nnb_q |&gt; nbdists(coords_ll) |&gt; unlist() |&gt; summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     0.2     9.8    12.2    12.6    15.1    33.0\n\n동일한 가중치 객체라도 평면 좌표를 사용할 경우와 구형 또는 타원체 지오메트리를 사용할 경우에는 계산된 거리 값이 약간 다르다(평면 지오메트리의 경우 거리는 투영 좌표계의 단위(보통 미터)로 반환되며, 타원체와 구형 지오메트리의 경우 거리는 킬로미터 단위로 반환된다).\n\nnb_q |&gt; nbdists(coords) |&gt; unlist() |&gt; summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    9822   12173   12651   15117   33102\n\n\nsf_use_s2(old_use_s2)",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>근접성과 에어리어 데이터</span>"
    ]
  },
  {
    "objectID": "14.html#가중치-지정",
    "href": "14.html#가중치-지정",
    "title": "14  근접성과 에어리어 데이터",
    "section": "\n14.5 가중치 지정",
    "text": "14.5 가중치 지정\n이웃 객체를 기반으로 가중치 객체를 지정한다. 이 과정에서 몇 가지 선택을 해야 한다. nb2listw() 함수는 nb 객체를 바탕으로 listw 가중치 객체를 생성한다. 가중치 객체는 가중치 벡터 리스트와 가중치 스타일을 나타내는 선택값으로 구성된다. 이 때 중요한 사안 중 하나는 비이웃 관측 개체의 처리 방식이며, 이를 zero.policy 인수가 제어한다. 기본값은 FALSE로, 비이웃 관측 개체가 조재하면 오류를 발생시킨다. 이는 관측 개체가 이웃을 갖지 않으면 공간래그값(spatially lagged values)을 계산할 수 없기 때문이다.(역자주: ‘spatially lagged values’는 국내에서 ‘공간지연값’, ‘공간시차값’, ‘공간지체값’, ‘공간래그값’ 등 다양한 번역어가 사용된다. 본 역서에서는 ’공간래그값’을 표준 표기로 사용한다. 그 이유는 ’lag’가 시계열 분석에서 시간적 지연을 뜻하는 용어이지만, 공간통계에서의 시간과 무관하게 주변 공간 단위의 값을 공간가중치행렬을 이용해 가중 평균한 값을 의미한다. 따라서 ’지연’이나 ’지체’처럼 시간적 어감이 강한 번역어는 공간적 개념을 설명하는 데 부적절하므로, 학계에서 널리 쓰이는 음역어 ’래그’를 채택하였다.) 일반적으로 비이웃 관측 개체에 대해 공간래그값을 0으로 부여하는데, 이는 제로 값의 가중치 벡터와 데이터 벡터의 교차곱과 동일하기 때문에 zero.policy라는 이름이 붙여졌다.\n\nargs(nb2listw)\n\n#  function (neighbours, glist = NULL, style = \"W\", zero.policy =\n#    NULL)\n스타일 선택을 변경했을 때의 결과를 보여주기 위해, 아래에서 도우미 함수 spweights.constants를 사용한다. 이 함수는 listw 객체에 대한 여러 상수 값을 반환한다. 여기서 \\(n\\)은 관측 개체의 수이며, n1부터 n3은 \\(n-1,...,\\) nn은 \\(n^2\\)을 의미한다. \\(S_0\\), \\(S_1\\), \\(S_2\\)는 상수로, \\(S_0\\)는 가중치의 합을 나타낸다. 이러한 상수들에 대한 자세한 논의는 Bivand와 Wong(2018)를 참고하면 된다.\n\nargs(spweights.constants)\n\n#  function (listw, zero.policy = NULL, adjust.n = TRUE)\n\"B\" 바이너리 스타일은 각 이웃 관계에 단위 값(1)을 부여한다. 이 방식은 이웃을 규정하는 경계가 존재하는 가장자리 구역 단위에 비해, 더 많은 이웃을 가질 수 있는 내부 구역 단위에 상대적으로 더 높은 가중치를 부여하게 된다.\n\n(nb_q |&gt; \n    nb2listw(style = \"B\") -&gt; lw_q_B) |&gt; \n    spweights.constants() |&gt; \n    data.frame() |&gt; \n    subset(select = c(n, S0, S1, S2))\n#      n    S0    S1     S2\n# 1 2495 14242 28484 357280\n\n\"W\" 행 표준화 스타일은 연구 지역의 가장자리에 위치하여 필연적으로 더 적은 수의 이웃을 가질 수 밖에 없는 구역 단위에 더 높은 가중치를 부여한다. 이 방식은 먼저 각 이웃 관계에 단위 값을 가중치로 부여한 뒤, 이를 해당 구역 단의의 가중치 합으로 나누어 표준화한다. 비이웃 구역 단위의 경우 0을 0으로 나누게 되어 ‘부정(not-a-number)’ 값이 발생하지만, zero.policy를 TRUE로 설정하면 문제가 없다. 행 표준화 스타일에서는 \\(S_0\\)는 \\(n\\)과 같아진다.\n\n(nb_q |&gt; \n        nb2listw(style = \"W\") -&gt; lw_q_W) |&gt; \n    spweights.constants() |&gt; \n    data.frame() |&gt; \n    subset(select = c(n, S0, S1, S2))\n#      n   S0  S1    S2\n# 1 2495 2495 958 10406\n\n역거리 가중치는 여러 과학 분야에서 사용된다. 일부에서는 밀집된 역거리 행렬을 사용하지만, 이 경우 많은 역거리 값이 거의 0에 가까워 실제적으로 기여하는 바가 적으며, 특히 공간 프로세스 행렬 자체가 밀집된 경우 그 영향은 더욱 제한적이다. 역거리 가중치는 보통 다음과 같은 절차로 구성된다. 먼저 엣지 길이를 계산하고, 대부분의 가중치 값이 지나치게 크거나 작지 않도록 단위를 변환하며(예: 미터를 킬로미터로 변환), 이를 역수로 변환한 뒤, nb2listw() 함수의 glist 인수로 전달한다.(역자주: “밀집된 역거리 행렬에서 많은 값이 0에 가깝다”는 것은, 거리의 역수를 취했을 때 멀리 떨어진 단위들 간의 가중치가 극도로 작아져, 공간분석에서 거의 영향력을 행사하지 못한다는 의미이다. 특히 공간 프로세스 행렬 자체가 이미 대부분의 단위들 간 연결을 포함하고 있다면, 이러한 미소 가중치는 분석 결과에 실질적인 변화를 주지 않는다.)\n\nnb_d183 |&gt; \n    nbdists(coords) |&gt; \n    lapply(function(x) 1/(x/1000)) -&gt; gwts\n(nb_d183 |&gt; nb2listw(glist=gwts, style=\"B\") -&gt; lw_d183_idw_B) |&gt; \n    spweights.constants() |&gt; \n    data.frame() |&gt; \n    subset(select=c(n, S0, S1, S2))\n#      n   S0  S1   S2\n# 1 2495 1841 534 7265\n\n비이웃 단위의 경우, 기본 설정은 가중치 객체의 생성을 막아 두어, 이후 절차를 어떻게 진행할지에 대해 분석가가 입장을 정하도록 한다.\n\ntry(nb_d16 |&gt; nb2listw(style=\"B\") -&gt; lw_d16_B)\n# Error in nb2listw(nb_d16, style = \"B\") : Empty neighbour sets found\n\nnb와 listw 객체와 관련된 많은 함수에서 zero.policy 인수를 사용할 수 있다.\n\nnb_d16 |&gt; \n    nb2listw(style=\"B\", zero.policy=TRUE) |&gt; \n    spweights.constants(zero.policy=TRUE) |&gt; \n    data.frame() |&gt; \n    subset(select=c(n, S0, S1, S2))\n#      n    S0    S1     S2\n# 1 2488 15850 31700 506480\n\nspweights.constants() 함수의 adjust.n 인수는 기본적으로 TRUE로 설정되어 있어, 비이웃 관측 개체 수를 제외하므로 \\(n\\) 값이 작아지고 통계적 추론에 영향을 줄 수 있다. 원래의 \\(n\\) 값은 인수를 다르게 지정하면 확인할 수 있다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>근접성과 에어리어 데이터</span>"
    ]
  },
  {
    "objectID": "14.html#고차-이웃의-정의",
    "href": "14.html#고차-이웃의-정의",
    "title": "14  근접성과 에어리어 데이터",
    "section": "\n14.6 고차 이웃의 정의",
    "text": "14.6 고차 이웃의 정의\n앞서 살펴본 퀸 인접성 기반 이웃 객체의 특성은 다음과 같다.\n\nnb_q\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14242 \n# Percentage nonzero weights: 0.229 \n# Average number of links: 5.71\n\n\\(i\\)가 \\(j\\)의 이웃이고, \\(j\\)가 \\(k\\)의 이웃인 경우, 즉 이웃 그래프에서 두 단계를 거쳐 \\(i\\)에서 \\(k\\)로 이어지는 이웃 관계를 나타내는 객체를 만들고자 한다면, nblag() 함수를 사용할 수 있다. 이 함수는 자동으로 \\(i\\) 에서 \\(i\\)로 가는 자기 이웃 관계를 제거한다.\n\n(nb_q |&gt; nblag(2) -&gt; nb_q2)[[2]]\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 32930 \n# Percentage nonzero weights: 0.529 \n# Average number of links: 13.2\n\nnblag_cumul() 함수는 지정된 모든 차수의 이웃 목록을 누적하여 반환한다.\n\nnblag_cumul(nb_q2)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 47172 \n# Percentage nonzero weights: 0.758 \n# Average number of links: 18.9\n\nunion.nb() 함수의 집합 연산은 두 개의 객체를 입력받아 처리하며, 이 예시에서는 동일한 결과를 생성한다.\n\nunion.nb(nb_q2[[2]], nb_q2[[1]])\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 47172 \n# Percentage nonzero weights: 0.758 \n# Average number of links: 18.9\n\n앞에서 이웃 객체를 그래프 형태로 변환하였는데, 이렇게 생성된 그래프 객체를 이용하면 그래프 탐색에 필요한 단계 수에 관한 정보를 얻을 수 있다.\n\ndiameter(g1)\n# [1] 52\n\n각 관측 개체에서 그래프를 통해 최단 경로로 도달하는 데 필요한 단계 수를 계산하여 \\(n \\times n\\) 크기의 sps 행렬을 생성한다. 이를 통해 동일한 최대값을 얻을 수 있다.\n\ng1 |&gt; shortest.paths() -&gt; sps\n(sps |&gt; apply(2, max) -&gt; spmax) |&gt; max()\n# [1] 52\n\n최대값을 가진 지방자치단체는 Lutowiska(루토비스카)로, 남동부의 끝에 위치해 있으며 우크라이나와 국경을 접하고 있다.\n\nmr &lt;- which.max(spmax)\npol_pres15$name0[mr]\n# [1] \"Lutowiska\"\n\n그림 14.3은 연접성 기반 이웃이 거리 기반 이웃과 마찬가지로 다른 관측값들과 동일한 유형의 관계를 나타낸다는 점을 보여준다. 일부 접근법에서는 거리 기반 이웃을 선호하는데, 예를 들어 역거리 가중 이웃은 모든 관측값이 서로 어떻게 연결되어 있는지를 명확히 드러내기 때문이다. 그러나 공간적 자기상관 검정이나 공간 회귀 모형 개발 과정에서는 공간 프로세스 모형의 역행렬을 사용하게 된다.(역자주: ’공간 프로세스 모형의 역행렬’이란, 공간적 자기상관이나 공간 회귀 모형을 계산할 때 수행되는 수학적 역연산을 의미한다. 이 연산 과정에는 공간가중치행렬을 반복적으로 곱하고 더하는 절차가 포함되며, 그 결과 모든 관측값이 서로 영향을 주고받는 관계가 모형에 자동으로 반영된다.) 이 역은 계수와 공간가중치행렬의 곱을 거듭제곱하여 더한 급수로 표현될 수 있으며, 이는 본질적으로 모든 관측값이 다른 모든 관측값과 관계를 맺고 있음을 전제로 한다. 희소 연접성 기반 이웃 객체는 이러한 의존성 구조를 명시적으로 기술하지 않더라도 풍부한 종속 관계를 포괄할 수 있다.\n\n\n\n\n\n그림 14.3: Lutowiska까지의 최단 경로 수와 거리의 관계. 왼쪽 지도는 Lutowiska까지의 최단 경로 수를, 오른쪽 그래프는 최단 경로 수와 거리의 관계를 보여준다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>근접성과 에어리어 데이터</span>"
    ]
  },
  {
    "objectID": "14.html#연습문제",
    "href": "14.html#연습문제",
    "title": "14  근접성과 에어리어 데이터",
    "section": "\n14.7 연습문제",
    "text": "14.7 연습문제\n\n어떤 유형의 지오메트리 스포트가 이웃 객체를 생성하는 함수에 적합하지 설명하시오.\n이웃 객체를 생성하는 함수 중, 평면 재현에만 사용할 수 있는 것은 무엇인지 설명하시오.\n체스판에서 queen 연접성 대신 rook 연접성을 선택하면 어떤 차이가 발생하는지 설명하시오.\n이웃 집합의 카디널리티(이웃 수)와 행표준화가중치 사이에는 어떤 관계가 있으며, 이러한 관계가 어떻게 엣지 효과(edge effect) 분석을 가능하게 하는지 설명하시오. 3번 문제에서 만든 체스판을 사용하여 rook 이웃과 queen 이웃 각각에 대해 설명하시오.\n\n\n\n\n그림 14.1: 2015년 폴란드 구역 단위 유형\n그림 14.2: 삼각망 이웃(오렌지색과 검은색)과 영향권 이웃(검은색)의 비교. 곳곳에 형성된 구멍은 모두 도시 구역이 농촌 구역으로 완전히 둘러싸여 있는 경우에 해당한다(그림 14.1 참조).\n그림 14.3: Lutowiska까지의 최단 경로 수와 거리의 관계. 왼쪽 지도는 Lutowiska까지의 최단 경로 수를, 오른쪽 그래프는 최단 경로 수와 거리의 관계를 보여준다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>근접성과 에어리어 데이터</span>"
    ]
  },
  {
    "objectID": "part_3.html",
    "href": "part_3.html",
    "title": "공간통계분석과 공간모형화",
    "section": "",
    "text": "이 책의 제1부와 제2부에서는 ’공간데이터 모형’과 관련된 핵심 개념들을 살펴보았다. 다룬 주제는 다음과 같다.\n\n실제 현상과 수치 표현의 관계(2장)\n좌표가 다양한 공간에서 정의되는 방식(2장과 4장)\n심플 피처 지오메트리와 두 점 사이 직선으로 라인스트링과 폴리곤을 정의하는 방법(3장)\n지오메트리 유형의 집합(3.1절)\n서포트, 피처 속성, 지오메트리의 관계(5장)\n심플 테셀레이션이 시공간 체적(볼륨)을 표현하는 방식(6장)\n이 개념을 데이터사이언스 소프트웨어에 적용하는 방법(7장)\n\n이 책의 제3부는 분량이 가장 많으며, 공간데이터의 통계적 모형화를 다룬다. 과학으로서 통계학은 관측값의 변동성을 기술하고 이해하며, 미래 관측값을 예측하는 데 중점을 둔다. 관측값은 보통 다음과 같이 모델링된다.\n\\[\n\\text{관측값}=\\text{설명된 부분}+\\text{잔여 부분}\n\\]\n여기서 ’잔여 부분’은 측정 오차를 포함해 예측 변수로 설명되지 않는 변동성을 의미할 뿐만 아니라, 낮은 모형 적합도나 모형 오지정(misspecification)에서 비롯된 변동성도 포함한다. 공간데이터의 경우에는 항이 하나 더 추가되어 다음과 같이 쓴다.\n\\[\n\\text{관측값}=\\text{설명된 부분}+\\text{매끄러운 부분}+\\text{잔여 부분}\n\\]\n여기서 ‘매끄러운 부분’은 외부 예측 변수로는 설명되지 않지만 뚜렷한 ’매끄러운’ 공간 패턴을 보이는 성분을 뜻하고, ‘잔차’는 이런 패턴을 보이지 않는 ’거친’ 변동성을 뜻한다. 이 ‘매끄러운’ 항은 좌표상의 기저함수(스플라인, 스무더)로 모형화하거나, 공간적 자기상관을 가진 랜덤 항으로 모델링할 수 있다.\n10장은 공간데이터의 통계적 모형화를 소개하며, 이를 통해 후속 장의 내용을 준비하는 동시에 후속 장에서 자세히 다루지 않는 사항도 함께 다룬다. 또한 이 장은 제1부에서 소개한 개념, 특히 5장에서 논의한 ‘서포트’ 개념과의 연계를 시도한다.\n공간데이터의 통계적 모형화 전반과 세부적인 전산 소프트웨어 활용을 한 권에 모두 담는 것은 애초에 불가능하다. 예를 들어, spatstat 책(Baddeley, Rubak, and Turner, 2015)은 공간 포인트 패턴 데이터와 R만을 다루는데도 분량이 약 850쪽에 이른다. 이 제3부에서는 ‘고전적인’ 공간통계 주제 세 가지, 즉 포인트 패턴 데이터 분석(11장), 지구통계학적 데이터 분석(12장과 13장), 에어리어(래티스) 데이터 분석(14~17장)에 집중한다. 또한, 본문 곳곳에서 통계 방법론과 R 구현과 관련된 참고 사항을 가능한 한 많이 제시할 것이다.",
    "crumbs": [
      "공간통계분석과 공간모형화"
    ]
  }
]