[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "공간데이터사이언스 개론",
    "section": "",
    "text": "서장\n데이터사이언스는 주어진 데이터를 바탕으로 질문에 대한 해답을 찾고, 그 과정을 타인과 효과적으로 소통하는 학문이다. 여기서 소통은 단순히 결과를 제시하는 것을 넘어, 사용된 데이터를 공유하고 해답 도출의 전 과정을 포괄적이며 재현 가능한 방식으로 투명하게 공개하는 것을 포함한다. 또한 데이터사이언스는 주어진 데이터가 질문에 답하기에 충분하지 않을 수 있음을 인정하며, 설령 해답이 도출되었다 하더라도 데이터 수집 또는 표본추출 방식에 따라 그 결과가 달라질 수 있음을 수용한다.\n이 책은 공간데이터의 기본 개념을 소개하고 설명한다. 포인트, 라인, 폴리곤, 래스터, 커버리지, 지오메트리 속성, 데이터 큐브, 참조계와 같은 기초 개념부터, 속성과 지오메트리가 어떻게 연결되고 이러한 연결이 분석에 어떤 영향을 미치는지에 관한 고차원 개념까지를 다룬다. 속성과 지오메트리 간의 관계를 서포트(support)라 하며, 서포트가 달라지면 속성의 특성도 변할 수 있다. 일부 데이터는 공간적 연속성에 기반해 생성되어 모든 지점에서 관찰이 가능하지만, 다른 데이터는 공간적 이산성에 기반해 특정한 구획 체계를 통해서만 관찰된다. 현대 공간데이터분석에서는 이러한 구획 체계 개념이 포인트 데이터, 지구통계학적 데이터, 에어리어 데이터를 포함한 다양한 데이터 유형에 폭넓게 적용된다. 공간적 재현의 중요성을 뒷받침하는 핵심 개념이 바로 서포트이며, 서포트에 대한 이해는 필수적이다. 이 책은 공간데이터를 분석에 활용하고자 하는 데이터 과학자를 주요 독자로 한다. 책 전반에 걸쳐 공간데이터분석의 절차와 방법을 설명하며, 예시에는 프로그래밍 언어 R을 사용한다. 향후에는 Python과 Julia를 활용한 예제도 추가할 예정이다(Bivand 2022a 참조).\n공간데이터에 대해 흔히 갖는 통념이 있다. 공간데이터란 관측 개체의 경위도값을 속성으로 포함한 데이터이며, 이 경위도값을 다른 변수들과 동일하게 취급해도 무방하다는 생각이다. 그러나 이러한 인식은 더 풍부한 연구 결과를 도출할 기회를 놓칠 뿐 아니라, 잘못된 결론에 이를 위험을 높인다. 다음의 세 가지 점을 살펴보자.\n이 책은 공간데이터, 좌표참조계, 공간분석과 관련된 다양한 개념 뿐만 아니라 sf(Pebesma 2018, 2022a), stars(Pebesma 2022b), s2(Dunnington, Pebesma, and Rubak 2023), lwgeom(Pebesma 2023)와 같은 여러 R 패키지를 함께 다룬다. 이와 더불어 공간적 tidyverse(Wickham et al. 2019; Wickham 2022) 확장 패키지와 이들 패키지와 연계하여 사용할 수 있는 공간분석 및 시각화 패키지들인 gstat(Pebesma 2004; Pebesma and Graeler 2022), spdep(Bivand 2022b), spatialreg(Bivand and Piras 2022), spatstat(Baddeley, Rubak, and Turner 2015; Baddeley, Turner, and Rubak 2022), tmap(Tennekes 2018, 2022), mapview(Appelhans et al. 2022)도 함께 소개한다.\n데이터사이언스와 마찬가지로 공간데이터사이언스도 특정 과학 분야의 하위 영역으로서 위로부터 형성된 것이 아니라, 공간데이터 활용과 관련된 다양한 학문 및 산업 분야에서의 상향식 발전을 통해 형성되어 온 분야이다. 학술대회, 심포지엄, 학회, 연구 프로그램 등을 통해 공간데이터사이언스를 정의하려는 시도가 이어지고 있으나, 그 응용 범위가 워낙 광범위하고 다양하기 때문에 결실을 맺기는 쉽지 않다. 이 책에 ’공간데이터사이언스’라는 제목을 붙인 이유는 이 분야의 경계를 명확히 규정하려는 의도에서 비롯된 것이 아니다. 지난 30~40년 동안 우리는 기본 아이디어, 데이터, 소프트웨어 기반의 분석 절차 등 연구의 전 과정을 기꺼이 공유해 온 수많은 연구자들과 함께해 왔으며, 이 책은 그러한 공동 경험을 정리한 결과물이다. 이를 통해 공간데이터사이언스의 발전에 작게나마 기여하고자 하는 것이 우리의 본래 의도이다. 따라서 이 책에서 다루는 주제의 선택은 필연적으로 저자들의 연구 관심과 경험에 일정 부분 편향될 수밖에 없다. 우리가 경험한 오픈 연구 커뮤니티의 형성에는 여러 플랫폼이 중요한 역할을 했다. ai-geostats, r-sig-geo 메일링 리스트, SourceForge, R-Forge, GitHub, 그리고 2006년부터 매년 열리고 있는 OpenGeoHub 여름학교가 그 예이다. 데이터사이언스라는 언어 장벽을 넘어서려는 수많은 노력의 결과, 오늘날 우리는 새로운 가능성과 흥미로운 관점이 열리고 있음을 실감하고 있다. 우리가 이 분야에 기여하고자 하는 이유는, 오픈사이언스가 더 나은 과학을 가능하게 하며, 더 나은 과학이 보다 지속가능한 세상을 만드는 데 기여할 수 있다고 믿기 때문이다.",
    "crumbs": [
      "서장"
    ]
  },
  {
    "objectID": "index.html#감사의-글",
    "href": "index.html#감사의-글",
    "title": "공간데이터사이언스 개론",
    "section": "감사의 글",
    "text": "감사의 글\n우리는 r-spatial 커뮤니티 전체에 깊이 감사드리며, 특히 다음에 열거한 분들께 특별한 감사를 전한다.\n\nr-spatial 패키지를 개발하거나 그 개발에 기여해 주신 분들\n트위터의 #rspatial 해시태그나 GitHub에서 토론에 참여해 주신 분들\n강좌, 여름학교, 학술 컨퍼런스에서 의견을 개진하거나 질문을 통해 토론에 기여해 주신 분들\n\n특히, s2 패키지를 구현한 듀이 더닝턴(Dewey Dunnington)과, 제6장 데이터 큐브의 그림을 준비해 준 사힐 반다리(Sahil Bhandari), 조너선 발만(Jonathan Bahlmann), 그리고 클라우스 빌케(Claus Wilke), 야쿠브 노보사드(Jakub Nowosad)의 적극적인 기여에 깊이 감사드린다. 또한 2021년과 2022년에 진행된 ‘R을 활용한 공간데이터사이언스(Spatial Data Science with R)’ 수업의 참가자들과, 다음의 GitHub 리포지터리에서 이슈, 풀 리퀘스트, 디스커션 등을 통해 적극적으로 참여해 주신 모든 분들께도 진심으로 감사드린다.\n\n이 책의 리포지터리(Nowosad, jonathom, JaFro96, singhkpratham, liuyadong, hurielreichel, PPaccioretti, Robinlovelace, Syverpet, jonas-hurst, angela-li, ALanguillaume, florisvdh, ismailsunni, andronaco)\nsf 리포지터리(aecoleman, agila5, andycraig, angela-li, ateucher, barryrowlingson, bbest, BenGraeler, bhaskarvk, Bisaloo, bkmgit, christophertull, chrisyeh96, cmcaine, cpsievert, daissi, dankelley, DavisVaughan, dbaston, dblodgett-usgs, dcooley, demorenoc, dpprdan, drkrynstrng, etiennebr, famuvie, fdetsch, florisvdh, gregleleu, hadley, hughjonesd, huizezhang-sherry, jeffreyhanson, jeroen, jlacko, joethorley, joheisig, JoshOBrien, jwolfson, kadyb, karldw, kendonB, khondula, KHwong12, krlmlr, lambdamoses, lbusett, lcgodoy, lionel-, loicdtx, marwahaha, MatthieuStigler, mdsumner, MichaelChirico, microly, mpadge, mtennekes, nikolai-b, noerw, Nowosad, oliverbeagley, Pakillo, paleolimbot, pat-s, PPaccioretti, prdm0, ranghetti, rCarto, renejuan, rhijmans, rhurlin, rnuske, Robinlovelace, robitalec, rubak, rundel, statnmap, thomasp85, tim-salabim, tyluRp, uribo, Valexandre, wibeasley, wittja01, yutannihilation, Zedseayou)\nstars 리포지터리(a-benini, ailich, ateucher, btupper, dblodgett-usgs, djnavarro, ErickChacon, ethanwhite, etiennebr, flahn, floriandeboissieu, gavg712, gdkrmr, jannes-m, jeroen, JoshOBrien, kadyb, kendonB, mdsumner, michaeldorman, mtennekes, Nowosad, pat-s, PPaccioretti, przell, qdread, Rekyt, rhijmans, rubak, rushgeo, statnmap, uribo, yutannihilation)\ns2 리포지토리(kylebutts, spiry34, jeroen, eddelbuettel)",
    "crumbs": [
      "서장"
    ]
  },
  {
    "objectID": "01.html",
    "href": "01.html",
    "title": "1  시작하기",
    "section": "",
    "text": "1.1 첫 번째 지도\n공간데이터를 표현하는 가장 전형적인 방법은 지도를 그리는 것이다. 그림 1.1은 그중에서도 단순한 형태의 지도를 예시로 보여준다.\n이 지도에는 다음과 같은 그래픽 요소가 포함되어 있다.\n폴리곤은 공간 지오메트리(geometry)의 한 형태다. 공간 지오메트리(포인트, 라인, 폴리곤, 픽셀)에 대해서는 3장에서 자세히 다룬다. 폴리곤은 여러 포인트가 선분으로 연결되어 형성되며, 포인트의 위치 표현과 측정 방법은 2장에서 설명한다. 그림 1.1에서 볼 수 있듯, 모든 경위선이 직선으로 나타나지는 않는다. 이는 지도에 특정 투영법이 적용되었음을 의미하며, 지도 투영에 대한 내용은 2장과 8.1절에서 다룬다.\n그림 1.1에서 컬러로 표현된 것은 BIR74 변수의 값이다. 각 값은 하나의 지오메트리, 즉 하나의 피처(feature)에 연결되어 있으며, 피처 속성과 지오메트리의 관계는 5장에서 다룬다. BIR74 변수는 출생아 수를 나타내는 지역별 빈도값(count)이다. 여기서 ’지역별’이라는 말은, 이 값이 지역 내 모든 지점과 직접적으로 대응되는 것이 아니라는 뜻이다. 지도의 컬러가 연속적으로 채색되어 있어 모든 지점이 해당 값을 가진다고 오해할 수 있지만, 실제로는 해당 값이 폴리곤 전체와 연결된 일종의 적분값임에 유의해야 한다.\n그림 1.1의 지도를 작성하려면 당연히 데이터가 필요하다. 여기서는 7.1절에서 사용된 파일을 불러와 사용하였다. 세 개 속성 변수에 대해 앞의 세 개 레코드만 요약한 결과는 다음과 같다.\n이 데이터 요약을 통해 다음과 같은 사실을 알 수 있다.\n패싯(facet) 플롯을 활용하면 그림 1.2와 같이 보다 복잡한 형태의 지도를 작성할 수 있다.\n리플릿(leaflet)을 사용하면 그림 1.3과 같은 인터랙티브 지도를 제작할 수 있다.\n그림 1.3: mapview로 그린 상호작용형 지도: 팬과 줌을 이용해 지도 스케일에 변화를 줄 수 있고 카운티를 클릭하면 해당 카운티의 속성을 보여주는 팝업 윈도우가 뜬다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#첫-번째-지도",
    "href": "01.html#첫-번째-지도",
    "title": "1  시작하기",
    "section": "",
    "text": "그림 1.1: 첫 번째 지도: 미국 노스캐롤라이나의 카운티별 출생아수, 1974~1978년\n\n\n\n\n폴리곤: 검은색 외곽선을 가진 폴리곤이며, 내부는 BIR74 변수(지도 제목)의 값에 따라 서로 다른 색상으로 채워져 있다.\n범례: 색상이 나타내는 값을 설명하며, 특정 컬러 팔레트(color palette)가 적용되어 있고 색상 변화 지점에는 컬러 단절값(color break)이 표시되어 있다.\n경위선망(그래티큘): 지도의 배경에 표시된다.\n축 눈금: 경도와 위도 값을 나타낸다.\n\n\n\n\n# Simple feature collection with 100 features and 3 fields\n# Geometry type: MULTIPOLYGON\n# Dimension:     XY\n# Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6\n# Geodetic CRS:  NAD27\n# # A tibble: 100 × 4\n#    AREA BIR74 SID74                                             geom\n#   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;                               &lt;MULTIPOLYGON [°]&gt;\n# 1 0.114  1091     1 (((-81.5 36.2, -81.5 36.3, -81.6 36.3, -81.6 36…\n# 2 0.061   487     0 (((-81.2 36.4, -81.2 36.4, -81.3 36.4, -81.3 36…\n# 3 0.143  3188     5 (((-80.5 36.2, -80.5 36.3, -80.5 36.3, -80.5 36…\n# # ℹ 97 more rows\n\n\n데이터셋은 100개의 피처(레코드)와 3개의 필드(속성)로 구성되어 있다.\n지오메트리 유형은 MULTIPOLYGON이다(3장 참조).\n디멘션은 XY이다. 즉, 개별 포인트는 두 개의 좌표값으로 구성되어 있다.\nCRS(coordinate reference system, 좌표참조계)는 측지 좌표계이며, NAD27 데이텀을 기반으로한 경위도값을 사용한다(2장 참조).\n세 개의 속성 변수 다음에는 MULTIPOLYGON 유형의 geom 변수가 있는데, 이는 폴리곤 정보를 각도(°) 형식으로 저장하고 있다.\n\n\n\n\n\n\n\n그림 1.2: “미국 노스캐롤라이나 카운티별 영아돌연사증후군에 의한 사망아수의 패싯 지도, 1974~1978년과 1979~1984년”",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#좌표참조계crs",
    "href": "01.html#좌표참조계crs",
    "title": "1  시작하기",
    "section": "\n1.2 좌표참조계(CRS)",
    "text": "1.2 좌표참조계(CRS)\n좌표참조계(CRS, coordinate reference system)는 공간데이터의 좌표값이 어떤 기준과 규칙에 따라 정의되는지를 나타낸다. 그림 1.1의 배경에 보이는 회색선은 경위선망, 즉 그래티큘(graticule)이다. 경위선이 \\(x\\), \\(y\\) 축과 직교하는 직선이 아니라는 점은, 이 데이터에 특정한 투영법(projection)이 적용되었음을 보여준다. 반면 그림 1.3에서는 노스캐롤라이나의 북쪽 경계가 곡선이 아닌 직선으로 나타나는데, 이는 또 다른 투영법이 사용되었음을 의미한다.\n그림 1.1에 나타난 경위도 좌표는 특정한 데이텀(datum), 여기서는 NAD27에 기반하고 있다.(역자주: 경위도 좌표는 절대적인 값이 아니라 데이텀에 따라 달라지는 상대적인 값임을 반드시 이해해야 한다. 동일한 지점이라도 데이텀에 따라 서로 다른 경위도 좌표를 가질 수 있으며, 반대로 동일한 좌표값이 데이텀에 따라 지표상의 서로 다른 지점을 가리킬 수도 있다.) 데이텀은 지구를 모형화하기 위해 어떤 지구타원체를 선택하고, 이를 지구와 어떻게 일치시킬 것인가―즉 지구타원체의 원점을 지구상의 어느 지점에, 어떤 방향으로 맞출 것인가―에 대한 일련의 사항을 규정한다. 예를 들어, GPS 수신기(예: 모바일 폰)를 통해 획득한 좌표값은 WGS84(World Geodetic System 1984) 데이텀에 기반한다. 이 좌표값을 NAD27(North American Datum 1927) 기준으로 해석하면, 동일한 좌표값이 실제 위치에서 약 30m 정도 차이이날 수 있다.\n투영법은 하나의 좌표계에서 다른 좌표계로 변환하기 위해, 두 좌표값 간의 대응 관계를 정의하는 함수이다.\n\n타원체 좌표(ellipsoidal coordinates): 지구를 수학적으로 모형화한 지구타원체(또는 지구구체) 상의 3차원 좌표로, 경도와 위도를 사용하여 표현한다.\n투영 좌표(projected coordinates): 지도 상의 2차원 평면 좌표계로, 일반적으로 \\(x\\) 좌표와 \\(y\\) 좌표 또는 동거(easting)와 북거(northing)로 나타낸다.\n\n한 데이텀을 다른 데이텀으로 변환하는 과정을 데이텀 변환이라고 한다. 투영과 좌표계는 공간참조계(spatial reference system)의 설정과 관련된 개념이며, 이에 대해서는 2장에서 자세히 설명한다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#래스터-데이터와-벡터-데이터",
    "href": "01.html#래스터-데이터와-벡터-데이터",
    "title": "1  시작하기",
    "section": "\n1.3 래스터 데이터와 벡터 데이터",
    "text": "1.3 래스터 데이터와 벡터 데이터\n포인트, 라인, 폴리곤 지오메트리는 벡터(vector) 데이터의 대표적인 예이다. 벡터 지오메트리를 구성하는 좌표값은 지표상의 ‘정확한’ 위치를 나타낸다. 이에 반해, 래스터 데이터는 주로 정사각형 픽셀로 구성된 격자망(이를 래스터(raster)라고 부른다)에 각 셀의 속성값이 할당된 형태의 데이터이다. 래스터 데이터의 예는 그림 1.4에 제시되어 있다.\n\n\n\n\n\n그림 1.4: 브라질의 대서양 연안 도시 올린다에 대한 래스터 지도: (a) Landsat-7의 청색 밴드를 타나낸 것으로 서로 다른 컬러는 속성값의 차이를 나타냄. (b) 좌상의 10 X 10 픽셀만 확대하여 나타냄. (c) 3개의 표본 포인트로 구성된 벡터 데이터를 중첩하여 나타냄. (d) 표본 포인트로부터 반경 500 m를 나타낸 3개의 폴리곤으로 구성된 벡터 데이터를 중첩하여 나타냄.\n\n\n벡터 데이터와 래스터 데이터는 여러 방식으로 결합할 수 있다. 예를 들어, 그림 1.4(c)에 나타난 세 개의 포인트에 해당하는 래스터 값을 추출할 수 있으며, 그림 1.4(d)에 나타난 원 내부에 포함된 모든 래스터 값을 선택적으로 추출할 수도 있다.\n래스터에서 벡터로의 전환은 7.6절에서 다루며, 다음과 같은 내용을 포함한다.\n\n래스터 픽셀 값을 포인트의 속성값으로 전환하기\n래스터 픽셀 값을 폴리곤의 속성값으로 전환한 후, 동일한 속성값을 가진 폴리곤을 병합하기(‘폴리곤 생성’)\n특정 범위의 값을 가진 연속적인 픽셀 영역을 라인이나 폴리곤으로 표현하기(‘등치선 생성’)\n\n\n\n\n\n\n그림 1.5: 그림 1.1에 나타나 있는 카운티별 출생아 수(1974~1978)를 래스터화하여 나타낸 지도\n\n\n그림 1.5에 나타난 벡터에서 래스터로의 전환(폴리곤의 래스터화)은 매우 단순한 사례이다. 그러나 다른 형태의 벡터-투-래스터 전환은 보다 복잡한 통계적 모형화를 수반한다. 예를 들어 다음과 같은 경우가 있다.\n\n포인트 속성값을 내삽하여 그리드 셀에 할당하기(12장 참조)\n포인트의 밀도 분포를 추정하여 그리드 셀에 할당하기(11장 참조)\n폴리곤의 속성값을 면적 가중 내삽을 통해 그리드 셀에 할당하기(5.3절 참조)\n포인트, 라인, 폴리곤을 래스터로 직접 변환하기(7.6절 참조)",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#래스터-유형",
    "href": "01.html#래스터-유형",
    "title": "1  시작하기",
    "section": "\n1.4 래스터 유형",
    "text": "1.4 래스터 유형\n래스터 데이터의 디멘션은 행과 열이 공간 좌표계와 어떻게 연결되는가에 따라 결정된다. 그림 1.6은 그 다양한 가능성을 예시로 보여준다.\n\n\n\n\n\n그림 1.6: 다양한 래스터 지오메트리 유형\n\n\n그림 1.6에 나타나 있는 규칙(regular) 래스터는 일정한 모양(반드시 정사각형일 필요는 없음)의 그리드 셀로 구성되어 있으며, 가로축과 세로축이 \\(x\\)축(동거축)과 \\(y\\)축(북거축)과 일치한다. 그러나 이 외에도 다양한 형태의 래스터가 존재한다. 예를 들어, 가로축과 세로축이 \\(x\\)축 및 \\(y\\)축과 일치하지 않는 회전형(rotated) 래스터, 가로축과 세로축이 서로 직교하지 않는 전단형(sheared) 래스터, 특정 디멘션을 따라 셀 크기가 달라지는 직교형(rectilinear) 래스터이다. 마지막으로, 곡선형(curvilinear) 래스터는 셀의 크기나 방향이 한 디멘션에서만 결정되는 것이 아니라, 다른 디멘션의 변화에도 영향을 받는다.(역자주: 곡선형 래스터는 좌표축이 곡선 형태를 이루기 때문에, 셀의 크기와 방향이 한 축에서만 결정되는 것이 아니라 다른 축의 변화에도 의존한다. 이는 일반적인 직교 좌표 기반 래스터와 달리, 두 디멘션이 서로 얽혀 있는 구조를 가진다는 뜻이다.)\n특정 좌표참조계에 기반한 규칙 래스터가 있다고 하자. 이 래스터를 셀 구조를 그대로 유지한 채 다른 투영법으로 변환하면, 직교형 래스터가 될 수도 있고(예: 그림 1.3에서처럼 측지 좌표를 메르카토르 도법으로 변환하는 경우), 곡선형 래스터가 될 수도 있다(예: 그림 1.1에서처럼 측지 좌표를 람베르트 정형원추 도법으로 변환하는 경우). 이와 같은 변환 과정을 역으로 수행하면 원래의 래스터를 손실없이 정확히 복원할 수 있다.\n새로운 투영법이 적용된 규칙 그리드를 새로 생성하는 과정을 래스터(또는 이미지) 재투영(reprojection) 또는 워핑(warping)이라고 한다(7.8절 참조). 워핑 과정에서는 정보 손실이 발생할 수 있으며, 일반적으로 불가역적이고 여러 옵션 설정이 필요하다. 예를 들어, 새로운 셀 값을 생성할 때 인터폴레이션을 적용할지, 평균값이나 합계값을 계산할지 여부를 결정해야 하며, 이웃 셀 값을 활용한 재샘플링 적용 여부도 함께 고려해야 한다. 이러한 선택은 래스터 셀 값이 범주형인지 연속형인지에 따라 달라질 수 있다(1.6절 참조).",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#시계열-어레이-데이터-큐브",
    "href": "01.html#시계열-어레이-데이터-큐브",
    "title": "1  시작하기",
    "section": "\n1.5 시계열, 어레이, 데이터 큐브",
    "text": "1.5 시계열, 어레이, 데이터 큐브\n많은 공간데이터는 공간적 특성뿐만 아니라 시간적 특성도 함께 지닌다. 모든 관측치는 관측이 이루어진 특정 지점뿐 아니라, 관측이 수행된 특정 시점과도 결부되어 있다. 예를 들어, 노스캐롤라이나 카운티 데이터셋은 그림 1.2에서 보듯 두 시점의 관측값을 포함하고 있다. 원래 데이터셋에서는 이 두 시점의 값이 각각 별도의 변수로 저장되어 있었을 가능성이 크지만, 그림 1.2와 같이 두 개의 패싯 지도로 표현하려면 지오메트리를 반복하여 두 변수를 하나의 열로 길게 배열하는 형태로 변형해야 한다. 위컴(Wickham, 2014)은 이러한 형태를 타이디(tidy) 형태라고 부른다. 그러나 지오메트리와 연결된 긴 시계열 데이터를 다룰 때는, 시간별로 여러 열을 사용하는 방식도, 지오메트리를 반복해 하나의 열로 시간값을 나열하는 방식도 효율적이지 않을 수 있다. 이러한 경우에는 시간과 공간을 각각 하나의 차원으로 설정한 매트릭스나 어레이(array) 구조가 더 효과적일 수 있다. 이미지나 래스터 데이터는 본래 매트릭스 구조로 저장되며, 여기에 시간이 추가되면 3차원 어레이가 된다. 이렇게 여러 차원의 데이터를 저장 및 표현하는 일반적인 구조를 (시공간적) 데이터 큐브(data cube)라고 한다. 데이터 큐브는 차원의 수에 제한이 없는 어레이 구조를 의미하며, 벡터 데이터와 래스터 데이터 모두에 적용될 수 있다. 이에 대한 다양한 예시는 6장에서 다룬다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#서포트",
    "href": "01.html#서포트",
    "title": "1  시작하기",
    "section": "\n1.6 서포트",
    "text": "1.6 서포트\n단일 포인트 지오메트리가 아닌, 포인트 집합 지오메트리(다중 포인트, 라인, 폴리곤, 픽셀)를 가진 공간데이터의 경우 결부된 속성값은 해당 지오메트리와 몇 가지 서로 다른 방식으로 연결될 수 있다.\n\n지오메트리의 모든 포인트에 공통적으로 적용되는 상수값(constant value)\n지오메트리의 모든 포인트를 집합적으로 대표하는 집계값(aggregate value)\n각 지오메트리의 고유성을 나타내는 식별값(identity value)\n\n상수값의 예로는 폴리곤의 토지이용 속성이나 기반암 유형이 있고, 집계값의 예로는 카운티의 출생아수가 있으며, 식별값의 예로는 카운티 이름이 있다.(역자주: 폴리곤의 토지이용은 폴리곤 내 모든 지점에 공통적으로 적용될 수 있는 상수값이다. 반면, 카운티의 출생아 수는 카운티 내 모든 지점의 값을 합산한 집계값이므로, 특정 지점에 적용될 수는 없고 카운티 전체를 집합적으로 대표하는 값이다.)\n한 속성값과 결부된 공간적 개체를 해당 속성값의 서포트(support)라고 한다. 집계값은 ‘블록(block)’(폴리곤 또는 라인) 서포트를 가지며, 상수값은 ‘포인트’ 서포트를 가진다(동일한 값이 모든 포인트에 적용된다). 예를 들어, 그림 1.5는 폴리곤 서포트를 갖는 변수(카운티별 출생아 수)로부터, 카운티별 속성값을 해당 카운티를 구성하는 픽셀의 속성값으로 할당한 결과이다. 그러나 이렇게 생성된 래스터 지도는 의미가 없다. 속성값인 카운티별 ’총출생아 수’는 개별 래스터 셀과 무관하며, 속성값과 결부된 카운티 전체 경계조차 표시되어 있지 않다. 따라서 이 지도로부터 노스캐롤라이나 주 전체의 출생아 수나 출생아 밀도를 재계산할 수 없다.\n래스터 셀의 속성은 포인트 서포트를 가질 수도 있고, 블록 서포트를 가질 수도 있다. 포인트 서포트의 대표적인 예는 고도이다. 예를 들어 DEM(digital elevation model, 수치표고모형)에서는 보통 셀 중심점의 고도값을 셀 속성으로 저장한다. 블록 서포트(혹은 셀 서포트)의 예로는 위성영상을 들 수 있다. 이미지 픽셀의 속성값은 대개 해당 픽셀(또는 픽셀을 중심으로 한 일정 영역) 내부 값들의 평균이다. 대부분의 파일 포맷은 이러한 서포트 정보를 명시적으로 제공하지 않는다. 그러나 래스터 데이터를 애그리게이팅(aggregating) 하거나, 리그리딩(regridding) 하거나, 워핑(warping) 할 때(7.8절), 또는 포인트별 값을 추출할 때는 매우 중요한 요소가 된다.(역자주: 애그리게이팅은 공간 해상도를 낮추는 과정, 리그리딩은 그리드 체계를 바꾸는 과정, 워핑은 다른 투영법을 적용해 래스터 유형을 변환하는 것을 의미한다.)",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#공간데이터사이언스를-위한-소프트웨어",
    "href": "01.html#공간데이터사이언스를-위한-소프트웨어",
    "title": "1  시작하기",
    "section": "\n1.7 공간데이터사이언스를 위한 소프트웨어",
    "text": "1.7 공간데이터사이언스를 위한 소프트웨어\n이 책에서 기본적으로 사용하는 프로그래밍 언어는 R이며, 공간데이터사이언스를 위해 다양한 R 패키지를 활용한다. 이들 R 패키지 중 상당수는 여러 종류의 소프트웨어 라이브러리를 기반으로 동작하는데, 이러한 라이브러리들은 R만을 위해 개발된 것이 아니다. 예를 들어, 그림 1.7은 sf 패키지의 의존 관계(dependency)를 보여주며, 이를 통해 sf 패키지가 R 패키지뿐 아니라 시스템 라이브러리도 함께 사용하고 있음을 알 수 있다.\n\n\n\n\n\n그림 1.7: sf 패키지의 의존 관계: 직선은 강한 의존성을, 점선은 약한 의존성을 나타낸다.\n\n\nC 또는 C++로 작성된 라이브러리(GDAL, GEOS, PROJ, liblwgeom, s2geometry, NetCDF, udunits2)는 모두 R 커뮤니티가 아니라 (공간)데이터사이언스 전반의 다른 커뮤니티에서 개발, 유지, 활용되고 있다. 이러한 라이브러리를 사용함으로써 R 사용자들은 다른 커뮤니티와 공유하는 기술과 협업의 범위를 이해할 수 있다. R, Python, Julia는 인터랙티브한 인터페이스를 제공하기 때문에 많은 사용자가 이러한 라이브러리를 기반으로 한 응용 소프트웨어 사용자들보다 라이브러리에 더 직접적으로 접근할 수 있다. 이 책의 제1부에서는 이러한 라이브러리에 내재된 핵심 개념을 설명하며, 이는 공간데이터사이언스를 폭넓게 이해하는 데 큰 도움이 될 것이다.\n\n1.7.1 GDAL\nGDAL(Geospatial Data Abstraction Library)은 공간데이터 처리에서 ’스위스 만능칼’과 같은 역할을 한다고 할 수 있다. GDAL은 R, Python, PostGIS를 비롯해 100개가 넘는 다른 소프트웨어 프로젝트에서 폭넓게 사용되고 있다.\nGDAL은 공간데이터를 읽고 쓸 수 있게 해주는 라이브러리 가운데서도 핵심적인 라이브러리로, 수많은 다른 라이브러리에 의존한다. 약 100개가 넘는 라이브러리와 연동되며, 각 라이브러리는 특정 데이터 파일 포맷, 특정 데이터베이스, 특정 웹서비스 또는 특정 압축 코덱을 처리한다.\nCRAN에서 배포되는 바이너리 형식의 R 패키지에는 스태틱 링크 코드(statically linked code)만 포함되어 있다. 이는 CRAN이 패키지를 배포하는 시스템에 서드파티(third-party) 라이브러리가 설치되어 있다고 가정하지 않기 때문이다. 그 결과 CRAN에서 바이너리 형식의 sf 패키지를 설치하면 sf 패키지의 의존성뿐 아니라 모든 외부 라이브러리도 함께 다운로드되어, 설치 파일 용량이 약 100MB에 달한다.(역자주: CRAN은 The Comprehensive R Archive Network의 약자로, R 패키지를 저장하는 중앙 저장소이다. R 언어 자체의 과거와 현재 버전뿐 아니라 20,000개 이상의 R 패키지가 모여 있다. 1997년 쿠르트 호르닉(Kurt Hornik)과 프리드리히 라이슈(Friedrich Leisch)가 처음 만들었으며, 현재도 쿠르트 호르닉과 많은 자원봉사자가 운영하고 있다. 스태틱 링크 코드는 컴파일 시점에 필요한 라이브러리나 의존성을 실행 파일에 미리 포함시켜 만든 코드를 의미한다.)\n\n1.7.2 PROJ\nPROJ(혹은 PR\\(\\phi\\)J)는 지도 투영과 데이텀 변환을 위한 라이브러리로, 공간 좌표를 한 CRS에서 다른 CRS로 변환한다. PROJ에는 현재까지 알려진 수많은 투영법에 대한 데이터베이스가 포함되어 있으며, 데이텀 변환을 위한 고정밀 계수값을 담은 데이터 그리드에 접근할 수 있다. 또한 PROJ는 CRS에 관한 국제 표준을 따른다(Lott 2015). 좌표계와 PROJ에 대해서는 2장에서 자세히 다룬다.\n\n1.7.3 GEOS와 s2geometry\nGEOS(Geometry Engine Open Source)와 s2geometry는 지오메트리 연산을 위한 라이브러리이다. 이들 라이브러리를 활용하면 기하학적 측정(길이, 면적, 거리), 프레디케이트(predicate)(두 지오메트리가 포인트를 공유하는지 여부), 새로운 지오메트리 생성(두 지오메트리가 공유하는 포인트) 등의 연산을 수행할 수 있다.(역자주: 프레디케이트는 특정 조건이 참인지 거짓인지 판별하는 논리 연산을 의미한다. 공간데이터 연산에서는 두 지오메트리가 접하는지, 포함하는지, 겹치는지 등을 판정하는 함수나 연산자를 지칭한다. ‘(공간) 관계 연산자’ 등으로 번역하기도 하지만 여기서는 원어를 음역한 ’프레디케이트’를 그대로 사용한다.) GEOS는 이러한 연산을 2차원 평면(\\(R^2\\))에서 수행하며, s2geometry는 이를 3차원 구면(\\(S^2\\))에서 수행한다. CRS에 대해서는 2장에서, 그리고 2차원 공간과 3차원 공간을 다루는 차이점은 4장에서는 좀 더 깊이 논의한다.\n\n1.7.4 NetCDF, udunits2, liblwgeom\nNetCDF(UCAR 2020)는 파일 형식이자 NetCDF 파일을 읽고 쓰기 위한 C 라이브러리를 의미한다. NetCDF를 통해 모든 차원의 어레이를 정의할 수 있으며, 특히 기후 모형화 커뮤니티에서 공간 및 시공간 정보를 다루는 데 널리 사용된다. Udunits2(UCAR 2014; Pebesma, Mailud, and Hiebert 2016; Pebesma et al. 2022)는 측정 단위와 관련된 데이터베이스이자 소프트웨어 라이브러리로, 측정 단위 간 전환과 파생 단위 처리를 지원하며 사용자 정의 단위도 사용할 수 있다. liblwgeom ’라이브러리’는 PostGIS(Obe and Hsu 2015)의 소프트웨어 구성 요소로서, GDAL이나 GEOS에서는 다루지 않는 몇 가지 루틴을 포함한다. 예를 들어 PROJ가 포함된 GeographicLib 루틴에 손쉽게 접근할 수 있게 해준다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "01.html#연습문제",
    "href": "01.html#연습문제",
    "title": "1  시작하기",
    "section": "\n1.8 연습문제",
    "text": "1.8 연습문제\n\n래스터 데이터와 백터 데이터의 차이점 다섯 가지를 열거하시오.\n그림 1.1 아래에 나열되어 있는 것 외에, 지도의 그래픽 요소 다섯 개를 더 열거하시오.\n그림 1.5에 나타나 있는 수치 정보가 왜 오해를 불러일으키는지(혹은 무의미한지)에 대해 얘기해 보시오.\n지오메트리 연산을 \\(S^2\\)에서 수행하는 것과 \\(R^2\\)에서 수행하는 것의 차이가 가장 극명하게 드러나는 상황을 예로 들어 설명하시오.\n\n\n\n\n그림 1.1: 첫 번째 지도: 미국 노스캐롤라이나의 카운티별 출생아수, 1974~1978년\n그림 1.2: “미국 노스캐롤라이나 카운티별 영아돌연사증후군에 의한 사망아수의 패싯 지도, 1974~1978년과 1979~1984년”\n그림 1.4: 브라질의 대서양 연안 도시 올린다에 대한 래스터 지도: (a) Landsat-7의 청색 밴드를 타나낸 것으로 서로 다른 컬러는 속성값의 차이를 나타냄. (b) 좌상의 10 X 10 픽셀만 확대하여 나타냄. (c) 3개의 표본 포인트로 구성된 벡터 데이터를 중첩하여 나타냄. (d) 표본 포인트로부터 반경 500 m를 나타낸 3개의 폴리곤으로 구성된 벡터 데이터를 중첩하여 나타냄.\n그림 1.5: 그림 1.1에 나타나 있는 카운티별 출생아 수(1974~1978)를 래스터화하여 나타낸 지도\n그림 1.6: 다양한 래스터 지오메트리 유형\n그림 1.7: sf 패키지의 의존 관계: 직선은 강한 의존성을, 점선은 약한 의존성을 나타낸다.",
    "crumbs": [
      "공간데이터",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "17.html",
    "href": "17.html",
    "title": "17  공간계량경제학적 모형",
    "section": "",
    "text": "17.1 정의\n공간 프로세스를 모형화하려는 시도 가운데 가장 초기의 공간계량경제학적 정식화 중 하나는, 잔차의 공간적 자기상관을 모형화하는 방식이다. 이는 공간오차모형(SEM)으로 다음과 같이 표현된다.\n\\[\n\\textbf{y}=\\textbf{X}\\beta+\\textbf{u},\\qquad \\textbf{u}=\\rho_\\text {Err} \\textbf{Wu}+\\epsilon\n\\]\n여기서 \\(\\textbf{y}\\)는 \\(N\\) 위치에서 측정된 반응변수의 \\((N\\times1)\\) 관측치 벡터, \\(\\textbf{X}\\)는 \\((N \\times k)\\) 공변량 행렬, \\(\\beta\\)는 \\((k \\times 1)\\) 계수 벡터, \\(\\textbf{u}\\)는 공간적 자기상관을 갖는 \\((N \\times 1)\\) 교란 벡터, \\(\\epsilon\\)은 독립항등분포를 따르는 \\((N \\times 1)\\) 교란 벡터, \\(\\rho_\\text{Err}\\)는 스칼라 형태의 공간 계수이다.\n이 모형과 유사한 다른 공간계량경제학 모형들은 혼합모형 프레임워크에는 부합하지 않는다. 여기서 모형화된 공간 프로세스는 반응변수, 공변량, 그리고 계수와 직접적으로 상호작용한다. 이러한 형태의 모형화 접근은 시계열 프레임워크를 단순히 2차원으로 확장한 오래된 전통에서 기원한 것으로 보인다.\n\\[\n\\textbf{u}=(\\textbf{I}-\\rho_\\text{Err}\\textbf{W})^{-1}\\epsilon,\\quad \\textbf{y}=\\textbf{X}\\beta+(\\textbf{I}-\\rho_\\text{Err}\\textbf{W})^{-1}\\epsilon,\\quad (\\textbf{I}-\\rho_\\text{Err}\\textbf{W})\\textbf{y}=(\\textbf{I}-\\rho_\\text{Err}\\textbf{W})\\textbf{X}\\beta+\\epsilon\n\\]\n만약 공변량과 반응변수가 동일한 공간 프로세스를 따른다면, 최소제곱법(OLS) 계수와 공간오차모형 계수 사이의 차이는 거의 없을 것이다. 그러나 실제로는 두 프로세스가 일치하지 않는 경우가 많으며, 이를 판별 및 조정하기 위해서는 Hausman 검정과 같은 추가 절차가 필요하다(Pace and LeSage 2008). 이러한 논의는, 공간 프로세스가 일치하는 경우 시계열 분석의 단위근(unit root)과 공적분(cointegration) 개념을 공간적으로 확장하려는 이전 연구와도 연결된다(Fingleton 1999).\n반응변수에만 공간 프로세스를 포함하는 모형을 공간래그모형(SLM)이라 하며, 종종 공간자기회귀모형(SAR, spatial autoregressive mode)이라고도 부른다(LeSage and Pace 2009). 더빈(Durbin) 모형은 여기에 공변량의 공간래그항을 추가한 형태이다. 공간더빈모형(spatial Durbin model)에 관한 종합적인 리뷰는 Mur와 Angulo(2006)를 참고할 수 있다. 만약 반응변수에 공간 프로세스를 포함하는 동시에 잔차에도 공간 프로세스를 포함시키면, 두 가지 형태의 모형이 가능하다. 하나는 모든 모형 요소를 포함하는 일반중첩모형(GNM, general nested model)이고, 다른 하나는 공간래그 공변량을 포함하지 않는 공간자기회귀-자기회귀모형(SARAR, spatial autoregressive-autoregressive model) 또는 공간자기회귀결합모형(SAC, spatial autoregressive combined model)이다. 반면, 반응변수나 잔차에 공간 프로세스를 모형화하지 않고, 단순히 공변량의 공간래그항을 선형모형에 추가할 수도 있다. 이를 공간래그X모형(SLX, spatial lag of X model)이라고 한다(Elhorst 2010; Bivand 2012; LeSage 2014; Halleck Vega and Elhorst 2015). GNM은 다음과 같이 표현된다.\n\\[\n\\textbf{y}=\\rho_\\text{Lag}\\textbf{Wy}+\\textbf{X}\\beta+\\textbf{WX}\\gamma+\\textbf{u},\\qquad \\textbf{u}=\\rho_\\text{Err}\\textbf{Wu}+\\epsilon\n\\]\n여기서 \\(\\gamma\\)는 \\((k' \\times 1)\\) 파라미터 벡터이다. \\(k'\\)는 절편과 일부 공변량을 정의하며, 행표준화 공간가중치행렬을 사용하고 공간래그 절편을 포함하지 않는 경우 \\(k'=k-1\\)이다.\n이 기본 모형에 특정 제약을 가하면 다양한 변형 모형이 도출된다. \\(\\gamma = 0\\)으로 설정하면 이중 공간계수 모형인 SAC/SARAR 모형이, \\(\\rho_\\text{Err}=0\\)으로 설정하면 공간더빈모형(SDM, spatial Durbin model)이, \\(\\rho_\\text{Lag}=0\\)으로 설정하면 공간더빈오차모형(SDEM, spatial Durbin error model)이 된다. 더 강한 조건을 부여할 수도 있는데, \\(\\gamma = 0\\)과 \\(\\rho_\\text{Err}=0\\)로 설정하면 공간래그모형(SLM), \\(\\gamma=0\\)와 \\(\\rho_\\text{Lag}=0\\)으로 설정하며 공간오차모형(SEM), \\(\\rho_\\text{Lag}=0\\)과 \\(\\rho_\\text{Err}=0\\)으로 설정하면 공간래그X모형(SLX)이 된다.\n공변량이 관측된 새로운 위치에 대해 예측을 수행하는 것과 관련된 문제는 오래전부터 인식되어 왔지만, 그 가능성에 대한 체계적인 검토와 실질적 진전은 상당한 시간이 지나서야 이루어졌다(Bivand 2002; Goulard, Laurent, and Thomas-Agnan 2017; Laurent and Margaretic 2021). MLE로 적합된 SLM, SDM, SEM, SDEM, SAC, GNM 모형을 예측에 적용하는 방법은 ‘Google Summer of Code(구글 썸머 오프 코드)’ 프로젝트를 수행한 마틴 구브리(Martin Gubri)의 공로가 크다. 또한, 결측 데이터를 다루는 유사한 모형에 관한 연구(Suesse 2018)는 보스턴 주택 데이터셋에서 검열된 중앙값 주택가격을 분석하는데 시사점을 제공한다. 예측 문제를 다루다 보면 해당 모형의 축약 형태(reduced form)가 매우 중요하다는 점을 인식하게 된다. 특히 SLM, SDM, SAC, GNM 모형처럼 반응변수의 공간 프로세스가 회귀계수와 상호작용하는 경우에는, 보다 단순화된 형태의 표현이 분석과 해석에 도움이 될 수 있다.(역자주: 여기서 ’축약 형태’란 공간계량경제학이나 회귀분석에서 모형을 단순화하여, 반응변수를 설명변수와 오차항만의 함수로 나타낸 식을 말하며, 효과 계산과 예측 분석에서 핵심적인 역할을 한다. 예를 들어 SLM에서는 단위행렬에서 공간계수와 공간가중치행렬의 곱을 뺀 행렬의 역행렬을 곱해 풀면 축약 형태가 되며, 이 역행렬이 공간 파급 효과를 나타낸다.)\n반응변수와 회귀계수 간 이러한 상호작용의 결과, 공변량의 단위 변화가 회귀계수 값에 비례하여 반응변수에 직접 효과를 미치려면, 공간래그 반응변수의 계수가 0이어야 한다. 만약 공간 계수가 0이 아니라면, 전역적 파급효과가 작용하게 되며, 그 크기는 회귀계수 만큼이나 중요한 정보가 된다(LeSage and Pace 2009; Elhorst 2010; Bivand 2012; LeSage 2014; Halleck Vega and Elhorst 2015). SDEM 및 SLX 모형의 경우, 각 공변량의 총 파급효과(total spillover effect)는 해당 공변량의 계수와 공간래그 공변량 계수의 합으로 정의되며, 국지적 파급효과(local spillover effect)는 이를 기반으로 선형결합을 사용해 표준오차를 계산하여 나타낸다.\n이것은 GNM 데이터 생성 프로세스에서 확인할 수 있다.\n\\[\n(\\textbf{I}-\\rho_\\text{Err}\\textbf{W})(\\textbf{I}-\\rho_\\text {Lag}\\textbf{W})\\textbf{y}=(\\textbf{I}-\\rho_\\text {Err}\\textbf{W})(\\textbf{X}\\beta+\\textbf{WX}\\gamma)+\\epsilon\n\\]\n이를 다음과 같이 변형하여 나타낼 수 있다.\n\\[\n\\textbf{y}=(\\textbf{I}-\\rho_\\text{Lag}\\textbf{W})^{-1}(\\textbf{X}\\beta+\\textbf{WX}\\gamma)+(\\textbf{I}-\\rho_\\text{Lag}\\textbf{W})^{-1}(\\textbf{I}-\\rho_\\text{Err}\\textbf{W})^{-1}\\epsilon\n\\]\n이 식에서 \\(\\rho_\\text{Lag}\\)와 \\(\\beta\\) 사이에는 상호작용이 존재하며, \\(\\gamma\\)가 존재할 경우에는 세 변수 간의 상호작용이 발생한다. 이는 다음의 편도함수에서 확인할 수 있다: \\(\\partial y_i/\\partial x_{jr}=((\\textbf{I}-\\rho_\\text{Lag}\\textbf{W})^{-1}(\\textbf{I}\\beta_r+\\textbf{W}\\gamma_r))_{ij}\\). 여기서 밀집 행렬 \\(S_r(\\textbf{W})=((\\textbf{I}-\\rho_\\text{Lag}\\textbf{W})^{-1}(\\textbf{I}\\beta_r+\\textbf{W}\\gamma_r))\\)의 주대각 요소는 직접 효과(direct effect)을 나타내고, 비대각 요소는 간접 효과(indirect effect)를 나타낸다.\nPiras와 Prucha(2014)는 Raymond J. G. M. Florax, Folmer, Rey(2003)를 재검토하고 수정하였으며, Hendry(2006)와 Raymond J. G. M. Florax, Folmer, Rey(2006)의 논평도 참고하였다. 이들은 모형 선택 시 통상적으로 사용되는 사전 검정(pre-test) 전략보다, 해당 분석 상황에 적합한 가장 일반적인 모형을 먼저 추정하는 전략이 더 바람직하다고 결론지었다.(역자주: 여기서 ’사전 검정 전략’이란 모형을 선택하기 전에 잔차의 공간적 자기상관 등 사전 가설검정을 수행하고, 그 결과에 따라 SLM, SEM 등 최종 모형을 결정하는 방법을 말한다. 그러나 표본 의존성과 모형 누락 위험이 있어, Piras와 Prucha(2014)는 가장 일반적인 모형을 먼저 적합한 뒤 필요시 단순화하는 방식을 권고하였다.) 이러한 결과에 비추어, 본 장에서는 사전 검정 기반의 모형 선택은 사용하지 않는다.\n현재 spatialreg 패키지가 주력하고 있는 개선 사항 중 하나는 공간래그 공변량 처리 방법의 향상이다. 이를 위해 Durbin 인수를 사용하여, 공간래그 형태로 추가할 공변량의 하위 집합을 지정하는 논리값이나 수식을 받을 수 있도록 하였다. 일부 공변량, 예를 들어 더미 변수와 같은 경우에는 공간래그 형태로 포함하지 않는 것이 바람직하다는 주장도 있다. 공간래그 공변량이 선택되면, 다음 과제는 영향력을 계산할 때 이를 어떻게 적절하게 처리할 것인가 하는 문제이다. 이러한 개선된 기능은 MCMC 또는 MLE로 적합된 횡단면 모형에 적용되며, 향후 공간 패널 모형에도 적용될 예정이다.\n거의 다루어지지 않은 주제이지만, 기능적 형태 가정(functional form assumption)을 언급할 가치가 있다.(역자주: 여기서 ’기능적 형태 가정’이란 반응변수와 독립변수 간의 관계가 특정한 수학적 형태(예: 선형, 로그-선형, 다항식)를 따른다고 전제하는 것이다. 이러한 가정이 실제 데이터 생성 프로세스를 잘 반영하지 못하면 추정 결과에 편향이 발생할 수 있다. 공간계량경제학에서는 반응변수, 공간 효과, 공변량 간 관계를 특정 형태로 가정하는 경우가 많다.) 이 문제는, 예를 들어 McSpatial 패키지에서 구현된 공간분위수회귀(spatial quatile regression, McMillen 2013)와 같은 유연한 구조가 유용한 상황과 관련이 있다. 또한 McSpatial 패키지의 일부 함수, 신규 패키지 spldv(Sarrias and Piras 2022), 그리고 spatialprobit 패키지와 ProbitSpatial 패키지(Wilhelm and Matos 2013; Martinetti and Geniaux 2017)에서 다루는 이산형 반응변수 관련 문제도 있다. McSpatial 패키지의 MCMC 구현은 LeSage와 Pace(2009)에 기반하고 있다. 마지막으로, Wagner와 Zeileis(2019)는 SLM 모형이 재귀적 분할(recursive partitioning) 설정에서 어떻게 활용될 수 있는지를 보여주며, 이를 spatialreg 패키지의 lagsarlm() 함수를 이용해 구현하는 lagsarlmtree 패키지에서 제시하였다.\nspatialreg 패키지(Bivand and Piras 2022)를 이용한 횡단면(cross-sectional) MLE와 일반화 모멘트법(GMM, generalised method of moments) 추정, 그리고 sphet 패키지를 통해 공간계량경제학 스타일의 공간 회귀모형에 대한 리뷰(Bivand and Piras 2015)는 여전히 대부분 유효하다. 이 리뷰에서는 R 패키지에서 제공하는 추정량을 다른 프로그래밍 언어의 대체 구현과 비교하였으나, 베이지안 공간계량경제학 스타일의 공간 회귀는 다루지 않았다. Millo와 Piras(2012)가 설명한 공간 패널 추정량에 대해서는 많은 변화가 있었지만, 본 장에서는 다루지 않는다.\nBivand, Millo와 Piras(2021)는 공간계량경제학적 분석을 위한 R 패키지의 다양한 기능을 포괄적으로 다루며, Bivand와 Piras(2015)를 업데이트하고 GMM 및 공간 패널 모형화의 최근 발전을 포함하고 있다. 따라서 이 장에서는 보스턴 주택가격 데이터셋을 사용한 Bivand(2017)의 예제 중 일부만을 간략히 다룰 것이다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>공간계량경제학적 모형</span>"
    ]
  },
  {
    "objectID": "17.html#최대우도추정법-spatialreg-패키지의-활용",
    "href": "17.html#최대우도추정법-spatialreg-패키지의-활용",
    "title": "17  공간계량경제학적 모형",
    "section": "\n17.2 최대우도추정법: spatialreg 패키지의 활용",
    "text": "17.2 최대우도추정법: spatialreg 패키지의 활용\n단일 공간계수를 가지는 모형(SEM 및 SDEM은 errorsarlm() 함수 사용, SLM 및 SDM은 lagsarlm() 함수 사용)에는 Ord(1975)가 처음 제시한 방법이 적용된다. 다음 표는 최대우도추정법(MLE)을 사용하여 앞서 설명한 모형을 추정할 수 있는 함수를 정리한 것이다.\n\n\n모형\n모형명\nMLE 함수\n\n\n\nSEM\n공간오차\nerrorsarlm(..., Durbin = FALSE)\n\n\nSEM\n공간오차\nspautolm(..., family = \"SAR\")\n\n\nSDEM\n공간더빈오차\nerrorsarlm(..., Durbin = TRUE)\n\n\nSLM\n공간래그\nlagsarlm(..., Durbin = FALSE)\n\n\nSDM\n공간더빈\nlagsarlm(..., Durbin = TRUE)\n\n\nSAC\n공간자기회귀결합\nsacsarlm(..., Durbin = FALSE)\n\n\nGNM\n일반중첩\nsacsarlm(..., Durbin = TRUE)\n\n\n\nerrorsarlm()과 lagsarlm() 추정 함수는 유사한 인수를 받는다. 첫 번째(formula)와 두 번째(data) 인수는 대부분의 모형 추정 함수에서 공통적으로 사용되며, 세 번째 인수는 listw 공간가중치 객체이다. na.action 인수는 결측값이 있는 관측 개체의 공간가중치를 어떻게 처리할지를 정의하며, 다른 모형 추정 함수와 동일하게 동작한다. weights 인수는 분산 항에서 관측값별 변동성을 나타내는 가중치를 제공하는 데 사용되지만, lagsarlm() 함수에서는 이 옵션이 제공되지 않는다.\nDurbin 인수는 이전의 type 및 etype 인수를 대체하며, 지정하지 않으면 기본값은 FALSE로 간주된다. 지정하는 경우, FALSE 또는 TRUE 값을 줄 수 있는데, TRUE로 설정하면 모든 공간래그 설명변수가 포함된다. 또는 포함할 공간래그 설명변수를 지저하는 일면 공식(one-sided formula)을 줄 수 있다.(역자주: 여기서 ’일면 공식’이란 R에서 좌변 없이 ~ 변수1 + 변수2 형태로 작성된 공식을 말하며, 주로 변수 집합을 지정할 때 사용된다. 여기서는 공간래그로 포함할 설명변수를 선택하는 데 쓰인다.) method 인수는 로그우도 함수에서 로그 행렬식 항을 계산하는 방법을 지정하며, 기본값 \"eigen\"은 중간 규모의 데이터셋에 적합하다. interval 인수는 stats 패키지의 optimize() 함수를 통해 공간 계수를 탐색하는 범위를 지정한다. tol.solve() 인수는 base 패키지의 solve() 함수에 전달되며, 회귀계수 간 스케일 차이가 큰 데이터셋에서 분산-공분산 행렬의 역행렬을 계산하는 데 필요하다. 기본값은 base::solve() 함수에서 사용하는 값보다 훨씬 크다. control 인수는 추정 함수의 실행을 세밀하게 조정하는 제어값 리스트를 받는다.\nsacsarlm() 함수는 SAC 및 GNM 형식에서 두 개의 공간 프로세스를 모형화할 때 서로 다른 두 개의 공간가중치를 사용할 수 있도록, 두 번째 공간가중치와 interval 인수를 받을 수 있다. 기본값은 동일한 공간가중치를 사용하는 것이며, 수치 최적화에는 기본적으로는 stats 패키지의 nlminb() 함수가 사용된다. 시작값은 휴리스틱이 방식으로 선택된다. lagsarlm()함수와 마찬가지로 weights 인수는 지원하지 않는다.\n대규모 데이터셋을 사용할 경우, 계수의 분산-공분산 행렬 계산 시 분석적 점근적(analytic asymptotic) 접근 방식 대신 수치적 헤세 행렬(numerical Hessian) 접근 방식이 사용된다.(역자주: ‘분석적 점근적’ 접근 방식은 수학적으로 유도된 공식에 따라 분산–공분산 행렬을 계산하는 방법이며, 표본 크기가 충분히 크다는 가정하에 효율적이다. 반면, ‘수치적 헤세 행렬’ 접근 방식은 모수에 대한 로그우도의 2차 미분을 수치적으로 근사하여 행렬을 구하는 방법으로, 대규모 데이터셋에서 계산 안정성과 정확성을 확보하기 위해 사용된다.)\n\n17.2.1 보스턴 주택가격 데이터셋 예시\n다음 예제는 Bivand(2017)를 기반으로 하며, 16장에서 생성된 객체들을 활용한다.\n\nlibrary(spatialreg)\neigs_489 &lt;- eigenw(lw_q_489)\nSDEM_489 &lt;- errorsarlm(form, data = boston_489, \n      listw = lw_q_489, Durbin = TRUE, zero.policy = TRUE,\n      control = list(pre_eig = eigs_489))\nSEM_489 &lt;- errorsarlm(form, data = boston_489, \n      listw = lw_q_489, zero.policy = TRUE,\n      control = list(pre_eig = eigs_489))\n\n기본값인 \"eigen\" 방법을 사용할 경우, 미리 계산된 고유값을 control 리스트 인수를 통해 전달할 수 있다.\n\ncbind(data.frame(model=c(\"SEM\", \"SDEM\")), \n      rbind(broom::tidy(Hausman.test(SEM_489)), \n            broom::tidy(Hausman.test(SDEM_489))))[,1:4]\n#   model statistic  p.value parameter\n# 1   SEM      52.0 2.83e-06        14\n# 2  SDEM      48.7 6.48e-03        27\n\n489개의 트랙트 데이터셋에 대한 두 가지 Hausman 검정 결과, 회귀계수가 비공간적 회귀분석의 회귀계수와 유의하게 다르다는 점이 확인되었으며, 이는 공간 프로세스의 패턴이 일치하지 않음을 시사한다.(역자주: Hausman 검정은 두 추정량이 모두 일관성을 가지지만 한쪽이 더 효율적일 것으로 가정될 때, 그 효율성이 실제로 유지되는지 확인하는 통계 검정이다. 공간통계 분석에서는 비공간 회귀와 공간 회귀의 계수를 비교하여, 계수 차이가 유의하면 공간 효과가 존재함을 시사한다.)\n\neigs_94 &lt;- eigenw(lw_q_94)\nSDEM_94 &lt;- errorsarlm(form, data=boston_94, listw=lw_q_94,\n                      Durbin = TRUE,\n                      control = list(pre_eig=eigs_94))\n# Warning in RET$pfunction(\"adjusted\", ...): Completion with error &gt;\n# abseps\n\n# Warning in RET$pfunction(\"adjusted\", ...): Completion with error &gt;\n# abseps\n\n# Warning in RET$pfunction(\"adjusted\", ...): Completion with error &gt;\n# abseps\n\n# Warning in RET$pfunction(\"adjusted\", ...): Completion with error &gt;\n# abseps\nSEM_94 &lt;- errorsarlm(form, data = boston_94, listw = lw_q_94,\n                     control = list(pre_eig = eigs_94))\n\n94개의 대기오염 모형 출력 구역에 대한 Hausman 검정에서는 계수 간 유의한 차이가 발견되지 않았다.\n\ncbind(data.frame(model=c(\"SEM\", \"SDEM\")), \n      rbind(broom::tidy(Hausman.test(SEM_94)), \n            broom::tidy(Hausman.test(SDEM_94))))[, 1:4]\n#   model statistic p.value parameter\n# 1   SEM     15.66   0.335        14\n# 2  SDEM      9.21   0.999        27\n\n이러한 결과는 SEM과 SDEM 모형이 대기오염 모형 출력 구역 수준에서 최소제곱법이나 SLX 모형에 비해 거의 추가적인 차이를 만들지 않았음을 보여준다. 이러한 사실은 우도비 검정을 통해 확인할 수 있다.\n\ncbind(data.frame(model=c(\"SEM\", \"SDEM\")),\n      rbind(broom::tidy(LR1.Sarlm(SEM_94)),\n            broom::tidy(LR1.Sarlm(SDEM_94))))[,c(1, 4:6)]\n#   model statistic p.value parameter\n# 1   SEM     2.593   0.107         1\n# 2  SDEM     0.216   0.642         1\n\nspatialreg 패키지의 LR.Sarlm() 함수를 사용하면 중첩(nested) 모형 간 우도비 검정을 실행할 수 있지만, 여기서는 lmtest 패키지의 lrtest() 함수를 사용하며, 결과는 동일하다.(역자주: 여기서 ’중첩 모형’이란 하나의 모형이 다른 모형의 특수한 형태로 포함되어 있는 경우를 말한다. 예를 들어, 공간더빈모형(SDM)에서 일부 계수를 0으로 두면 공간래그모형(SLM)이 되므로, SLM은 SDM에 중첩되어 있다. 우도비 검정은 이러한 중첩 관계를 전제로 두 모형의 적합도를 비교한다.) 트랙트와 모형 출력 구역 모두에서 공간래그 공변량을 포함하는 모형이 더 선호된다는 것으로 나타났다.\n\no &lt;- lmtest::lrtest(SEM_489, SDEM_489)\nattr(o, \"heading\")[2] &lt;- \"Model 1: SEM_489\\nModel 2: SDEM_489\"\no\n# Likelihood ratio test\n# \n# Model 1: SEM_489\n# Model 2: SDEM_489\n#   #Df LogLik Df Chisq Pr(&gt;Chisq)    \n# 1  16    274                        \n# 2  29    311 13  74.4    1.2e-10 ***\n# ---\n# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\no &lt;- lmtest::lrtest(SEM_94, SDEM_94)\nattr(o, \"heading\")[2] &lt;- \"Model 1: SEM_94\\nModel 2: SDEM_94\"\no\n# Likelihood ratio test\n# \n# Model 1: SEM_94\n# Model 2: SDEM_94\n#   #Df LogLik Df Chisq Pr(&gt;Chisq)    \n# 1  16   59.7                        \n# 2  29   81.3 13  43.2    4.2e-05 ***\n# ---\n# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nSLX 모형은 최소제곱법으로 적합되며, 로그우도 값을 반환하므로 잔차에 공간 프로세스 요소를 포함할 필요가 있는지를 검정할 수 있다. 트랙트 데이터셋의 경우, 이를 포함해야 한다는 결과가 명확히 나타났다.\n\nSLX_489 &lt;- lmSLX(form, data = boston_489, listw = lw_q_489,\n                 zero.policy = TRUE)\no &lt;- lmtest::lrtest(SLX_489, SDEM_489)\nattr(o, \"heading\")[2] &lt;- \"Model 1: SLX_489\\nModel 2: SDEM_489\"\no\n# Likelihood ratio test\n# \n# Model 1: SLX_489\n# Model 2: SDEM_489\n#   #Df LogLik Df Chisq Pr(&gt;Chisq)    \n# 1  28    231                        \n# 2  29    311  1   159     &lt;2e-16 ***\n# ---\n# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n그러나 모형 출력 구역 데이터에서는 그와 반대되는 결과가 나타났다.\n\nSLX_94 &lt;- lmSLX(form, data = boston_94, listw = lw_q_94)\no &lt;- lmtest::lrtest(SLX_94, SDEM_94)\nattr(o, \"heading\")[2] &lt;- \"Model 1: SLX_94\\nModel 2: SDEM_94\"\no\n# Likelihood ratio test\n# \n# Model 1: SLX_94\n# Model 2: SDEM_94\n#   #Df LogLik Df Chisq Pr(&gt;Chisq)\n# 1  28   81.2                    \n# 2  29   81.3  1  0.22       0.64\n\n이러한 결과는 주택 단위 수를 트랙트와 모형 출력 구역별로 집계해 사례 가중치를 적용했을 때도 동일하게 유지되었다.\n\nSLX_489w &lt;- lmSLX(form, data = boston_489, listw = lw_q_489,\n                  weights = units, zero.policy = TRUE)\nSDEM_489w &lt;- errorsarlm(form, data = boston_489,\n                        listw = lw_q_489, Durbin = TRUE,\n                        weights = units, zero.policy = TRUE,\n                        control = list(pre_eig = eigs_489))\no &lt;- lmtest::lrtest(SLX_489w, SDEM_489w)\nattr(o, \"heading\")[2] &lt;- \"Model 1: SLX_489w\\nModel 2: SDEM_489w\"\no\n# Likelihood ratio test\n# \n# Model 1: SLX_489w\n# Model 2: SDEM_489w\n#   #Df LogLik Df Chisq Pr(&gt;Chisq)    \n# 1  28    311                        \n# 2  29    379  1   136     &lt;2e-16 ***\n# ---\n# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nSLX_94w &lt;- lmSLX(form, data = boston_94, listw = lw_q_94,\n                 weights = units)\nSDEM_94w &lt;- errorsarlm(form, data = boston_94, listw = lw_q_94,\n                       Durbin = TRUE, weights = units,\n                       control = list(pre_eig = eigs_94))\no &lt;- lmtest::lrtest(SLX_94w, SDEM_94w)\nattr(o, \"heading\")[2] &lt;- \"Model 1: SLX_94w\\nModel 2: SDEM_94w\"\no\n# Likelihood ratio test\n# \n# Model 1: SLX_94w\n# Model 2: SDEM_94w\n#   #Df LogLik Df Chisq Pr(&gt;Chisq)\n# 1  28   97.5                    \n# 2  29   98.0  1  0.92       0.34\n\n이 경우와 Bivand(2017)에서 제시된 논거를 바탕으로, 가중치 사용은 정당화된다. 이는 주택 단위 수가 트랙트의 경우 5개에서 3,031개까지, 대기오염 모형 출력 구역의 경우는 25개에서 12,411개까지 다양하기 때문이다. 이러한 이유와, 가중치를 활용하는 GNM 모형이 아직 개발되지 않았다는 점 때문에, GNM 모형을 출발점으로 삼아 일반 모형에서 더 단순한 모형으로의 검정을 수행할 수 없다. 대신 SDEM 모형을 출발점으로 설정하고, Hausman 검정을 사용하여 관측 단위 선택에 지침을 얻는다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>공간계량경제학적 모형</span>"
    ]
  },
  {
    "objectID": "17.html#공간-효과-추정",
    "href": "17.html#공간-효과-추정",
    "title": "17  공간계량경제학적 모형",
    "section": "\n17.3 공간 효과 추정",
    "text": "17.3 공간 효과 추정\n전역적 효과는 공간래그 반응변수를 포함하는 모형(SLM, SDM, SAC, GNM)의 적합 결과를 보고할 때 핵심적인 요소로 간주된다(LeSage and Pace 2009). 전역적 효과를 공간래그 공변량(SLX, SDEM)을 포함하는 다른 모형으로 확장하려는시도도 이루어졌다(Elhorst 2010; Bivand 2012; Halleck Vega and Elhorst 2015). SLM, SDM, SAC, GNM 모형은 MLE 또는 GMM을 사용하여 적합시킬 경우, 계수의 분산-공분산 행렬을 활용할 수 있다. 계수 추정치를 평균으로 하고, 추정된 분산-공분산 행렬로부터 분산을 가져와 다변량 정규분포를 구성한 뒤, 이로부터 난수를 추출할 수 있다. 베이지안 방법으로 적합한 경우에는 표본이 사전에 주어지므로 별도의 추출이 필요 없다. SDEM의 경우, 비래그 공변량의 회귀계수에 대한 표본은 직접(direct) 효과를 나타내고, 공간래그 공변량의 회귀계수에 대한 표본은 간접(indirect) 효과를 나타내며, 이 둘을 합한 값이 총(total) 효과를 이룬다.\nSLX와 SDEM 모형에서는 추론을 위해 샘플링이 필요하지 않으므로, MLE로 적합된 모형에 대해서는 선형결합을 사용한다. 여기서는 공기오염 변수에 대해서만 결과를 제시한다. 모형 출력 보고 방법과 관련된 문제는 아직 완전히 해결되지 않았다. 이는 개별 공변량에 대해 세 가지 효과 값을 보고해야 하기 때문이다. 공간래그 공변량이 포함될 경우, 기존의 두 개의 계수는 세 가지 효과로 대체된다. 여기서는 공기오염 변수에 대한 예시를 보여준다.\n\nsum_imp_94_SDEM &lt;- summary(impacts(SDEM_94))\nrbind(Impacts = sum_imp_94_SDEM$mat[5,], \n      SE = sum_imp_94_SDEM$semat[5,])\n#           Direct Indirect   Total\n# Impacts -0.01276 -0.01845 -0.0312\n# SE       0.00235  0.00472  0.0053\n\nSLX와 SDEM 모형에서 직접 효과는 동일한 관측 단위에서 공기오염 변화가 반응변수에 미치는 영향이며, 간접 효과(지역 효과)는 인접한 관측 단위에서 공기오염 변화가 반응변수에 미치는 영향이다.\n\nsum_imp_94_SLX &lt;- summary(impacts(SLX_94))\nrbind(Impacts = sum_imp_94_SLX$mat[5,], \n      SE = sum_imp_94_SLX$semat[5,])\n#          Direct Indirect    Total\n# Impacts -0.0128 -0.01874 -0.03151\n# SE       0.0028  0.00556  0.00611\n\n같은 방법을 가중 공간 회귀분석에 적용한 결과, 공기오염이 주택 가치에 미치는 총 효과는 감소했으나 여전히 통계적으로 유의하였다.\n\nsum_imp_94_SDEMw &lt;- summary(impacts(SDEM_94w))\nrbind(Impacts = sum_imp_94_SDEMw$mat[5,], \n      SE = sum_imp_94_SDEMw$semat[5,])\n#           Direct Indirect    Total\n# Impacts -0.00592 -0.01076 -0.01668\n# SE       0.00269  0.00531  0.00559\n\n전체적으로, 대기오염 모형 출력 구역 수준으로 집계된 공간래그 공변량만을 포함하는 가중 공간 회귀모형이 대부분의 모형 오지정 오류를 해결하는 것으로 보인다. Bivand(2017)에서 더 자세히 논의된 바와 같이, 이는 오지정된 대체 모형들보다 오염 제거에 대한 지불의향이 훨씬 더 크다는 점을 보여준다.\n\nsum_imp_94_SLXw &lt;- summary(impacts(SLX_94w))\nrbind(Impacts = sum_imp_94_SLXw$mat[5,], \n      SE = sum_imp_94_SLXw$semat[5,])\n#           Direct Indirect    Total\n# Impacts -0.00620 -0.01221 -0.01842\n# SE       0.00326  0.00628  0.00629",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>공간계량경제학적 모형</span>"
    ]
  },
  {
    "objectID": "17.html#예측",
    "href": "17.html#예측",
    "title": "17  공간계량경제학적 모형",
    "section": "\n17.4 예측",
    "text": "17.4 예측\n보스턴 구역 데이터셋에서 응답변수인 중위 주택가격의 17개 관측치가 누락되어 있다. 이를 채우기 위해 \"Sarlm\" 객체에 대한 predict() 메서드를 사용한다. 이 메서드는 Goulard, Laurent, and Thomas-Agnan(2017)을 기반으로 마틴 구브리(Martin Gubri)가 재작성하였으며 Laurent와 Margaretic(2021)도 참고할 수 있다. pred.type 인수는 해당 논문에서 제시된 예측 전략을 지정한다.\n이 예시에서는 pred.type 설정을 달리하여 SDEM 모형의 다양한 변종으로 샘플 외 예측을 수행한다. 이를 통해 예측 결과의 차이를 확인할 수 있으며, 이는 연구할 가치가 있는 중요한 주제임을 시사한다. 누락 변수 처리에 대해서는 여러 대안이 제시되어 있다(Gómez-Rubio, Bivand, and Rue 2015; Suesse 2018). 예측에 대한 관심이 높아지는 또 다른 이유는, 예측이 기계학습 접근 방식의 기본 요소이기 때문이다. 기계학습에서는 검증 및 테스트 데이터셋을 대상으로 한 예측 성능이 모형 사양 선택을 이끈다. 그러나 공간적 의존성을 지닌 공간데이터에서 훈련 및 검정 데이터셋을 선택하는 문제는 여전히 해결되지 않았으며, 이는 독립 표본 데이터의 경우와는 확연히 다른 복잡성을 지닌다.\n여기서는 검열된 트랙트 관측값에 대해 세 가지 상이한 예측 유형을 적용하고, USD 단위의 주택 중위값으로 복원하기 위해 지수 변환을 수행한다. 이때 newdata 객체의 row.names() 함수가 공간가중치행렬의 \"region.id\" 속성과 일치해야 샘플 외 예측이 가능하다는 점에 유의해야 한다.\n\nnd &lt;- boston_506[is.na(boston_506$median),]\nt0 &lt;- exp(predict(SDEM_489, newdata = nd, listw = lw_q,\n                  pred.type = \"TS\", zero.policy  =TRUE))\nsuppressWarnings(t1 &lt;- exp(predict(SDEM_489, newdata = nd,\n                                    listw = lw_q,\n                                    pred.type = \"KP2\",\n                                    zero.policy = TRUE)))\nsuppressWarnings(t2 &lt;- exp(predict(SDEM_489, newdata = nd,\n                                    listw = lw_q,\n                                    pred.type = \"KP5\",\n                                    zero.policy = TRUE)))\n\nINLA 패키지의 \"slm\" 모형을 사용하면 모형 적합 함수 호출 과정에서 누락된 반응변수 값을 함께 예측할 수 있다. 다만 \"slm\" 모형은 아직 실험적 단계이므로 약간의 설정 코드가 필요하다.\n\nlibrary(INLA)\n# Loading required package: foreach\n# Loading required package: parallel\n# Loading required package: sp\n# This is INLA_23.04.24 built 2023-04-24 19:15:35 UTC.\n#  - See www.r-inla.org/contact-us for how to get help.\n#  - To enable PARDISO sparse library; see inla.pardiso()\n# \n# Attaching package: 'INLA'\n# The following object is masked _by_ '.GlobalEnv':\n# \n#     f\nW &lt;- as(lw_q, \"CsparseMatrix\")\nn &lt;- nrow(W)\ne &lt;- eigenw(lw_q)\nre.idx &lt;- which(abs(Im(e)) &lt; 1e-6)\nrho.max &lt;- 1 / max(Re(e[re.idx]))\nrho.min &lt;- 1 / min(Re(e[re.idx]))\nrho &lt;- mean(c(rho.min, rho.max))\nboston_506$idx &lt;- 1:n\nzero.variance = list(prec = list(initial = 25, fixed = TRUE))\nargs.slm &lt;- list(rho.min = rho.min, rho.max = rho.max, W = W,\n                 X = matrix(0, n, 0), Q.beta = matrix(1,0,0))\nhyper.slm &lt;- list(prec = list(prior = \"loggamma\", \n                              param = c(0.01, 0.01)),\n                  rho = list(initial = 0, prior = \"logitbeta\",\n                             param = c(1,1)))\nWX &lt;- create_WX(model.matrix(update(form, CMEDV ~ .), \n                             data = boston_506), lw_q)\nSDEM_506_slm &lt;- inla(update(form, \n                            . ~ . + WX + f(idx, model = \"slm\",\n                                         args.slm = args.slm,\n                                         hyper = hyper.slm)),\n                 data = boston_506, family = \"gaussian\",\n                 control.family = list(hyper = zero.variance),\n                 control.compute = list(dic = TRUE, cpo = TRUE))\nmv_mean &lt;- exp(SDEM_506_slm$summary.fitted.values$mean[\n               which(is.na(boston_506$median))])\n\nINLA 패키지는 예측값에 대한 주변분포(marginal distribution)의 격자형 추정치를 제공하며, 이를 통해 예측값에 내재된 불확실성을 평가할 수 있다.(역자주: 여기서 ’예측값에 대한 주변분포’란 각 예측값이 가질 수 있는 불확실성을 나타내는 확률분포를 말한다. INLA 패키지는 이를 일정 간격의 격자점에서 계산하여 근사하는 방식을 사용하며, 이를 통해 예측값의 신뢰구간이나 변동 범위를 평가할 수 있다.)\n\ndata.frame(fit_TS = t0[,1], fit_KP2 = c(t1), fit_KP5 = c(t2),\n    INLA_slm = mv_mean, censored = \n      boston_506$censored[as.integer(attr(t0, \"region.id\"))])\n#     fit_TS fit_KP2 fit_KP5 INLA_slm censored\n# 13   23912   29477   28147    31112    right\n# 14   28126   27001   28516    31314    right\n# 15   30553   36184   32476    41298    right\n# 17   18518   19621   18878    21160    right\n# 43    9564    6817    7561     6830     left\n# 50    8371    7196    7383     6885     left\n# 312  51477   53301   54173    56274    right\n# 313  45921   45823   47095    46447    right\n# 314  44196   44586   45361    42805    right\n# 317  43427   45707   45442    48025    right\n# 337  39879   42072   41127    41462    right\n# 346  44708   46694   46108    45847    right\n# 355  48188   49068   48911    49138    right\n# 376  42881   45883   44966    47747    right\n# 408  44294   44615   45670    46164    right\n# 418  38211   43375   41914    43913    right\n# 434  41647   41690   42398    41551    right\n\n공간적 회귀분석을 위한 도구 모음은 여전히 완전하지 않으며, 그 빈틈을 메우는 데는 시간이 필요하다. 여러 공간적 회귀분석 전통 간에 이해와 발전을 거의 공유하지 않는 점은 여전히 아쉬운 부분이다.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>공간계량경제학적 모형</span>"
    ]
  },
  {
    "objectID": "17.html#연습문제",
    "href": "17.html#연습문제",
    "title": "17  공간계량경제학적 모형",
    "section": "\n17.5 연습문제",
    "text": "17.5 연습문제\n\nPiras와 Prucha(2014), 그리고 Raymond J. G. M. Florax, Folmer과 Rey(2003)를 참조하여, 사전 테스트 전략을 선택했을 때, 속성만 포함된 데이터셋과 지자체 구역 변수를 추가한 속성 데이터셋의 선형모형에서 잔차의 공간적 의존성이 나타나는지 답하시오. 사전 테스트가 어떤 모형을 지목하는지에 대해 답하시오.\n자치구역 더미 변수를 포함하거나 자치구역 레짐(regime) 모형을 실행하는 것이 잔차의 공간적 의존성을 줄이는 데 도움이 될 수 있는지에 대해 답하시오.\n속성만 포함한 모형과 자치구역 변수를 추가한 모형에 대해 MLE를 사용하여 SEM 모형을 실행하시오(GMM 코드 예시는 Bivand, Millo와 Piras(2021)를 참조). 이어서 SDEM 모형으로 확장하시오. 또한 SLX 모형을 실행하고, 해당 모형의 잔차에 대한 공간적 자기상관 검정 결과를 해석하시오. SEM과 SDEM 모형에 대한 Hausman 검정에서 나타난 매우 높은 유의성을 해석하시오.\n속성만 포함한 모형과 자치구역 변수를 추가한 모형에 대해 GNM 모형을 실행하시오. 이러한 모형을 SDM 또는 SDEM 형식으로 단순화할 수 있는지에 대해 답하시오.\n16장 연습문제에서 얻은 모형 추정 결과가 이 장의 결과보다 더 명확한 통찰을 제공하는지에 대해 답하시오.",
    "crumbs": [
      "공간통계분석과 공간모델링",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>공간계량경제학적 모형</span>"
    ]
  },
  {
    "objectID": "A.html",
    "href": "A.html",
    "title": "부록 A — 예전 R 공간 패키지",
    "section": "",
    "text": "rgdal과 rgeos 패키지의 퇴역\nsf와 stars와 같은 최신 패키지가 등장하기 전부터 R을 사용해 온 오랜 사용자라면, maptools, sp, rgeos, rgdal과 같은 오래된 공간 패키지에 더 익숙할 것이다. 그렇다면, 기존 코드나 이들 패키지에 의존하는 다른 R 패키지를 갱신해야 할 필요가 있는지 궁금할 것이다. 그에 대한 대답은 간단하다. “그렇다.”\nmaptools, rgdal, rgeos 패키지는 2023년에 퇴역했다. 여기서 ’퇴역’이란 더 이상 유지 보수가 이뤄지지 않고, 그 결과로 CRAN에서 해당 패키지가 아카이브로 전환되는 것을 의미한다. 다만 R-Forge가 유지되는 한, 소스 코드 저장소 자체는 계속 남아 있을 것이다. 퇴역의 한 가지 이유는 관리자의 은퇴이며, 더 중요한 이유는 이들 패키지의 기능이 이미 새로운 패키지들로 대체되었기 때문이다. 새로운 관리자가 R-Forge 저장소를 인수할 가능성은 매우 낮다. 이는 GEOS, GDAL, PROJ 라이브러리의 발전과 함께 패키지 코드가 점진적으로 변화해 왔고, 많은 부분이 오래된 구조를 포함해 유지와 이해가 어렵기 때문이다.\nrgeos와 rgdal 패키지의 퇴역과 함께, sp 패키지가 이들과 맺고 있던 기존 연결성은 sf 패키지와의 연결로 대체되었다. 여기에는 예를 들어 좌표참조계(CRS) 식별자의 검증이나, 링이 내부 홀인지 외부 링인지 확인하는 작업 등이 포함된다. maptools 패키지에서 선택된 일부 함수도 sp 패키지로 이전되었다.",
    "crumbs": [
      "부록",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>예전 R 공간 패키지</span>"
    ]
  },
  {
    "objectID": "A.html#sf와-sp-패키지의-연결성-및-차별성",
    "href": "A.html#sf와-sp-패키지의-연결성-및-차별성",
    "title": "부록 A — 예전 R 공간 패키지",
    "section": "sf와 sp 패키지의 연결성 및 차별성",
    "text": "sf와 sp 패키지의 연결성 및 차별성\nsf와 sp 패키지는 여러 측면에서 차이를 보인다. 가장 두드러진 차이는 sp 클래스가 엄격한 S4 클래스를 사용하는 반면, sf는 보다 유연한 S3 클래스 계층을 사용한다는 점이다. sf 객체는 data.frame 또는 tibble에서 파생되므로, 기존 R 생태계, 특히 tidyverse 계열 패키지와의 연동이 용이하다. sf 객체는 기하 데이터를 리스트-컬럼(list-column)에 저장하며, 이로 인해 기하 데이터가 항상 리스트 요소 형태로 유지된다. 반면, sp 패키지는 데이터 구조를 덜 엄격하게 설계하여, 예를 들어 SpatialPoints나 SpatialPixels의 모든 좌표를 행렬 형태로 저장한다. 이러한 방식은 리스트-컬럼으로는 구현할 수 없지만, 특정 문제에서는 더 나은 성능을 제공한다. sf 객체 x를 sp 객체로 변환하려면 다음과 같이 수행한다.\n\nlibrary(sp)\ny = as(x, \"Spatial\")\n\n그리고, 반대로 sp 객체를 sf 객체로 변환하려면 다음과 같이 한다.\n\nx0 = st_as_sf(y)\n\n이러한 변환에는 몇 가지 제약이 있다.\n\nsp는 LINESTRING과 MULTILINESTRING, 또는 POLYGON과 MULTIPOLYGON 지오메트리를 구분하지 않는다. 예를 들어, LINESTRING을 sp로 변환한 후 다시 sf로 변환하면 MULTILINESTRING으로 반환된다.\nsp는 GEOMETRYCOLLECTION를 지원하지 않으며, ‘빅 세븐’ (3.1.1절) 범주에 포함되지 않는 지오메트리를를 표현할 구조가 없다.\n혼합된 지오메트리를 포함한 GEOMETRY 유형의 sf 또는 sfc 객체는 sp 객체로 변환할 수 없다.\n속성-지오메트리 관계 속성은 sp로 변환 시 손실된다.\n두 개 이상의 지오메트리 리스트-컬럼을 가진 sf 객체는 sp로 변환 시 부차적인 리스트-컬럼이 삭제된다.",
    "crumbs": [
      "부록",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>예전 R 공간 패키지</span>"
    ]
  },
  {
    "objectID": "A.html#코드와-패키지-마이그레이션",
    "href": "A.html#코드와-패키지-마이그레이션",
    "title": "부록 A — 예전 R 공간 패키지",
    "section": "코드와 패키지 마이그레이션",
    "text": "코드와 패키지 마이그레이션\nsf의 GitHub 위키 페이지(https://github.com/r-spatial/sf/wiki/Migrating)에는 rgeos, rgdal, sp의 메서드 및 함수와 그에 데응하는 sf 메서드 및 함수의 목록이 정리되어 있다. 이 자료는 기존 코드나 패키지를 sf로 전환할 때 유용하다.\n가장 간단한 마이그래이션 사례는 rgdal 패키지의 readOGR() 함수만으로 파일을 읽던 코드를 sf 패키지의 read_sf() 함수로 바꾸는 것이다. 기존 코드가 sp 클래스를 기대한다면, sf로 읽은 뒤 sp로 변환하는 방식이 편리하다.(역자주: 여기서 ’마이그레이션(migration)’은 기존 시스템이나 환경에서 새로운 시스템이나 환경으로 코드나 데이터를 이전 및 전환하는 과정을 의미한다. 여기서는 구 버전 R 공간 패키지에서 최신 패키지로 코드를 옮기고 호환성을 확보하는 과정을 가리킨다.)\n\nx = as(sf::read_sf(\"file\"), \"Spatial\")\n\n다만 readOGR() 함수를 계속 사용할 경우에는 아규먼트를 더 주의해서 다뤄야 한다. 현재 우리는 rgdal, rgeos, maptools 없이, 가능하면 sp 없이도 전반이 동작하도록 과거 도서 ’R을 활용한 응용 공간데이터분석(Applied Spatial Data Analysis with R)’(Virgilio Gómez-Rubio, Bivand, Pebesma, Gómez-Rubio, 2013)의 모든 코드를 변환하는 작업을 진행 중이다. 관련 스크립트는 다음에서 확인할 수 있다. https://github.com/rsbivand/sf_asdar2ed",
    "crumbs": [
      "부록",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>예전 R 공간 패키지</span>"
    ]
  },
  {
    "objectID": "A.html#raster와-terra-패키지",
    "href": "A.html#raster와-terra-패키지",
    "title": "부록 A — 예전 R 공간 패키지",
    "section": "raster와 terra 패키지",
    "text": "raster와 terra 패키지\nraster 패키지는 2010년부터 R에서 래스터 데이터 분석의 핵심 도구로 사용되어 왔으면, 이후 ‘공간데이터분석과 모델링(Geographic Data Analysis and Modeling)’(Hijmans 2023a) 패키지로 발전하여 다양한 공간데이터 처리에 활용되었다. raster 패키지는 벡터 데이터를 처리를 위해 sp 객체를 사용하고, GDAL 라이브러리 형식의 데이터 입출력시 terra를 활용한다. 후속 패키지인 terra는 ‘공간데이터분석(Spatial Data Analysis)’(Hijmans 2023b)을 위한 도구로, “raster 패키지와 매우 유사하지만 […] 더 많은 기능을 제공하며, 사용하기 쉽고, […] 더 빠르다.” terra 패키지는 벡터 데이터용 자체 클래스를 제공하면서도 대부분의 sf 객체를 받아들인다. 다만, 위에서 언급한 sp 변환 시와 유사한 제약이 적용된다. 또한 terra 패키지는 GDAL, GEOS, PROJ와 직접 연결 되므로 별도의 패키지가 필요 없다.\nraster 또는 terra 패키지의 래스터 레이어나 래스터 스택은 st_as_stars() 함수를 사용해 stars 객체로 변환할 수 있다. terra의 SpatVector 객체는 sf의 st_as_sf() 함수를 통해 를 변환할 수 있다.\n로버트 히즈먼(Robert Hijmans)이 저술한 온라인 저서 ’R과 terra를 활용한 공간데이터사이언스(Spatial Data Science with R and “terra”)’(https://rspatial.org/terra)에서는 terra를 활용한 공간데이터분석 방법을 자세히 다룬다. sf, stars 및 이 책에서 다루는 여러 r-spatial 패키지는 r-spatial GitHub 조직에 속해 있으며(여기서 r과 spatial 사이에는 하이픈이 있다. 히즈먼의 조직에는 하이픈이 없음). 해당 조직 블로그(https://r-spatial.org/book) 에서 책 링크를 확인할 수 있다.\nsf, stars, terra 패키지는 공통의 목표를 공유하고 있지만 접근 방식에서 차이를 보인다. 데이터 분석, 소프트웨어 엔지니어링, 커뮤니티 운영에 대한 강조점이 서로 달라 일부 사용자에게 혼란을 줄 수 있지만, 이러한 다양성은 R 패키지 생태계를 더욱 풍부하게 만들고 선택지를 확장한다. 이느 사용자가 R로 공간데이터를 다루는 과정에서 새로운 시도를 이어가도록 장려하며, 궁극적으로 R spatial의 발전과 확신에 기여한다.",
    "crumbs": [
      "부록",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>예전 R 공간 패키지</span>"
    ]
  },
  {
    "objectID": "B.html",
    "href": "B.html",
    "title": "부록 B — R 기초",
    "section": "",
    "text": "파이프 오퍼레이터\n|&gt; (파이프) 기호는 ’그렇다면’이라고 읽으면 이해하기 쉽다.\na |&gt; b() |&gt; c() |&gt; d(n = 10)\n위의 코드는 a를 b() 함수에 전달한 후, 결과를 c() 함수에 전달하고, 다시 d() 함수에 전달하며, 마지막 호출에서 n = 10을 지정하는 것과 같다. 즉, 다음과 동일하다.\nd(c(b(a)), n = 10)\n혹은 중간 결과를 변수에 담아 다음과 같이 쓸 수도 있다.\ntmp1 &lt;- b(a)\ntmp2 &lt;- c(tmp1)\ntmp3 &lt;- d(tmp2, n = 10)\n많은 사람들은 이러한 파이프 형태가 실행 순서가 읽는 순서(왼쪽에서 오른쪽)를 따르기 때문에 읽기 쉽다고 생각한다. 중첩 함수 호출과 마찬가지로, 중간 결과에 이름을 붙일 필요가 없다. 그러나 중첩 함수 호출과 마찬가지로, 예상과 다른 중간 결과를 디버그하기는 어렵다. 또한 중간 결과는 메모리에 존재하므로, 어느 방식도 메모리 할당을 절약하지 못한다는 점에 유의해야 한다. 이 책에서 사용하는 R 4.1.0에 도입된 네이티브 파이프(|&gt;)는 magrittr 패키지의 %&gt;% 파이프로 안전하게 대체할 수 있다.",
    "crumbs": [
      "부록",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>R 기초</span>"
    ]
  },
  {
    "objectID": "B.html#데이터-구조",
    "href": "B.html#데이터-구조",
    "title": "부록 B — R 기초",
    "section": "데이터 구조",
    "text": "데이터 구조\nChambers (2016)가 언급했듯이, “R에서 존재하는 모든 것은 객체”이다. 여기에는 데이터 객체뿐 아니라 언어 객체나 함수와 같이 특수 객체도 포함된다. 이 절에서는 R의 기본 데이터 구조를 살펴본다.\n동질 벡터\n데이터 객체는 데이터를 포함하며, 경우에 따라 메타데이터도 가진다. 데이터는 항상 벡터 형태이며, 벡터는 하나의 유형만 가질 수 있다. 유형은 typeof() 함수로 확인하고, 길이는 length() 함수로 확인한다. 벡터는 c() 함수로 생성한다.\n\ntypeof(1:10)\n# [1] \"integer\"\nlength(1:10)\n# [1] 10\ntypeof(1.0)\n# [1] \"double\"\nlength(1.0)\n# [1] 1\ntypeof(c(\"foo\", \"bar\"))\n# [1] \"character\"\nlength(c(\"foo\", \"bar\"))\n# [1] 2\ntypeof(c(TRUE, FALSE))\n# [1] \"logical\"\n\n이런 종류의 벡터를 동질(homogeneous) 벡터라고 부르는데, 이는 한 가지 유형의 데이터만을 포함할 수 있기 때문이다.\n또한 벡터는 길이가 0일 수도 있다는 점에 유의해야 한다.\n\ni &lt;- integer(0)\ntypeof(i)\n# [1] \"integer\"\ni\n# integer(0)\nlength(i)\n# [1] 0\n\n벡터의 요소는 [] 혹은 [[]]를 사용하여 추출할 수 있으며, 할당 구문에서는 해당 요소를 다른 값으로 대체할 수도 있다.\n\na &lt;- c(1,2,3)\na[2]\n# [1] 2\na[[2]]\n# [1] 2\na[2:3]\n# [1] 2 3\na[2:3] &lt;- c(5,6)\na\n# [1] 1 5 6\na[[3]] &lt;- 10\na\n# [1]  1  5 10\n\n차이점은 []는 인덱스 범위(또는 복수 인덱스)에 대해 작업할 수 있는 반면, [[]]는 단일 벡터 요소에만 접근한다는 점이다.\n이질 벡터: list\n\n두 번째 벡터 유형은 list로, 서로 다른 유형의 데이터를 함께 담을 수 있다는 점에서 이질(heterogeneous) 벡터라고 불린다.\n\nl &lt;- list(3, TRUE, \"foo\")\ntypeof(l)\n# [1] \"list\"\nlength(l)\n# [1] 3\n\n리스트에서 []와 [[]]는 추가적인 차이가 있다. []는 항상 리스트 자체를 반환하는 반면, [[]]는 해당 리스트 요소의 내용을 반환한다.\n\nl[1]\n# [[1]]\n# [1] 3\nl[[1]]\n# [1] 3\n\n교체를 수행할 때, 리스트를 지정할 경우에는 []를 사용하고, 새로운 값을 지정할 경우에는 [[]]를 사용한다.\n\nl[1:2] &lt;- list(4, FALSE)\nl\n# [[1]]\n# [1] 4\n# \n# [[2]]\n# [1] FALSE\n# \n# [[3]]\n# [1] \"foo\"\nl[[3]] &lt;- \"bar\"\nl\n# [[1]]\n# [1] 4\n# \n# [[2]]\n# [1] FALSE\n# \n# [[3]]\n# [1] \"bar\"\n\n리스트의 각 요소에 이름을 부여할 수 있다.\n\nl &lt;- list(first = 3, second = TRUE, third = \"foo\")\nl\n# $first\n# [1] 3\n# \n# $second\n# [1] TRUE\n# \n# $third\n# [1] \"foo\"\n\nl[[\"second\"]]처럼 이름을 사용하거나, 더 간단한 표기법을 사용할 수도 있다.\n\nl$second\n# [1] TRUE\nl$second &lt;- FALSE\nl\n# $first\n# [1] 3\n# \n# $second\n# [1] FALSE\n# \n# $third\n# [1] \"foo\"\n\n이름을 사용하는 것은 편리해 보일 수 있지만, 먼저 이름 속성에서 이름을 찾아야 한다는 점에 유의해야 한다(아래 참조).\nNULL과 리스트 요소의 제거\nNULL은 R에서 널(null) 값을 표현하는 방식이다. 단순 비교에서는 직관적이지 않은 결과가 나올 수 있으므로 주의해야 한다.\n\n3 == NULL # not FALSE!\n# logical(0)\nNULL == NULL # not even TRUE!\n# logical(0)\n\n따라서 NULL은 특별히 취급할 필요가 있으며, 이를 확인할 때는 is.null() 함수가 유용하다.\n\nis.null(NULL)\n# [1] TRUE\n\n리스트에서 특정 요소를 제거하려면, 해당 요소를 제외한 새로운 리스트를 만들면 된다.\n\nl &lt;- l[c(1,3)] # remove second, implicitly\nl\n# $first\n# [1] 3\n# \n# $third\n# [1] \"foo\"\n\n또는, 제거하려는 요소에 NULL을 할당하는 방법도 있다.\n\nl$second &lt;- NULL\nl\n# $first\n# [1] 3\n# \n# $third\n# [1] \"foo\"\n\n속성\n예를 들어, 임의의 메타데이터 객체를 데이터 객체에 결합할 수 있다.\n\na &lt;- 1:3\nattr(a, \"some_meta_data\") = \"foo\"\na\n# [1] 1 2 3\n# attr(,\"some_meta_data\")\n# [1] \"foo\"\n\n이 메타데이터는 조회하거나 다른 값으로 교체할 수 있다.\n\nattr(a, \"some_meta_data\")\n# [1] \"foo\"\nattr(a, \"some_meta_data\") &lt;- \"bar\"\nattr(a, \"some_meta_data\")\n# [1] \"bar\"\n\n본질적으로 객체의 속성은 이름이 지정된 리스트이며, 전체 리스트를 다음과 같이 불러오거나 설정할 수 있다.\n\nattributes(a)\n# $some_meta_data\n# [1] \"bar\"\nattributes(a) = list(some_meta_data = \"foo\")\nattributes(a)\n# $some_meta_data\n# [1] \"foo\"\n\nR은 여러 속성을 특별하게 취급하며, 전체 내용은 ?attributes에서 확인할 수 있다. 이제 몇 가지 주요 속성에 대해 살펴보자.\n객체 클래스와 class 속성\nR의 모든 객체는 “클래스를 가진다.” class(obj)는 obj의 클래스명을 담은 문자 벡터를 반환한다. 일부 객체는 기본 벡터처럼 암시적 클래스를 가진다.\n\nclass(1:3)\n# [1] \"integer\"\nclass(c(TRUE, FALSE))\n# [1] \"logical\"\nclass(c(\"TRUE\", \"FALSE\"))\n# [1] \"character\"\n\n클래스는 명시적으로 설정할 수도 있다. 이를 위해 attr() 함수를 사용하거나, 표현식의 왼쪽에 class를 배치하여 지정할 수 있다.\n\na &lt;- 1:3\nclass(a) &lt;- \"foo\"\na\n# [1] 1 2 3\n# attr(,\"class\")\n# [1] \"foo\"\nclass(a)\n# [1] \"foo\"\nattributes(a)\n# $class\n# [1] \"foo\"\n\n이 경우 새로 지정된 클래스가 기존의 암시적 클래스를 덮어쓴다. 이렇게 하면 메서드 이름에 클래스 이름을 덧붙여 foo 클래스용 메서드를 정의할 수 있다.\n\nprint.foo &lt;- function(x, ...) { \n    print(paste(\"an object of class foo with length\", length(x)))\n}\nprint(a)\n# [1] \"an object of class foo with length 3\"\n\n이러한 메서드를 제공하는 목적은 일반적으로 소프트웨어를 더 쉽게 사용할 수 있도록 하는 것이지만, 동시에 객체를 더 불투명하게 만들 수도 있다. 따라서 클래스 속성을 제거한 후 객체를 출력해 “무엇으로 구성되어 있는지” 확인하는 것이 유용하다.\n\nunclass(a)\n# [1] 1 2 3\n\n좀 더 구체적인 예로, sf 패키지를 사용해 폴리곤을 생성하는 경우를 생각해보자.\n\nlibrary(sf) |&gt; suppressPackageStartupMessages()\np &lt;- st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,0))))\np\n# POLYGON ((0 0, 1 0, 1 1, 0 0))\n\n이는 WKT(well-known-text) 형식으로 출력된다. 데이터 구조를 확인하려면 다음과 같이 하면 된다.\n\nunclass(p)\n# [[1]]\n#      [,1] [,2]\n# [1,]    0    0\n# [2,]    1    0\n# [3,]    1    1\n# [4,]    0    0\n\n\ndim 속성\ndim 속성은 행렬이나 어레이(array)의 차원을 설정한다.\n\na &lt;- 1:8\nclass(a)\n# [1] \"integer\"\nattr(a, \"dim\") &lt;- c(2,4) # or: dim(a) = c(2,4)\nclass(a)\n# [1] \"matrix\" \"array\"\na\n#      [,1] [,2] [,3] [,4]\n# [1,]    1    3    5    7\n# [2,]    2    4    6    8\nattr(a, \"dim\") &lt;- c(2,2,2) # or: dim(a) = c(2,2,2)\nclass(a)\n# [1] \"array\"\na\n# , , 1\n# \n#      [,1] [,2]\n# [1,]    1    3\n# [2,]    2    4\n# \n# , , 2\n# \n#      [,1] [,2]\n# [1,]    5    7\n# [2,]    6    8\n\n\nnames 속성\n이름이 지정된 벡터는 names 속성에 해당 이름을 저장한다. 위에서는 리스트 예시를 보았고, 숫자 벡터의 예시는 다음과 같다.\n\na &lt;- c(first = 3, second = 4, last = 5)\na[\"second\"]\n# second \n#      4\nattributes(a)\n# $names\n# [1] \"first\"  \"second\" \"last\"\n\n다른 이름 속성으로는 행렬이나 어레이의 dimnames가 있다. 이 속성은 차원의 이름뿐 아니라, 각 차원에 연결된 값의 레이블도 지정한다.\n\na &lt;- matrix(1:4, 2, 2)\ndimnames(a) &lt;- list(rows = c(\"row1\", \"row2\"),\n                    cols = c(\"col1\", \"col2\"))\na\n#       cols\n# rows   col1 col2\n#   row1    1    3\n#   row2    2    4\nattributes(a)\n# $dim\n# [1] 2 2\n# \n# $dimnames\n# $dimnames$rows\n# [1] \"row1\" \"row2\"\n# \n# $dimnames$cols\n# [1] \"col1\" \"col2\"\n\ndata.frame 객체는 행과 열을 가지며, 각각의 행과 열에는 이름이 지정되어 있다.\n\ndf &lt;- data.frame(a = 1:3, b = c(TRUE, FALSE, TRUE))\nattributes(df)\n# $names\n# [1] \"a\" \"b\"\n# \n# $class\n# [1] \"data.frame\"\n# \n# $row.names\n# [1] 1 2 3\n\n\nstructure의 사용\n프로그래밍 시, 객체를 반환하기 전에 속성을 추가하거나 수정하는 패턴은 매우 흔하다. 예를 들어 다음과 같다.\n\nf &lt;- function(x) {\n   a &lt;- create_obj(x) # call some other function\n   attributes(a) &lt;- list(class = \"foo\", meta = 33)\n   a\n}\n\n마지막 두 문장은 다음과 같이 축약할 수 있다.\n\nf &lt;- function(x) {\n   a &lt;- create_obj(x) # call some other function\n   structure(a, class = \"foo\", meta = 33)\n}\n\n여기서 structure() 함수는 첫 번째 아규먼트로 받은 객체의 속성을 추가하거나 교체하고, 값이 NULL이면 해당 속성을 제거한다.",
    "crumbs": [
      "부록",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>R 기초</span>"
    ]
  },
  {
    "objectID": "B.html#multipolygon-객체-분할하기",
    "href": "B.html#multipolygon-객체-분할하기",
    "title": "부록 B — R 기초",
    "section": "\nMULTIPOLYGON 객체 분할하기",
    "text": "MULTIPOLYGON 객체 분할하기\nMULTIPOLYGON이 포함된 sf 객체는 여러 개의 개별 조각으로 분리할 수 있다. 예를 들어, 위의 예시와 같이 nc 데이터셋을 사용한다고 가정해 보자.\n\nsystem.file(\"gpkg/nc.gpkg\", package = \"sf\") |&gt; \n    read_sf() -&gt; nc\n\nnc 객체의 속성을 확인하면 다음과 같은 내용을 볼 수 있다.\n\nattributes(nc)\n# $names\n#  [1] \"AREA\"      \"PERIMETER\" \"CNTY_\"     \"CNTY_ID\"   \"NAME\"     \n#  [6] \"FIPS\"      \"FIPSNO\"    \"CRESS_ID\"  \"BIR74\"     \"SID74\"    \n# [11] \"NWBIR74\"   \"BIR79\"     \"SID79\"     \"NWBIR79\"   \"geom\"     \n# \n# $row.names\n#   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n#  [16]  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30\n#  [31]  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45\n#  [46]  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60\n#  [61]  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75\n#  [76]  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n#  [91]  91  92  93  94  95  96  97  98  99 100\n# \n# $class\n# [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n# \n# $sf_column\n# [1] \"geom\"\n# \n# $agr\n#      AREA PERIMETER     CNTY_   CNTY_ID      NAME      FIPS \n#      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt; \n#    FIPSNO  CRESS_ID     BIR74     SID74   NWBIR74     BIR79 \n#      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt;      &lt;NA&gt; \n#     SID79   NWBIR79 \n#      &lt;NA&gt;      &lt;NA&gt; \n# Levels: constant aggregate identity\n\ngeom이라는 이름의 지오메트리 컬럼이 있음을 확인할 수 있으며, 이 컬럼만 추출할 수 있다.\n\nnc$geom\n# Geometry set for 100 features \n# Geometry type: MULTIPOLYGON\n# Dimension:     XY\n# Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6\n# Geodetic CRS:  NAD27\n# First 5 geometries:\n# MULTIPOLYGON (((-81.5 36.2, -81.5 36.3, -81.6 3...\n# MULTIPOLYGON (((-81.2 36.4, -81.2 36.4, -81.3 3...\n# MULTIPOLYGON (((-80.5 36.2, -80.5 36.3, -80.5 3...\n# MULTIPOLYGON (((-76 36.3, -76 36.3, -76 36.3, -...\n# MULTIPOLYGON (((-77.2 36.2, -77.2 36.2, -77.3 3...\n\n해당 컬럼만 포함된 객체가 다음과 같은 속성을 가지고 있음을 확인할 수 있다.\n\nattributes(nc$geom)\n# $n_empty\n# [1] 0\n# \n# $crs\n# Coordinate Reference System:\n#   User input: NAD27 \n#   wkt:\n# GEOGCRS[\"NAD27\",\n#     DATUM[\"North American Datum 1927\",\n#         ELLIPSOID[\"Clarke 1866\",6378206.4,294.978698213898,\n#             LENGTHUNIT[\"metre\",1]]],\n#     PRIMEM[\"Greenwich\",0,\n#         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#     CS[ellipsoidal,2],\n#         AXIS[\"geodetic latitude (Lat)\",north,\n#             ORDER[1],\n#             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#         AXIS[\"geodetic longitude (Lon)\",east,\n#             ORDER[2],\n#             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#     USAGE[\n#         SCOPE[\"Geodesy.\"],\n#         AREA[\"North and central America: Antigua and Barbuda - onshore. Bahamas - onshore plus offshore over internal continental shelf only. Belize - onshore. British Virgin Islands - onshore. Canada onshore - Alberta, British Columbia, Manitoba, New Brunswick, Newfoundland and Labrador, Northwest Territories, Nova Scotia, Nunavut, Ontario, Prince Edward Island, Quebec, Saskatchewan and Yukon - plus offshore east coast. Cuba - onshore and offshore. El Salvador - onshore. Guatemala - onshore. Honduras - onshore. Panama - onshore. Puerto Rico - onshore. Mexico - onshore plus offshore east coast. Nicaragua - onshore. United States (USA) onshore and offshore - Alabama, Alaska, Arizona, Arkansas, California, Colorado, Connecticut, Delaware, Florida, Georgia, Idaho, Illinois, Indiana, Iowa, Kansas, Kentucky, Louisiana, Maine, Maryland, Massachusetts, Michigan, Minnesota, Mississippi, Missouri, Montana, Nebraska, Nevada, New Hampshire, New Jersey, New Mexico, New York, North Carolina, North Dakota, Ohio, Oklahoma, Oregon, Pennsylvania, Rhode Island, South Carolina, South Dakota, Tennessee, Texas, Utah, Vermont, Virginia, Washington, West Virginia, Wisconsin and Wyoming - plus offshore . US Virgin Islands - onshore.\"],\n#         BBOX[7.15,167.65,83.17,-47.74]],\n#     ID[\"EPSG\",4267]]\n# \n# $class\n# [1] \"sfc_MULTIPOLYGON\" \"sfc\"             \n# \n# $precision\n# [1] 0\n# \n# $bbox\n#  xmin  ymin  xmax  ymax \n# -84.3  33.9 -75.5  36.6\n\n네 번째 리스트 요소의 내용을 불러온다.\n\nnc$geom[[4]] |&gt; format(width = 60, digits = 5)\n# [1] \"MULTIPOLYGON (((-76.009 36.32, -76.017 36.338, -76.033 36...\"\n\n해당 객체의 클래스가 리스트임을 확인한다.\n\ntypeof(nc$geom[[4]])\n# [1] \"list\"\n\n해당 객체의 속성을 확인한다.\n\nattributes(nc$geom[[4]])\n# $class\n# [1] \"XY\"           \"MULTIPOLYGON\" \"sfg\"\n\n그리고 length를 확인한다.\n\nlength(nc$geom[[4]])\n# [1] 3\n\n길이 속성은 외부 링의 개수를 나타낸다. 멀티폴리곤은 하나 이상의 폴리곤으로 구성될 수 있으며, 대부분의 카운티는 하나의 폴리곤만 가지고 있음을 알 수 있다.\n\nlengths(nc$geom)\n#   [1] 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n#  [32] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 2 1 1 1 1 1\n#  [63] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 2 1 1\n#  [94] 1 2 1 1 1 1 1\n\n멀티폴리곤은 여러 폴리곤으로 구성된 리스트이다.\n\ntypeof(nc$geom[[4]])\n# [1] \"list\"\n\n네 번째 멀티폴리곤의 첫 번째 폴리곤 역시 리스트인데, 이는 폴리곤이 외부 링을 포함하고 그 뒤에 하나 이상의 내부 링(구멍)이 올 수 있기 때문이다.\n\ntypeof(nc$geom[[4]][[1]])\n# [1] \"list\"\n\n해당 폴리곤이 외부 링 하나만 가지고 있음을 확인할 수 있다.\n\nlength(nc$geom[[4]][[1]])\n# [1] 1\n\n해당 폴리곤의 유형, 차원, 그리고 첫 번째 좌표 집합은 다음과 같이 출력할 수 있다.\n\ntypeof(nc$geom[[4]][[1]][[1]])\n# [1] \"double\"\ndim(nc$geom[[4]][[1]][[1]])\n# [1] 26  2\nhead(nc$geom[[4]][[1]][[1]])\n#       [,1] [,2]\n# [1,] -76.0 36.3\n# [2,] -76.0 36.3\n# [3,] -76.0 36.3\n# [4,] -76.0 36.4\n# [5,] -76.1 36.3\n# [6,] -76.2 36.4\n\n속성은 변경 가능하다. 예를 들어, 세 번째 좌표의 위도 값을 다음과 같이 수정할 수 있다.\n\nnc$geom[[4]][[1]][[1]][3,2] &lt;- 36.5",
    "crumbs": [
      "부록",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>R 기초</span>"
    ]
  }
]