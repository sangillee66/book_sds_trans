<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>공간데이터사이언스 개론 - 5&nbsp; 속성과 서포트</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./06.html" rel="next">
<link href="./04.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script><link rel="stylesheet" href="styles.css">
</head>
<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <a class="flex-grow-1 no-decor" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="사이드바 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
          <h1 class="quarto-secondary-nav-title"><span id="sec-attribute" class="quarto-section-identifier"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">속성과 서포트</span></span></h1>
        </a>     
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">공간데이터사이언스 개론</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/sangillee66/book_sds_trans" title="소스 코드" class="quarto-navigation-tool px-1" aria-label="소스 코드"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="검색"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">서장</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">공간데이터</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">시작하기</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">좌표계</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">지오메트리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">구체 지오메트리</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">속성과 서포트</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">데이터 큐브</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">공간데이터사이언스와 R</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">sf와 stars</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">공간데이터의 플로팅</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">대용량 데이터와 클라우드 네이티브</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part_3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">공간통계분석과 공간모델링</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">공간데이터의 통계적 모델링</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">포인트 패턴 분석</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">공간적 인터폴레이션</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">다변량 및 시공간 지구통계학</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">근접성과 에어리어 데이터</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">공간적 자기상관 측도</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./16.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">공간적 회귀분석</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./17.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">공간계량경제학적 모델</span></span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true">
 <span class="menu-text">부록</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="true" aria-label="토글 섹션">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./A.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">R 스페셜 패키지</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./B.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">R 기초</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
      </ul>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">목차</h2>
   
  <ul>
<li><a href="#%EC%86%8D%EC%84%B1-%EC%A7%80%EC%98%A4%EB%A9%94%ED%8A%B8%EB%A6%AC-%EA%B4%80%EA%B3%84%EC%99%80-%EC%84%9C%ED%8F%AC%ED%8A%B8" id="toc-속성-지오메트리-관계와-서포트" class="nav-link active" data-scroll-target="#%EC%86%8D%EC%84%B1-%EC%A7%80%EC%98%A4%EB%A9%94%ED%8A%B8%EB%A6%AC-%EA%B4%80%EA%B3%84%EC%99%80-%EC%84%9C%ED%8F%AC%ED%8A%B8"><span class="header-section-number">5.1</span> 속성-지오메트리 관계와 서포트</a></li>
  <li><a href="#%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%EC%85%98%EA%B3%BC-%EC%84%9C%EB%A8%B8%EB%9D%BC%EC%9D%B4%EC%A6%88" id="toc-애그리게이션과-서머라이즈" class="nav-link" data-scroll-target="#%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B2%8C%EC%9D%B4%EC%85%98%EA%B3%BC-%EC%84%9C%EB%A8%B8%EB%9D%BC%EC%9D%B4%EC%A6%88"><span class="header-section-number">5.2</span> 애그리게이션과 서머라이즈</a></li>
  <li>
<a href="#%EB%A9%B4%EC%A0%81-%EA%B0%80%EC%A4%91-%EC%9D%B8%ED%84%B0%ED%8F%B4%EB%A0%88%EC%9D%B4%EC%85%98" id="toc-면적-가중-인터폴레이션" class="nav-link" data-scroll-target="#%EB%A9%B4%EC%A0%81-%EA%B0%80%EC%A4%91-%EC%9D%B8%ED%84%B0%ED%8F%B4%EB%A0%88%EC%9D%B4%EC%85%98"><span class="header-section-number">5.3</span> 면적-가중 인터폴레이션</a>
  <ul class="collapse">
<li><a href="#%EA%B3%B5%EA%B0%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%99%B8%EC%97%B0%EC%A0%81%EC%9D%B8-%EB%B3%80%EC%88%98%EC%99%80-%EA%B3%B5%EA%B0%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%82%B4%ED%8F%AC%EC%A0%81%EC%9D%B8-%EB%B3%80%EC%88%98" id="toc-공간적으로-외연적인-변수와-공간적으로-내포적인-변수" class="nav-link" data-scroll-target="#%EA%B3%B5%EA%B0%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%99%B8%EC%97%B0%EC%A0%81%EC%9D%B8-%EB%B3%80%EC%88%98%EC%99%80-%EA%B3%B5%EA%B0%84%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%82%B4%ED%8F%AC%EC%A0%81%EC%9D%B8-%EB%B3%80%EC%88%98"><span class="header-section-number">5.3.1</span> 공간적으로 외연적인 변수와 공간적으로 내포적인 변수</a></li>
  <li><a href="#%EB%8C%80%EC%8B%9C%EB%A9%94%ED%8A%B8%EB%A6%AD-%EB%A7%A4%ED%95%91" id="toc-대시메트릭-매핑" class="nav-link" data-scroll-target="#%EB%8C%80%EC%8B%9C%EB%A9%94%ED%8A%B8%EB%A6%AD-%EB%A7%A4%ED%95%91"><span class="header-section-number">5.3.2</span> 대시메트릭 매핑</a></li>
  <li><a href="#%ED%8C%8C%EC%9D%BC-%ED%8F%AC%EB%A7%B7%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%9C%ED%8F%AC%ED%8A%B8" id="toc-파일-포맷에서의-서포트" class="nav-link" data-scroll-target="#%ED%8C%8C%EC%9D%BC-%ED%8F%AC%EB%A7%B7%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%9C%ED%8F%AC%ED%8A%B8"><span class="header-section-number">5.3.3</span> 파일 포맷에서의 서포트</a></li>
  </ul>
</li>
  <li><a href="#%EC%83%81%ED%96%A5-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81%EA%B3%BC-%ED%95%98%ED%96%A5-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81" id="toc-상향-스케일링과-하향-스케일링" class="nav-link" data-scroll-target="#%EC%83%81%ED%96%A5-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81%EA%B3%BC-%ED%95%98%ED%96%A5-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81"><span class="header-section-number">5.4</span> 상향 스케일링과 하향 스케일링</a></li>
  <li><a href="#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C" id="toc-연습문제" class="nav-link" data-scroll-target="#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C"><span class="header-section-number">5.5</span> 연습문제</a></li>
  </ul><div class="toc-actions"><ul><li><a href="https://github.com/sangillee66/book_sds_trans/issues/new" class="toc-action"><i class="bi bi-github"></i>이슈 보고</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<h1 class="title d-none d-lg-block"><span id="sec-attribute" class="quarto-section-identifier"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">속성과 서포트</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">2024년 10월 16일</p>
    </div>
  </div>
    
  </div>
  


</header><p>피처 <em>속성</em>은 피처(“사물”)의 특성을 의미한다. 피처의 지오메트리 특성 그 자체는 속성으로 간주되지 않지만 어떤 속성은 지오메트리로부터 <em>도출</em>된다(예를 들어, LINESTRING의 길이나 POLYGON의 면적과 같은 속성). 그러나 많은 속성은 다음과 같은 비도출 속성이다.</p>
<ul>
<li><p>스트리트나 카운티의 이름</p></li>
<li><p>카운티의 인구수</p></li>
<li><p>도로의 유형</p></li>
<li><p>토양 유형</p></li>
<li><p>가게의 영업 개시 시간</p></li>
<li><p>동물의 체중 혹은 심박수</p></li>
<li><p>대기질 측정소의 이산화질소 농도</p></li>
</ul>
<p>어떤 경우에는 시간적 특성이 피처의 속성으로 간주될 수 있으며, 예를 들어 사람의 출생일이나 도로의 건설 연도가 이에 해당한다. 대기질과 같은 속성이 공간과 시간의 함수일 때, 시간은 기하학적 특성과 동등한 중요성을 가지는 방식으로 다루는 것이 가장 적합하다(6장에서 데이터 큐브에서와 관련하여 이러한 사항이 다루어진다).</p>
<p>심플 피처를 구현하는 공간데이터사이언스 소프트웨어는 일반적으로 피처의 기하학적 특성과 속성을 모두 포함하는 테이블 형태로 데이터를 구성한다. 이는 파이썬의 <code>Geopandas</code>, PotsgreSQL의 <code>PostGIS</code> 테이블, R의 <code>sf</code> 객체 모두에 해당된다. 3.2절에서 설명된 기하학적 오퍼레이션은 <em>오직</em> 지오메트리에만 적용되며, 경우에 따라 새로운 속성(프리디케이트, 측정, 변환)을 생성할 수 있지만, 기존 속성에는 적용되지 않는다.</p>
<p>지오메트리의 수정이 있음에도 속성 <em>값</em>이 그대로 유지되는 경우에는 서포트 문제가 발생할 수 있다. 예를 들어 카운티 폴리곤을 해당 폴리곤의 센트로이드로 대체하는 간단한 사례를 살펴보면, R 패키지 <strong>sf</strong>는 다음과 같은 경고 메시지를 출력한다.</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Warning: st_centroid assumes attributes are constant over geometries</code></pre>
</div>
</div>
<p>이러한 경고 메시지가 표출되는 이유는 데이터셋에 전체 폴리곤과 연관된 값(역자주: 폴리곤 내부의 모든 지점이 해당 값을 가진다고 볼 수 없고, 폴리곤 전체의 합산값 혹은 총빈도의 의미를 갖는 값)들을 가진 변수들이 포함되어 있기 때문이다. 이 경우, 인구수와 같은 값들은 폴리곤 전체에 관련된 것이므로, 폴리곤을 대체하는 <code>POINT</code> 지오메트리와는 연관되지 않는다.</p>
<p>1.6절에서 이미 언급했듯이, 라인 및 폴리곤 지오메트리에서는 피처 속성 값이 <em>포인트 스포트</em> 또는 <em>블록 스포트</em>를 가질 수 있다. 포인트 스포트는 해당 값이 지오메트리의 <em>어떤 지점에도</em>(<em>모든 지점</em>에) 적용되는 경우이고, 블록 서포트는 지오메트리 내의 <em>모든 지점을 요약</em>하는 경우를 의미한다(해당 지오메트리보다 더 작거나 더 큰 서포트 역시 가능한다).</p>
<p>이 장에서는 속성이 지오메트리와 관련되는 방식과 서로 다른 방식이 데이터 분석에 미치는 영향, 그리고 서로 다른 지오메트리로부터 속성을 도출하는 방법(상향 스케일링과 하향 스케일링)에 대해 설명할 것이다.</p>
<section id="속성-지오메트리-관계와-서포트" class="level2" data-number="5.1"><h2 data-number="5.1" class="anchored" data-anchor-id="속성-지오메트리-관계와-서포트">
<span class="header-section-number">5.1</span> 속성-지오메트리 관계와 서포트</h2>
<p>피처 속성은 변경하지 않고 피처의 기하 특성만 변경해도 <em>피처</em>는 변화한 것이다. 왜냐하면 피처는 지오메트리와 속성의 조합으로 이루어지기 때문이다. 예를 들어, 해당 지오메트리를 컨벡스 헐이나 센트로이로 대체할 때, 산출되는 피처가 여전히 속성 값과 의미 있게 관계를 맺을 것인지를 미리 예측할 수 있을까? 이건 그때마다 다르다.</p>
<p>LINESTRING의 지오메트리를 갖는 도로망을 예를 들어보자. 데이터셋에 도로폭이라는 속성이 포함되어 있고, 어떤 도로의 속성값이 10m라고 하자. 이 때 해당 도로의 특정 부분의 도로폭에 대해 우리는 뭐라고 얘기할 수 있을까? 이는 속성인 도로폭이 도로의 모든 지점의 도로폭을 의미하는지, 즉 도로폭이 일정하다는 것을 의미하는지, 아니면 최소 또는 평균 도로폭과 같은 집합적 속성을 의미하는지에 따라 달라진다. 최소의 경우를 좀 더 따져보자. 최소 도로폭은 해당 도로에서 임의로 특정 구간을 선택했을 때 그것의 최소 도로폭이 주어진 최소 도로폭보다 작지 않을 것이라는 점을 함축하고 있지만, 그 하위 구간의 최소 도로폭이 아닐 수도 있다. 이는 두 가지 <em>유형</em>의 속성-지오메트리 관계(AGR)가 있음을 함축한다.</p>
<ul>
<li><p>고정(constant) AGR: 속성값이 지오메트리의 모든 부분에 적용된다. 피처가 무수히 많은 지점으로 구성되어 있고, 모든 지점이 동일한 속성값을 가지는 경우라고 생각하면 된다. 지구통계학적 용어로는 이것을 <em>포인트 서포트</em>를 보유한 변수라고 부른다.</p></li>
<li><p>집계(aggregate) AGR: 속성값이 지오메트리의 전체에 대한 요약값이다. 피처가 하나의 관측값을 갖고 그 값은 지오메트리 전체에 적용되는 경우라고 생각하면 된다. 이러한 변수를 <em>블록 서포트</em>를 보유한 변수라고 부른다.</p></li>
</ul>
<p>폴리곤 데이터의 경우, 고정 AGR(포인트 서포트)의 예로 다음을 변수를 들 수 있다.</p>
<ul>
<li><p>토지이용도에서의 토지이용</p></li>
<li><p>지질도에서의 암석 단위 또는 지질층</p></li>
<li><p>토양도에서의 토양 유형</p></li>
<li><p>기복도에서의 고도 클래스</p></li>
<li><p>기후구분도에서의 기후 지역</p></li>
</ul>
<p>이러한 변수의 전형적인 특성은 지오메트리가 인위적으로 생성된 것이 아니며, 센서 장치(예: 원격탐사의 이미지 픽셀 경계)와도 관련이 없다는 것이다. 대신, 지오메트리는 관찰된 변수를 매핑함으로써 결정된다. 집계 AGR의 예로는 다음과 같은 변수를 들 수 있다.</p>
<ul>
<li><p>인구: 인구수 혹은 인구밀도</p></li>
<li><p>지역별로 요약된 사회경제적 변수</p></li>
<li><p>원격탐사 픽셀별 평균 반사율</p></li>
<li><p>지역별 총 오염물질 배출량</p></li>
<li><p>이산화질소 농도에 대한 블록 평균: 보통 정사각형 블록에 대한 블로 크리깅(12.5절) 또는 구역 평균값을 예측하는 분산 모델을 통해 획득된다.</p></li>
</ul>
<p>이러한 변수의 전형적인 특성은 지오메트리가 법률적 규정, 관측 장치 또는 분석 선택과 같은 것으로부터 비롯된 것으로, 관찰 변수 그 자체와 본질적으로 연결되어 있지는 않다는 점이다.</p>
<p>세 번째 유형의 AGR는 속성이 피처 기하의 식별자 역할을 하는 경우에 발생한다. 개별 지오메트리가 변수의 특정 값과 고유한 관련성을 맺고 있을 때, 우리는 이 속성을 식별 변수(identity variable)라고 부른다(같은 값을 가진 다른 지오메트리가 없다). 카운티 이름의 예를 들어보자. 이름이 해당 카운티를 식별하고, 카운티 내의 어떤 하위-지역에 대해서도 동일 이름이 적용될 수 있다(포인트 서포트). 그러나 임의의 하위-구역을 염두에 두면 해당 변수는 더 이상 식별자로서의 역할을 할 수 없는 고정 속성값으로 변모한다. 하나의 예를 들면 다음과 같다.</p>
<ul>
<li>카운티 내부의 임의 점(또는 지역)은 여전히 그 카운티의 일부이며 카운티 이름이라는 변수에 대해 동일한 변수값을 가져야 한다. 하지만 해당 지점(또는 지역)은 더 이상 해당 카운티의 (총체적인) 지오메트리에 대한 식별자 구실을 할 수 없다.</li>
</ul>
<p>여기서 중요한 것은 공간정보(단순화를 위해 시간을 무시할 경우)가 서로 다른 현상 유형으로 나뉘어질 수 있다는 점이다(Scheider et al.&nbsp;2016).</p>
<ul>
<li><p>필드: <em>연속적</em> 공간 상의 모든 지점이 특정한 속성 값을 갖는 경우(예를 들어, 고도, 대기질 또는 토지이용)</p></li>
<li><p>객체: 위치의 <em>이산적</em> 집합으로 규정되는 경우(예를 들어, 주택, 나무 또는 사람)</p></li>
<li><p>집계값: 필드별 총합 혹은 평균, 라인 혹은 폴리곤 객체의 총빈도 혹은 밀도로 계산되는 값</p></li>
</ul>
<p>그런데 이러하 현상 유형이 지오메트리 유형(포인트, 라인, 폴리곤, 래스터 셀)과 일대일 대응의 관계에 있는 것은 아니다.</p>
<ul>
<li><p>포인트는 필드 상의 표집 위치일 수도 있고(대기질) 객체의 위치일 수도 있다.</p></li>
<li><p>라인은 객체(도로와 강)일수도 있고, 필드를 위한 등치선일 수 있고, 행정구역의 경계일 수도 있다.</p></li>
<li><p>래스터 픽셀과 폴리곤은 토지이용(<em>커버리지</em>)과 같은 범주형 필드와 연관될 수도 있고, 인구밀도와 같은 집계값과도 관련될 수 있다.</p></li>
<li><p>래스터 혹은 다른 종류의 메시 삼각망은 노드(포인트), 엣지(라인), 페이스(에어리어, 셀)와 관련된 서로 다른 변수를 가질 수 있다. 스태거드(staggered) 그리드를 이용해 편미분 방정식을 근사하는 상황(Haltiner and Williams 1980; Collins et al.&nbsp;2013)이 이러한 예가 될 수 있다.</p></li>
</ul>
<p>속성-지오메트리 관계를 적절히 정의하고, 속성-지오메트리 관계에 대한 정보가 부존하거나 지오메트리의 변화(서포트의 변화)가 정보의 변화를 야기하는 경우에 대해 경고 메시지를 표출하는 것은 공간데이터의 <em>서포트</em>와 관련된 일반적인 공간데이터 분석 오류(Stasch et al.&nbsp;2014)를 피하는 데 도움이 될 수 있다.</p>
</section><section id="애그리게이션과-서머라이즈" class="level2" data-number="5.2"><h2 data-number="5.2" class="anchored" data-anchor-id="애그리게이션과-서머라이즈">
<span class="header-section-number">5.2</span> 애그리게이션과 서머라이즈</h2>
<p>테이블 레코드의 합형은 다음의 두 간계를 통해 이루어진다.</p>
<ul>
<li><p>그룹 프리디케이트에 기반해 레코드를 분류하기</p></li>
<li><p>합형 함수를 적용해 그룹별로 단일한 요약 속성값을 계산하기</p></li>
</ul>
<p>SQL에서 합형 과정은 다음의 예시처럼 이루어진다.</p>
<p><code>SELECT GroupID, SUM(population) FROM table GROUP BY GroupID;</code></p>
<p>여기서 합형 함수는 <code>SUM</code>이고 그룹 프리디케이트는 <code>GroupID</code>이다.</p>
<p>R 패키지인 dplyr은 이를 수행하기 위해 두 단계를 사용한다. 함수 group_by는 레코드의 그룹 멤버십을 지정하고, summarise는 각 그룹에 대한 데이터 요약(예: 합계 또는 평균)을 계산한다. 베이스 R의 aggregate 함수는 테이블, 그룹화 조건, 및 집계 함수를 아규먼트로 받아 두 가지 작업을 단일 함수로 해결한다.</p>
<p>노스캐롤라이나 카운티의 예는 그림 5.1에 나타나 있다. 타원 좌표 POINT(-79, 35.5)를 기준으로 사분면을 설정하고 카운티의 센트로이드가 어느 사분면에 위치하느냐에 따라 카운티를 그룹화하고, 각 그룹별로 질병 사례 수를 합산했다. 그 결과, 그룹별로 통합된 지오메트리가 생성되었음을 알 수 있다(3.2.6절 참조). 이러한 그룹별 합형은 필수적인데, 만일 카운티 지오메트리를 단순히 한데 묶어 MULTIPOLYGON을 생성했다면 수 많은 중복 경계가 생겨나 유효하지 않은 지오메트리가 생성되었을 것이기 때문이다(3.1.2절 참조).</p>
<div id="fig-5-1" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://r-spatial.org/book/05-Attributes_files/figure-html/fig-ncaggregation-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" data-glightbox="description: .lightbox-desc-1"><img src="https://r-spatial.org/book/05-Attributes_files/figure-html/fig-ncaggregation-1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;5.1: SID74가 네 개의 지역별로 합산되었다.
</figcaption></figure>
</div>
<p>결합된 카운티 폴리곤을 지도로 나타내는 것은 기술적으로 아무런 문제가 없지만, 그룹 합계가 그룹화된 카운티에 관련된 것이 아니라 개별 카운티와 관련된 것이라는 잘못된 암시를 줄 수 있다. 이러한 방식의 합형의 특징은 각 레코드가 하나의 그룹에만 할당된다는 점이다. 이렇게 하면 그룹별 합계의 총합이 그룹화 이전 데이터의 총합과 동일하다는 장점이 있다. 즉, 정량적인 변수의 경우, 정보가 손실되거나 추가되는 일이 없다. 새로 형성된 기오메트리는 원 레코드의 지오메트리를 그룹에 의거해 유니온한 결과이다.</p>
<div id="fig-5-2" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://r-spatial.org/book/05-Attributes_files/figure-html/fig-ncblocks-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" data-glightbox="description: .lightbox-desc-2"><img src="https://r-spatial.org/book/05-Attributes_files/figure-html/fig-ncblocks-1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;5.2: 노스케롤라이나 카운티 상의 타깃 블
</figcaption></figure>
</div>
<p>지오메트리의 결합 없이 그룹별 합산값을 산출할 필요가 있을 수 있다. 이 경우, 우리는 공간적 프리디케이트를 사용하는데, 하나의 레코드가 여러개의 그룹과 관련될 수 있다. 그림 5.2의 직사각형을 타깃 에어리어로 하여 직사각형별로 교차하는 카운티의 유병자를 합산하게 되면 전체 합계는 훨씬 더 큰 값을 갖게 될 것이다.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co">#   sid74_sum_counties sid74_sum_rectangles </span></span>
<span><span class="co">#                  667                 2621</span></span></code><button title="클립보드 복사" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>반대로 contains 또는 covers와 같은 다른 프리디케이트를 사용하면 훨씬 더 적은 값이 산출된다. 왜냐하면 많은 카운티가 직사각형 속에 완전히 포함되지 않기 때문이다. 그러나 이러한 결과가 좋을 수 있는 상황도 충분히 존재할 수 있다.</p>
<ul>
<li><p>POINT 지오메트리를 폴리곤에 의거해 합형하고자 하는 경우. 이 때 모든 포인트는 해당 포인트를 완전 포함하는 폴리곤에 할당된다. 만일 경계 상에 위치하게 되면 양쪽 폴리곤 모두에 할당된다(DE-9IM-기반 GEOG 라이브러리가 이러한 방식을 취한다. s2geometry 라이브러리는 “반-개방” 폴리곤을 지정할 수 있게 해주는데, 폴리곤의 중첩만 없다면, 반드시 하나의 폴리곤에 포인트를 할당해준다.</p></li>
<li><p>매우 작은 폴리곤이나 래스터 픽셀을 더 큰 에어리어로 합역하는 경우. 예를 들어 노스케롤라이나에 대한 30m 해상도의 고도 데이터를 카운티별로 평균내는 경우가 해당될 수 있는데 다중 대응으로 인한 데이터 오류는 무시할 만하다.</p></li>
<li><p>다대다 대응에 최대면적대응이 적용된 경우(그림 7.4 참조)</p></li>
</ul>
<p>보다 작은 에어리어를 보다 큰 에어리어로 합역하는 보다 포괄적인 접근 방법은 면적-가중 인터폴레이션(area-weighted interpolation)을 적용하는 것이다.</p>
</section><section id="면적-가중-인터폴레이션" class="level2" data-number="5.3"><h2 data-number="5.3" class="anchored" data-anchor-id="면적-가중-인터폴레이션">
<span class="header-section-number">5.3</span> 면적-가중 인터폴레이션</h2>
<p>두 개의 데이터셋의 지오메트리와 속성을 결합함으로써 소스 데이터셋의 속성 값을 타겟 데이터셋의 지오메트리에 의거한 요약값으로 전환하고자 한다면, 면적-가중 인터폴레이션(area-weighted interpolation)이 가장 간단한 접근 방법이 될 수 있다. 이 방법은 소스와 타겟의 지오메트리가 겹치는 면적을 고려하여 소스 속성 값을 타겟 속성 값으로 전환하기 위한 가중치로 사용한다(Goodchild and Lam 1980; Do, Thomas-Agnan, and Vanhems 2015a, 2015b; Do, Laurent, and Vanhems 2021). 이 기법은 보수적 합역(conservative region aggregation) 또는 재그리드(regridding)로도 알려져 있다(Jones 1999). 여기서는 Do, Thomas-Agnan, and Vanhems(2015b)의 표기법을 따르도록 한다.</p>
<p>면적-가중 인터폴레이션은 타깃 에어리어 <span class="math inline">\(T_j\)</span>에 대한 가중평균값을 산출해 주는데, 해당 타깃 에어리어와 결부되어 있는 <span class="math inline">\(p\)</span>개의 타깃 에어리어 <span class="math inline">\(S_i\)</span>의 속성값 <span class="math inline">\(Y_i\)</span>에 대한 가중평균값이다.</p>
<p><span id="eq-5-1"><span class="math display">\[
\hat Y_j(T_j)=\sum\limits_{ij}^pw_{ij}Y_i(S_i)
\tag{5.1}\]</span></span></p>
<p>여기서 <span class="math inline">\(w_{ij}\)</span>는 <span class="math inline">\(T_j\)</span>와 <span class="math inline">\(S_i\)</span>의 겹침의 정도에 따라 달라지는 데, 겹침의 정도는 <span class="math inline">\(A_{ij}=T_j\cap S_i\)</span>로 표현된다. <span class="math inline">\(w_{ij}\)</span>와 <span class="math inline">\(A_{ij}\)</span>의 관계는 아래에서 자세히 설명하고자 한다.</p>
<p>가중치를 계산하는 다양한 옵션이 있으며, 외부 변수를 활용하는 방법(대시메트릭 매핑은 Mennis 2003 참조)도 그 중 하나이다. 외부 변수를 사용하지 않고 가중치를 계산하는 두 가지 단순한 방식이 존재하는데, 변수 <span class="math inline">\(Y\)</span>가 공간적으로 <em>외연적인</em>(extensive) 변수인지 <em>내포적인</em>(intensive) 변수인지에 따라 달라진다.</p>
<section id="공간적으로-외연적인-변수와-공간적으로-내포적인-변수" class="level3" data-number="5.3.1"><h3 data-number="5.3.1" class="anchored" data-anchor-id="공간적으로-외연적인-변수와-공간적으로-내포적인-변수">
<span class="header-section-number">5.3.1</span> 공간적으로 외연적인 변수와 공간적으로 내포적인 변수</h3>
<p>공간적으로 외연적인 변수는 길이, 면적, 부피, 또는 카운트와 같은 물리적 크기와 관련된 양을 나타낸다. 외연적인 변수의 예로 인구 수를 들 수 있다. 인구 수는 특정 크기의 영역과 관련된 값이며, 그 영역이 더 작은 영역으로 분할되면 인구 수 또한 분할되어야 한다. 인구가 공간적으로 균일하지 분포하지 않은 경우가 많기 때문에, 이 분할이 반드시 면적에 비례하여 이루어질 필요는 없지만, 더 작은 영역의 인구 수의 합계는 전체 영역의 인구 수와 일치해야 한다.</p>
<p>공간적으로 내포적인 변수는 영역의 면적에 비례적으로 작동하지 않는 변수이다. 즉, 영역이 분할되더라도 평균적인 의미에서는 값이 그대로 유지된다. 내포적인 변수의 예로 인구밀도를 들 수 있다. 영역이 더 작은 영역으로 분할되더라도 연구밀도 값이 면적에 비례하여 할당되지는 않는다. 더 작은 영역의 인구밀도의 합산값은 아무런 의미가 없으며, 작은 영역의 인구밀도의 평균의 전체 영역의 인구밀도와 유사할 것이다.</p>
<p>외연적인 변수 <span class="math inline">\(Y\)</span>가 공간상에 균등하게 분포한다고 했을 때, 소스 데이터의 지역 <span class="math inline">\(S_i\)</span>의 변수값 <span class="math inline">\(Y_i\)</span>로부터 타깃 지역과의 겹침을 통해 생성된 구역(<span class="math inline">\(A_{ij}=T_j\cap S_i\)</span>)의 속성값 <span class="math inline">\(Y_{ij}\)</span>를 다음의 공식에 의거해 구할 수 있다.</p>
<p><span class="math display">\[
\hat Y_{ij}(A_{ij})=\frac{|A_{ij}|}{|S_i|}Y_i(S_i)
\]</span></p>
<p>여기서 <span class="math inline">\(|\cdot|\)</span>는 면적을 의미한다. <span class="math inline">\(Y_j(T_j)\)</span>를 추청하려면, <span class="math inline">\(T_j\)</span>와 겹쳐서 생성되는 모든 하위 영역의 값을 합산해야 한다.</p>
<p><span id="eq-5-2"><span class="math display">\[
\hat Y_j(T_j)=\sum\limits_{i=1}^p\frac{|A_{ij}|}{|S_i|}Y_i(S_i)
\tag{5.2}\]</span></span></p>
<p>내포적인 변수의 경우, 해당 변수값이 개별 소스 구역 <span class="math inline">\(S_i\)</span> 내에서 일정한 값을 나타낸다고 가정하기 때문에, 겹침에 의해 생성된 하위 구역의 추정값은 해당 소스 구역의 전체 값과 동일하다.</p>
<p><span class="math display">\[
\hat Y_{ij}=Y_i(S_i)
\]</span></p>
<p>따라서 소스 구역의 값에 대해 면적-가중 평균을 구하면 타깃 구역 <span class="math inline">\(T_j\)</span>에 대한 추정값을 구할 수 있다.</p>
<p><span id="eq-5-3"><span class="math display">\[
\hat Y_j(T_j)=\sum\limits_{i=1}^p\frac{|A_{ij}|}{|T_j|}Y_i(S_i)
\tag{5.3}\]</span></span></p>
</section><section id="대시메트릭-매핑" class="level3" data-number="5.3.2"><h3 data-number="5.3.2" class="anchored" data-anchor-id="대시메트릭-매핑">
<span class="header-section-number">5.3.2</span> 대시메트릭 매핑</h3>
<p>다시메트릭 매핑은 보다 큰 크기의 구역 체계의 변수값(예: 인구 수)을 보다 크기가 작은 구역 체계의 변수값으로 분배하는 방법이다. 이때 인구 분포와 연관된 다른 변수들, 예를 들어 토지 이용, 건물 밀도, 도로 밀도 등을 활용한다. 대시매트릭 매핑을 위한 가장 간단한 방식은 식 5.2에서 나타나 있는 비 <span class="math inline">\(|A_{ij}|/|S_i|\)</span> 대신 또 다른 외연적인 변수와 관련된 비 <span class="math inline">\(X_{ij}(S_{ij})/X_i(S_i)\)</span>를 사용하는 것이다. 이 방법을 사용하기 위해서는 소스 구역과 겹침 구역 모두에 대해 변수 값을 알고 있어야 한다.</p>
</section><section id="파일-포맷에서의-서포트" class="level3" data-number="5.3.3"><h3 data-number="5.3.3" class="anchored" data-anchor-id="파일-포맷에서의-서포트">
<span class="header-section-number">5.3.3</span> 파일 포맷에서의 서포트</h3>
<p>GDAL의 벡터 API는 필드 도메인(field domains)이라고 불리는 것을 읽고 쓰는 기능을 지원하며, 이는 지오메트리가 분할되거나 결합될 때 속성 변수에 대해 어떤 처리를 해야 할지 나타내는 “분할 정책(split policy)”과 “병합 정책(merge policy)”을 가질 수 있다. 이러한 값은 공간적으로 내표적인 변수의 경우, 분할 시 “중복(duplicate)”이, 병합 시 “기하 가중(geometry weighted)”가 될 수 있으며, 공간적으로 외연적인 변수의 경우, 분할 시 “기하 비율(geometry ratio)”이, 병합 시 “합(sum)”이 될 수 있다. 이 기능을 지원하는 파일 형식으로는 GeoPackage와 FileGDB가 있다.</p>
</section></section><section id="상향-스케일링과-하향-스케일링" class="level2" data-number="5.4"><h2 data-number="5.4" class="anchored" data-anchor-id="상향-스케일링과-하향-스케일링">
<span class="header-section-number">5.4</span> 상향 스케일링과 하향 스케일링</h2>
<p>상향 및 하향 스케일링(upscaling and downscaling)은 일반적으로 저해상도 데이터에서 고해상도 정보를 얻는 과정(하향 스케일링) 또는 고해상도 데이터에서 저해상도 정보를 얻는 과정(상향 스케일링)을 의미한다. 이 두 과정은 속성과 지오메트리의 관계에서의 변화, 즉 서포트에서의 변화를 야기한다. 상향 스케일링은 집계(aggregation), 하향 스케일링은 분해(disaggregation)와 동의어로 사용할 수 있다. 하향 스케일링의 가장 단순한 형태는 폴리곤, 라인, 또는 격자 셀의 값을 주어진 포인트에 대해 샘플링(또는 추출)하는 것이다. 이는 포인트-서포트를 가진 변수(“고정” AGR)에는 적합하지만, 변수 값이 합산값일 경우에는 대략적인 결과만을 제공할 수 있다. 하향 스케일링의 도전 과제로는 저해상도 기상 예측 모델 또는 기후 변화 모델을 통해 얻은 변수를 고해상도로 예측하는 것, 그리고 다른 시공간적 해상도를 가진 센서의 융합을 기반으로 위성 이미지에서 파생된 변수를 고해상도로 예측하는 작업이 포함된다.</p>
<p>식 5.1과 이에 기반한 식 5.2(공간적으로 외연적인 변수)와 식5.3(공간적으로 내포적인 변수)는 소스 구역 <span class="math inline">\(S_i\)</span>와 타깃 구역 <span class="math inline">\(T_i\)</span> 간에 겹침이 존재하기만 하면 두 구역 사이에서 정보를 이동시키는 것이 가능하다는 점을 보여준다. 이는 임의로 더 큰 구역 단위로 이동(집계)하거나 더 작은 구역 단위로 이동(분해)할 수 있음을 의미한다. 물론 이러한 방식의 유의성은 다음의 가정이 성립하는 정도에 의존적이다. 즉, 소스 구역에서 외연적인 변수는 균등 분포해야 하고, 내포적인 변수는 일정한 값을 가져야 한다.</p>
<p>디스애그리게이션은 라인이나 폴리곤 데이터로부터 포인트 값을 추출하는 것에서 시작된다. 포인트는 면적을 갖지 않기 때문에(<span class="math inline">\(|A_{ij}|=0\)</span>) 식 5.2와 5.3은 적용할 수 없다. 그러나 지오메트리 내부의 값이 일정하다는 가정을 할 수 있다면, 내포적인 변수인 경우에는 <span class="math inline">\(Y_i(S_i)\)</span>이 포인트에 할당될 수 있다. 단, 모든 지점이 고유한 방식으로 단일한 소스 지점 <span class="math inline">\(S_i\)</span>에 할당될 수 있어야 한다. 폴리곤 데이터를 예를 들자면, <span class="math inline">\(Y\)</span>가 커버리지 변수(3.4절)여야만 한다는 것을 함축한다. 외연적인 변수의 경우, 포인트에 대한 변수값을 추출한다는 것이 무의미하다. 항상 0이 추출될 것이기 때문이다.</p>
<p>영역과 관련된 값이 해당 영역의 집계 값인 경우, 면적-가중 인터폴레이션이나 대시매트릭 매핑에서 가정하는 균일 분포 또는 일정한 값이라는 가정은 매우 비현실적이다. 이러한 경우에라 하더라도 이러한 단순한 접근법이 합리적인 근사치를 제공할 수 있으며, 예를 들어 다음과 같은 상황에서 가능하다.</p>
<ul>
<li><p>소스 구역과 타깃 구역이 거의 동일하다.</p></li>
<li><p>소스 구역 내의 변동성이 매우 작아서, 변수값이 거의 균등 분포하거나 일정한 값을 보인다.</p></li>
</ul>
<p>다른 경우에는 이러한 방법을 사용하여 얻은 결과는 그저 타당성이 결여된 가정의 결과일 뿐이다. 점 또는 더 작은 구역으로부터 더 큰 구역에 대한 퀀티티를 추정할 수 있는 통계적 애그리게이션 방법에는 다음이 포함된다.</p>
<ul>
<li><p>디자인-기반(design-based) 방법: 타깃 지역에서 확률 샘플이 이용 가능하고, 포함 확률(inclusion probability)이 알려져 있어야 한다(Brus 2021, 10.4 절).</p></li>
<li><p>모델-기반(model-based) 방법: 공간적 자기상관을 수용하는 랜덤 필드 모델을 가정한다(블록 크리깅, 12.5절).</p></li>
</ul>
<p>다른 디스애그리게이션 기법에 다음과 같은 것들이 있다.</p>
<ul>
<li><p>결정론적, 평활화-기반 접근: 커널-기반 또는 스플라인-기반의 평활화 기법 포함</p></li>
<li><p>통계적, 모델-기반 접근: 에어리어-투-에어리어 크리깅과 에어리어-투-포인트 크리깅</p></li>
</ul></section><section id="연습문제" class="level2" data-number="5.5"><h2 data-number="5.5" class="anchored" data-anchor-id="연습문제">
<span class="header-section-number">5.5</span> 연습문제</h2>
<p>다음의 연습문제를 풀되, 적절한 곳에서 R을 활용하라.</p>
<ol type="1">
<li><p>노스케롤라이나 데이터셋(<code>nc</code>)에 <code>nc$State = "North Carolina"</code>와 같은 방식으로 변수를 첨가한다고 할 때(모든 카운티에 동일한 주 이름이 할당), 속성-지오메트리 관계(AGR)을 위해 이 변수에 어떤 값을 첨가할 수 있을까?</p></li>
<li><p><code>st_union(nc)</code>으로 얻은 지오메트리로부터 새로운 <code>sf</code> 객체를 생성하고, <code>State</code>라는 변수에 <code>"North Carolina"</code>라는 값을 할당하라. 이 변수에 어떤 대한 속성-지오메트리 관계(AGR)을 속성 변수에 할당할 수 있을까?</p></li>
<li><p><code>nc</code> 데이터셋에 <code>st_area</code>를 사용하여 이름이 <code>area</code>인 변수를 추가하시오. <code>area</code> 변수와 <code>AREA</code> 변수를 비교하시오. <code>AREA</code>의 단위는 무엇인가? 두 변수는 선형적인 관련성이 있는가? 불일치가 존재한다면, 그 원인은 무엇일까?</p></li>
<li><p><code>area</code>는 내포적인 변수인가 외연적인 변수인가? <code>area</code>의 AGR은 <code>constant</code>인가, <code>identity</code>인가, 아니면 <code>aggregate</code>인가?</p></li>
<li><p>그림 5.3에서 5.3.1 절에 나타나 있는 방정식을 이용하여 (a) 점선 셀과 (b)네 개의 실선 셀을 모두 포함하는 정사각형에 대해 면적-가중 인터폴레이션의 결과를 구하시오. 후자에 대해서는 (i) 외연적인 변수인 경우와 (ii) 내포적인 변수인 경우로 나누어 계산하시오. 빨간 숫자는 소스 구역의 데이터 값이다.</p></li>
</ol>
<div id="fig-5-3" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-5-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://r-spatial.org/book/05-Attributes_files/figure-html/fig-awiex-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" data-glightbox="description: .lightbox-desc-3"><img src="https://r-spatial.org/book/05-Attributes_files/figure-html/fig-awiex-1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-5-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
그림&nbsp;5.3: 면적-가중 인터폴레이션의 예제 데이터
</figcaption></figure>
</div>


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-1">그림&nbsp;5.1: SID74가 네 개의 지역별로 합산되었다.</span>
<span class="glightbox-desc lightbox-desc-2">그림&nbsp;5.2: 노스케롤라이나 카운티 상의 타깃 블</span>
<span class="glightbox-desc lightbox-desc-3">그림&nbsp;5.3: 면적-가중 인터폴레이션의 예제 데이터</span>
</div>
</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="./04.html" class="pagination-link  aria-label=">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">구체 지오메트리</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./06.html" class="pagination-link" aria-label="<span class='chapter-number'>6</span>&nbsp; <span class='chapter-title'>데이터 큐브</span>">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">데이터 큐브</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/sangillee66/book_sds_trans/issues/new" class="toc-action"><i class="bi bi-github"></i>이슈 보고</a></li></ul></div></div></div></footer><script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","openEffect":"zoom","selector":".lightbox","descPosition":"bottom","loop":false});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>


</body></html>