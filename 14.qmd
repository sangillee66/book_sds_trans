---
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
---

# 근접성과 에어리어 데이터 {#sec-area}

관측개체가 에어리어 객체인 경우는 매우 흔하다. 연구대상 전체에서 관측이 동시적으로 이루어지고 그러한 관측값이 비중첩 구역단위로 합산되는 경우가 여기에 해당한다. 이러한 구역단위는 행정구역인 경우가 많다. 물론 통근 플로와 같이 기저 공간 프로세스를 직접적으로 반영한 경우도 있지만, 보통은 프로세스와 관계없이 임의적으로 주어진다. 이러한 구역단위와 기저 공간 프로세스 간의 불일치는 동일한 공간적 프로세스가 인접한 구역단위 사이에서 부분적으로 공유된다는 것을 의미하며, 이러한 불일치가 해당 데이터셋 내의 단 하나의 변수에서라도 발생한다면, 전체적으로 공간적 자기상관의 문제가 야기된다고 할 수 있다. 여기서 근접성(proximity)이란 데이터 생성 프로세스라는 의미에서의 *가까움*(closeness)을 의미한다. 포인트 스포트를 사용하는 횡단 지구통계학 분석에서는 포인트 간 거리가 전형적인 데이터 생성 프로세스에 적합하다. 그런데, 에어리어 데이터의 경우는 거리보다는 공유 경계가 더 적합할 수 있다. 공유 경계는 우리가 확실히 측정할 수 있는 것이지만, 동일한 확실성 하에서 에어리어간 거리를 측정할 수 있는 방법은 없기 때문이다.

데이터의 스포트란 개별 관찰단위(관측개체)의 물리적 크기(길이, 면적, 부피)를 의미한다(5장 참조). 에어리어 데이터는 기본적으로 폴리곤 스포트를 가지지만 포인트 서포트를 가지는 것으로 재현할 수도 있다. 개별 폴리곤의 센트로이드 혹은 멀티폴리곤의 경우는 최대 폴리곤의 센트로이드를 대표 지점으로 삼을 수 있다. 반대로, 포인트 스포트를 가지는 데이터를 에어리어 데이터로 취급할 수도 있다. 이 경우 포인트를 비중첩 테셀레이션으로 전환해야 하는데, 들로네 삼각망을 통해 보로노이 다이어그램(디리클레 테셀레이션 혹은 티센 폴리곤)을 생성한다. 다른 메트릭이 선택될 수 있으며, 평면이 아닌 네트워크 상의 거리를 측정할 수도 있다. 국지적 공간 분석에서는 가중 보로노이 다이어그램이 사용되기도 한다(Boots and Okabe 2007; Okabe et al. 2008; She et al. 2015 참조).

데이터의 원 스포트가 포인트이지만, 기저의 공간 프로세스가 관측개체간의 거리가 아니라 오로지 인접성에 의거해 발생하는 경우라면, 데이터는 총빈도 혹은 총계(투표소의 개수, 총매출액)이거나 관측개체의 직접적 속성(예: 투표소의 개방 시간)일 수 있다. 이러한 모든 경우에서 기저의 공간 프로세스를 잘못 재현할 위험성이 상존함은 분명한 사실이다. 특히, 연구지역 전체를 하나의 테셀레이션 체계로 재현하는 경우, 관측값이 기저의 공간적 프로세스를 모두 포착해 낸 것으로 상정되기 때문에 더욱 그러하다. 이러한 측면에서 에어리어 데이터는 지구통계학적 데이터와는 다르다. 후자는 전체 지역에 대해 특정한 방식의 샘플링이 적용되었다는 것을 전제하지만 전자는 그렇지 않다. 또한 생태 및 환경 분석에서 사용되는 에어리어 샘플링과도 다른데, 그러한 샘플링은 지역 전체가 아니라 일부 영역에 대해 선택적으로 이루어진다.

15\~17장에 걸쳐 에어리어 데이터를 탐색 및 분석하기 위한 기법들이 다루어진다. 이를 위해서는 관측개체 간의 근접성을 나타내는 특정한 방식이 요구된다. 이 장에서는 근접성을 연접성(contiguity)에 의거해 규정하는 방식에 집중한다. 여기서 연접성은 이웃으로 정의된 관측개체들을 서로 연결한 그래프를 통해 규정된다. 이 그래프는 보통 방향성과 가중치가 없지만, 특정 설정에서는 방향과 가중치가 부여될 수도 있으며, 이 경우 대칭성에 대한 추가적인 이슈가 야기될 수 있다. 원칙적으로, 근접성은 공간 상에서 대칭적으로 작동하는 것으로 간주한다. 즉, $i$가 $j$에 미치는 영향과 $j$가 $i$에 미치는 영향은 동일한 것으로 간주한다. 일반적으로 에지 효과(edge effect)는 고려하지 않는다.

## 근접성의 재현: spdep 패키지의 경우

공간적 자기상관을 그래프 상의 이웃들의 관계를 통해 다루는 접근의 경우, 해당 그래프는 주어진 것이고, 그 그래프를 연구자가 선택한 것으로 간주한다. 이것은 지구통계학적 접근과는 다른 것인데, 연구자는 경험적 베리오그램의 거리를 어떻게 나눌 것인지, 어떤 함수를 적용할 것인지, 베리오그램 적합을 어떻게 수행할 것인지를 모두 선택한다. 두 접근법 모두 사전 선택을 포함하지만, 기저의 상관성을 재현하는 방식에서는 서로 다른 것이다(Wall 2004). 그래프에 기반한 이웃 규정 방식을 보다 넓은 맥락에서 설명하는 시도도 존재한다(Bavaud, 1998).

이웃 관계를 나타내는 객체를 생성할 때 이웃이 없는 구역단위의 존재는 문제를 야기한다(Bivand and Portnov 2004). 섬이나 강으로 분리된 구역단위가 이러한 비이웃 구역단위일 수 있는데, 구역단위에 에어리어 스포터가 적용되어 있고 공유 경계와 같은 위상 관계가 사용되는 경우이다. 예를 들어, `mgcv::gam`과 같은 모델 적합 함수에서 `mrf`(마르코프 랜덤 필드) 항을 사용할 때, 방향이 없는 필요하지만, 그래프가 분리된 하위 그래프들로 구성되는 경우 에러가 발생한다.

이러한 무이웃 문제는 포인트 간의 거리로 이웃을 규정하는 경우에도 발생할 수 있는데, 거리 임계값이 최근린 이웃 거리보다 작은 경우가 여기에 해당된다. 공유 경계에 기반한 연접성 규정은 비투영 경위도 좌표를 사용하더라도 영향을 받지 않지만, 모든 포인트 기반 접근법은 어쨌든 거리를 사용하며, 적절한 방식으로 거리를 계산할 필요가 있다.

**spdep** 패키지는 이웃을 규정하는 `nb` 클래스를 제공한다. `nb` 클래스는 관측개체의 수를 길이로 갖는 리스트로 정수 벡터를 구성 요소로 갖는다. 이웃이 없는 경우는 `0L`이 단일 요소로 포함된 정수 벡터로 인코딩된다. 이웃이 있는 경우는 `1L:n` 범위 내의 값이 포함된 정수 벡터로 인코딩되는데, 그 값들은 이웃으로 규정된 관측개체의 인덱스값이다. 이것은 소위 행-기반 희소 재현(row-oriented sparse representation) 방식이다. **spdep** 패키지는 `nb` 객체를 생성하는 다양한 방법을 제공하며, 이 표현과 생성 함수는 다른 패키지에서도 널리 사용된다.

**spdep** 패키지는 `nb` 클래스(무방향 혹은 유방향 그래프)를 통해 `listw` 객체를 구성한다. `listw` 객체는 세 가지 구성 요소를 갖는 리스트로, `nb` 객체, 가중치 리스트, 그리고 가중치 계산 방식을 나타내는 단일 요소 문자 벡터가 포함된다. 사회과학에서 가장 흔히 사용되는 방법은 행 표준화를 통해 가중치를 계산하는 것인데, 개별 관측개체의 한 이웃의 가중치는 해당 관측개체의 이웃의 수(즉 카드널리티)의 역수(즉, `1/card(nb)[i]`)로 변환된다.

이 장에서는 2015년 폴란드 대통령 선거 데이터를 사용하는데, 지역 전체가 2,495개의 지방자치단체와 바르샤바 구역으로 구성되어 있다(그림 14.1 참조). 이 지도는 **tmap** 패키지(8.5절)를 활용해 그려진 것으로 지방자치단체 유형이 표시되어 있다. 구역단위는 `sf` 객체이며, 투표소 단위의 결과를 구역단위로 집계한 데이터이다.

```{r}
#| eval: false
library(sf)
# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE
```

```{r}
#| eval: false
data(pol_pres15, package = "spDataLarge")
pol_pres15 |>
    subset(select = c(TERYT, name, types)) |>
    head()
# Simple feature collection with 6 features and 3 fields
# Geometry type: MULTIPOLYGON
# Dimension:     XY
# Bounding box:  xmin: 235000 ymin: 367000 xmax: 281000 ymax: 413000
# Projected CRS: ETRS89 / Poland CS92
#    TERYT                name       types
# 1 020101         BOLESŁAWIEC       Urban
# 2 020102         BOLESŁAWIEC       Rural
# 3 020103            GROMADKA       Rural
# 4 020104        NOWOGRODZIEC Urban/rural
# 5 020105          OSIECZNICA       Rural
# 6 020106 WARTA BOLESŁAWIECKA       Rural
#                         geometry
# 1 MULTIPOLYGON (((261089 3855...
# 2 MULTIPOLYGON (((254150 3837...
# 3 MULTIPOLYGON (((275346 3846...
# 4 MULTIPOLYGON (((251770 3770...
# 5 MULTIPOLYGON (((263424 4060...
# 6 MULTIPOLYGON (((267031 3870...
```

```{r}
#| eval: false
library(tmap, warn.conflicts = FALSE)
# Breaking News: tmap 3.x is retiring. Please test v4, e.g. with
# remotes::install_github('r-tmap/tmap')
tm_shape(pol_pres15) + tm_fill("types")
```

![폴란드 구역단위 유형(2015년)](https://r-spatial.org/book/14-Areal_files/figure-html/fig-plotpolpres15-1.png){#fig-14-1}

`sf` 객체의 위상 구조의 유효성을 검토한다.

```{r}
#| eval: false
if (!all(st_is_valid(pol_pres15)))
        pol_pres15 <- st_make_valid(pol_pres15)
```

2002년 초부터 2019년 4월까지, `spdep`는 이웃 및 공간 가중치 객체를 생성하고 처리하는 함수, 공간적 자기상관을 검정하는 함수, 모델 적합과 관련된 함수 등을 포함하고 있었다. 모델 적합과 관련된 함수는 `spatialreg`로 분리되었으며, 이후 장에서 다룰 예정이다. 현재 `spdep`(Bivand 2022)는 `sf` 클래스와 `sp` 클래스 객체 모두를 지원한다.

```{r}
#| eval: false
library(spdep) |> suppressPackageStartupMessages()
```

## 이웃의 규정: 연접성 기반

**spdep** 패키지의 `poly2nb` 함수는 `pl` 아규먼트를 통해 투입된 객체에서 폴리곤 경계를 구성하고 있는 경계 포인트들을 이용한다. 투입 객체는 일반적으로 `"POLYGON"` 또는 `"MULTIPOLYGON"` 지오메트리를 가진 `"sf"` 또는 `"sfc"` 객체이다. 각 관측개체에 대해, 최소한 하나의 포인트(디폴트 퀸 방식, `queen=TRUE`) 또는 최소 두 개의 포인트(루크 방식, `queen=FALSE`)가 `snap` 거리 내에 또 다른 포인트(역자주: 연접 폴리곤의 경계 포인트)를 가지는지를 확인한다. 거리 계산은 투영법에 관계없이 원 길이 단위에 기반한 평면 거리로 이루어진다. 필요한 수의 충분히 가까운 점을 찾으면, 검색이 중단된다.

```{r}
#| eval: false
args(poly2nb)
```

``` r
#  function (pl, row.names = NULL, snap = sqrt(.Machine$double.eps),
#    queen = TRUE, useC = TRUE, foundInBox = NULL)
```

**spdep** 패키지 1.1-7부터, `poly2nb` 함수는 후보 이웃을 찾고 `foundInBox`를 내부적으로 채우기 위해 **sf** 패키지의 GEOS 인터페이스를 사용한다. 이 경우, **sf** 패키지를 통한 GEOS의 공간 인덱싱(STRtree 쿼리 사용)이 기본값으로 설정된다.

```{r}
#| eval: false
pol_pres15 |> poly2nb(queen = TRUE) -> nb_q
```

`print` 메서드는 이웃 객체의 요약 구조를 표시한다.

```{r}
#| eval: false
nb_q
# Neighbour list object:
# Number of regions: 2495 
# Number of nonzero links: 14242 
# Percentage nonzero weights: 0.229 
# Average number of links: 5.71
```

**sf** 패키지 버전 1.0-0부터는 구체 지오메트리를 위해 기본적으로 **s2** 패키지(Dunnington, Pebesma, and Rubak 2023)가 사용된다. 이는 `poly2nb` 함수에서 사용되는 `st_intersects` 함수가 계산을 `s2::s2_intersects_matrix`로 전달하기 때문이다(4장 참조). **spdep** 패키지 버전 1.1-9부터는 `sf_use_s2()`가 `TRUE`일 경우 구체 인터섹션을 사용하여 후보 이웃을 찾는다. GEOS와 마찬가지로, `s2` 라이브러리는 빠른 공간 인덱싱을 사용한다.

```{r}
#| eval: false
old_use_s2 <- sf_use_s2()
```

```{r}
#| eval: false
sf_use_s2(TRUE)
```

```{r}
#| eval: false
(pol_pres15 |> st_transform("OGC:CRS84") -> pol_pres15_ll) |> 
    poly2nb(queen = TRUE) -> nb_q_s2
```

예시의 경우, 구면 교차와 평면 교차가 동일한 인접 이웃을 생성한다. 두 경우 모두 투입 지오메트리의 유효성이 담보되어야 한다.

```{r}
#| eval: false
all.equal(nb_q, nb_q_s2, check.attributes=FALSE)
# [1] TRUE
```

`nb` 객체는 대칭적인 이웃 관계인 $i$에서 $j$, $j$에서$i$를 모두 기록하는데, 이는 `nb` 객체가 비대칭적인 관계도 허용하기 때문이다. 그러나 객체 생성에는 이러한 중복이 큰 의미는 없다.

대부분의 **spdep** 패키지 함수는 이웃 객체를 생성할 때 `row.names` 아규먼트를 사용하며, 이 값은 `region.id` 속성으로 저장된다. 만약 `row.names` 아규먼트가 지정되지 않으면, 첫 번째 아규먼트의 `row.names()`에서 가져온다. `region.id` 속성은 `nb` 객체가 원 데이터와 동일한 순서로 정리되어 있는지를 확인하는 데 사용된다. `nb` 객체의 일부만 추출할 경우 인덱스는 `1:length(subsetted_nb)` 범위 내의 값으로 재설정되지만, `region.id` 속성 값을 통해 원본 객체와 정확한 연결 정보를 확인할 수 있다. 이는 17.4절에서 간략하게 논의될 공간적 회귀 모델의 샘플 외 예측에서 사용된다.

`n.comp.nb` 함수를 사용하여 이 비방향 그래프의 연결성을 확인할 수도 있다. 일부 모델 추정 기법은 비연결 그래프를 지원하지 않지만, 비연결 그래프가 야기할 가능한 문제를 인지하고 있는 것은 중요하다(Freni-Sterrantino, Ventrucci, and Rue 2018).

```{r}
#| eval: false
(nb_q |> n.comp.nb())$nc
# [1] 1
```

이 접근법은 이웃 객체를 그래프처럼 취급하고 해당 그래프에 대해 그래프 분석을 수행하는 것과 동일하다(Csardi and Nepusz 2006; Nepusz 2022). 먼저 이웃 객체를 이진 희소 행렬로 변환한 후 그래프 분석을 수행한다(Bates, Maechler, and Jagan 2022).

```{r}
#| eval: false
library(Matrix, warn.conflicts = FALSE)
library(spatialreg, warn.conflicts = FALSE)
nb_q |> 
    nb2listw(style = "B") |> 
    as("CsparseMatrix") -> smat
library(igraph, warn.conflicts = FALSE)
(smat |> graph.adjacency() -> g1) |> 
    count_components()
# [1] 1
```

다른 소프트웨어와의 호환성을 위해 이웃 객체를 GAL 형식으로 내보내고 가져올 수 있다. 이를 위해 `write.nb.gal`함수와 `read.gal` 함수가 사용된다.

```{r}
#| eval: false
tf <- tempfile(fileext = ".gal")
write.nb.gal(nb_q, tf)
```

## 이웃의 규정: 그리프 기반

## 이웃의 규정: 거리 기반

## 가중치 부여

## 고차 이웃의 규정

## 연습문제
