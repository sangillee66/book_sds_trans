---
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
---

# 지오메트리 {#sec-geometry}

2장에서 좌표계에 대해 학습했으므로, 이제 이 장에서는 좌표를 활용하여 지오메트리를 정의하는 방법을 배운다. 본 장에서 다룰 주요 내용은 다음과 같다.

-   *심플 피처*(simple feature): 포인트, 라인, 폴리곤 지오메트리를 다루는 표준

-   지오메트리에 적용되는 다양한 연산

-   커버리지(coveratge): 공간 혹은 시공간을 표현하는 함수

-   테셀레이션(tessellation): 하나의 영역을 여러 하위 영역으로 세분화한 구조

-   네트워크

구면 지오메트리는 4장에서 논의하며, 래스터와 공간 또는 시공간을 직사각형 형태로 분할한 다른 세분화 체계는 6장에서 다룬다.

## 심플 피처 지오메트리

심플 피처 지오메트리(simple feature geometry)는 *피처*의 지오메트리를 기술하는 방식이다. 여기서 피처란 지오메트리를 가진 *사물*(thing)을 의미하며, 암묵적으로 시간 *속성*(attribute)을 포함할 수 있고, 사물을 묘사하기 위한 라벨이나 정량적 측도와 관련된 속성을 가질 수 있다. 심플 피처 지오메트리의 주된 목적은 2차원 공간에서 포인트, 라인, 폴리곤을 기반으로 기하학적 형태를 표현하는 것이다. ‘심플’이라는 형용사가 붙은 이유는 라인이나 폴리곤 지오메트리도 포인트 지오메트리와 이를 연결하는 직선으로 표현할 수 있기 때문이다.

*심플 피처 액세스*(simple feature access)는 심플 피처 지오메트리를 설명하는 표준(Herring 2011, 2010; ISO 2004)으로, 다음 사항을 포함한다.

-   클래스 위계

-   연산(오퍼레이션)의 집합

-   이진 인코딩과 텍스트 인코딩

이제 가장 널리 사용되는 7가지 심플 피처 지오메트리 유형에 대해 살펴본다.

### 7개의 대표 지오메트리

단일(single) 피처를 나타내는 데 사용되는 가장 일반적인 심플 피처 지오메트리 유형은 다음과 같다.

| 유형 | 설명 |
|----|----|
| `POINT` | 단일 포인트 지오메트리 |
| `MULTIPOINT` | `POINT`의 집합 |
| `LINESTRING` | 단일 라인스트링(두개 이상의 포인트가 직선으로 연결되어 있음) |
| `MULTILINESTRING` | `LINESTRING`의 집합 |
| `POLYGON` | 외부 링과 0개 이상의 내부 링(구멍을 나타냄)으로 구성된 구조 |
| `MULTIPOLYGON` | `POLYGON`의 집합 |
| `GEOMETRYCOLLECTION` | 위에서 언급된 모든 지오메트리의 집합 |

```{r}
#| echo: false
#| eval: false
#| label: fig-3-1
#| fig-cap: "심플 피처 지오메트리의 주요 유형"

library(sf) |> suppressPackageStartupMessages()
par(mfrow = c(2,4))
par(mar = c(1,1,1.2,1))

# 1
p <- st_point(0:1)
plot(p, pch = 16)
title("point")
box(col = 'grey')

# 2
mp <- st_multipoint(rbind(c(1,1), c(2, 2), c(4, 1), c(2, 3), c(1,4)))
plot(mp, pch = 16)
title("multipoint")
box(col = 'grey')

# 3
ls <- st_linestring(rbind(c(1,1), c(5,5), c(5, 6), c(4, 6), c(3, 4), c(2, 3)))
plot(ls, lwd = 2)
title("linestring")
box(col = 'grey')

# 4
mls <- st_multilinestring(list(
  rbind(c(1,1), c(5,5), c(5, 6), c(4, 6), c(3, 4), c(2, 3)),
  rbind(c(3,0), c(4,1), c(2,1))))
plot(mls, lwd = 2)
title("multilinestring")
box(col = 'grey')

# 5 polygon
po <- st_polygon(list(rbind(c(2,1), c(3,1), c(5,2), c(6,3), c(5,3), c(4,4), c(3,4), c(1,3), c(2,1)),
    rbind(c(2,2), c(3,3), c(4,3), c(4,2), c(2,2))))
plot(po, border = 'black', col = '#ff8888', lwd = 2)
title("polygon")
box(col = 'grey')

# 6 multipolygon
mpo <- st_multipolygon(list(
    list(rbind(c(2,1), c(3,1), c(5,2), c(6,3), c(5,3), c(4,4), c(3,4), c(1,3), c(2,1)),
        rbind(c(2,2), c(3,3), c(4,3), c(4,2), c(2,2))),
    list(rbind(c(3,7), c(4,7), c(5,8), c(3,9), c(2,8), c(3,7)))))
plot(mpo, border = 'black', col = '#ff8888', lwd = 2)
title("multipolygon")
box(col = 'grey')

# 7 geometrycollection
gc <- st_geometrycollection(list(po, ls + c(0,5), st_point(c(2,5)), st_point(c(5,4))))
plot(gc, border = 'black', col = '#ff6666', pch = 16, lwd = 2)
title("geometrycollection")
box(col = 'grey')

```

![심플 피처 지오메트리의 주요 유형](https://r-spatial.org/book/03-Geometries_files/figure-html/fig-sfgeometries-1.png){#fig-3-1}

그림 3.1은 이러한 기본 지오메트리 유형의 예를 보여준다. 지오메트리를 표현하는, 사람이 읽을 수 있는 '웹 노운 텍스트(well-known text)' WKT 표기법은 다음과 같다.

```         
POINT (0 1)
MULTIPOINT ((1 1), (2 2), (4 1), (2 3), (1 4))
LINESTRING (1 1, 5 5, 5 6, 4 6, 3 4, 2 3)
MULTILINESTRING ((1 1, 5 5, 5 6, 4 6, 3 4, 2 3), (3 0, 4 1, 2 1))
POLYGON ((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),
    (2 2, 3 3, 4 3, 4 2, 2 2))
MULTIPOLYGON (((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),
    (2 2, 3 3, 4 3, 4 2, 2 2)), ((3 7, 4 7, 5 8, 3 9, 2 8, 3 7)))
GEOMETRYCOLLECTION (
    POLYGON ((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),
      (2 2 , 3 3, 4 3, 4 2, 2 2)),
    LINESTRING (1 6, 5 10, 5 11, 4 11, 3 9, 2 8),
    POINT (2 5),
    POINT (5 4)
)
```

좌표는 공백으로 구분되며, 포인트들은 쉼표로 구분된다. 집합은 괄호로 묶이고, 각 요소는 쉼표로 구분된다. 폴리곤은 외부 링과, 존재할 경우 내부 링(구멍을 나타냄)으로 구성된다.

지오메트리의 각 포인트는 최소 두 개의 좌표를 포함하며, 이 좌표는 $x$와 $y$ 순서로 나열된다. 이 좌표가 타원체 좌표를 나타내는 경우, $x$는 일반적으로 경도를, $y$는 위도를 의미한다. 그러나 상황에 따라 위도-경도 순서로 나열되기도 한다(2.4절 및 섹션 7.7.6 참조).

### 심플 지오메트리, 밸리드 지오메트리, 링 디렉션

`LINESTRING`은 자기교차(self-intersect)가 없을 때 *심플* 지오메트리가 된다.(역자주: '자기교차’란 선분이 스스로를 가로지르는 경우를 말하며, 예를 들어 숫자 8 모양의 라인처럼 하나의 라인이 교차점을 형성하는 상황을 의미한다.)

```{r}
#| echo: false
#| eval: false
(ls <- st_linestring(rbind(c(0,0), c(1,1), c(2,2), c(0,2), c(1,1), c(2,0))))
```

```{r}
#| echo: false
#| eval: false
c(is_simple = st_is_simple(ls))
```

```         
# LINESTRING (0 0, 1 1, 2 2, 0 2, 1 1, 2 0)
```

```         
# is_simple 
#     FALSE
```

밸리드(valid) 폴리곤과 멀티폴리곤은 다음의 모든 프로퍼티을 갖는다.

-   폴리곤 링은 닫혀 있어야 한다(즉, 첫번째 포인트와 마지막 포인트가 동일해야 한다)

-   폴리곤 구멍(내부 링)은 외부 링 내부에 위치해야 한다.

-   폴리곤 내부 링은 외부 링과 한 점에서 만날 수 있으나, 선분(라인)은 공유해서는 안 된다.

-   폴리곤 링은 자신의 경로를 반복하지 않는다.

-   멀티폴리곤에서 외부 링은 다른 외부 링과 한 지점에서 만날 수 있지만, 선분을 공유해서는 안 된다.

이 조건들 중 하나라도 충족하지 못하면 해당 지오메트리는 밸리드 지오메트리가 아니다. 밸리드하지 않은 지오메트리는 일반적으로 연산 수행 중 오류를 일으키지만, 보통 사전에 밸리드 지오메트리로 수정된다.(역자 주: 밸리드 지오메트리를 유지하는 것은 공간분석, 지도 제작, 공간 질의에서 신뢰할 수 있는 결과를 얻기 위한 필수 조건이다. 보통 '유효한', '정합한', '합당한' 지오메트리 등으로 번역되지만, 여기서는 프로그래밍 용어 및 함수명과의 일관성을 위해 '밸리드' 지오메트리라는 표기를 사용한다.)

추가적인 규칙으로, 폴리곤의 외부 링은 반시계 방향으로, 구멍(내부 링)은 시계 방향으로 감겨 있어야 한다.(역자 주: 여기서 ‘감기다’는 것은 폴리곤 경계를 따라 점들이 연결되는 방향을 의미한다. 외부 링은 반시계 방향으로 이동할 때 왼쪽이 폴리곤 내부가 되고, 내부 링은 시계 방향으로 이동할 때 왼쪽이 폴리곤 내부, 오른쪽이 구멍(빈 공간)임을 나타낸다. 이 방향 규칙은 컴퓨터가 폴리곤 내부와 구멍을 정확히 구분하는 데 필수적이다.) 그러나 이러한 규칙을 따르지 않는 폴리곤도 여전히 밸리드 지오메트리로 간주된다. 구면상의 폴리곤의 경우 ‘시계 방향’이라는 개념은 크게 유용하지 않다. 예를 들어, 적도를 폴리곤으로 간주할 때 북반구와 남반구 중 어느 쪽이 ‘내부’인지 명확하지 않기 때문이다. 이 책에서는 폴리곤 경계를 따라 이동할 때 왼쪽에 위치한 영역을 폴리곤 내부로 간주하는 규칙을 채택한다(7.3절 참조).

### Z 좌표와 M 좌표

심플 피처 지오메트리의 단일 포인트(버텍스)는 `X` 좌표와 `Y` 좌표 외에도 다음과 같은 값을 가질 수 있다.

-   `Z` 좌표: 고도

-   `M` 좌표: 측정치

`M` 속성은 버텍스의 속성으로 간주되어야 한다. 예를 들어, `LINESTRING`에 이동 경로 데이터를 담기 위해 시간 정보를 `M` 속성에 인코딩하는 것은 매력적인 방법처럼 보일 수 있다. 그러나 경로가 자기교차하면, 이러한 `LINESTRING`은 밸리드하지 않거나 심플하지 않는 상태가 되는데, 이때의 자기교차 여부는 `X`와 `Y` 좌표만을 기준으로 판단된다.

`Z`와 `M`은 자주 사용되지 않으며, 이를 지원하는 소프트웨어도 아직까지는 드문 편이다. 그럼에도 불구하고, WKT에서의 `Z`와 `M` 표기는 비교적 쉽게 이해할 수 있다.

```{r}
#| echo: false
#| eval: false
#| message: true
st_point(c(1,3,2))
```

```{r}
#| echo: false
#| eval: false
#| message: true
st_point(c(1,3,2), dim = "XYM")
```

```{r}
#| echo: false
#| eval: false
#| message: true
st_linestring(rbind(c(3,1,2,4), c(4,4,2,2)))
```

```         
# POINT Z (1 3 2)
```

```         
# POINT M (1 3 2)
```

```         
# LINESTRING ZM (3 1 2 4, 4 4 2 2)
```

### 엠프티 지오메트리

피쳐 지오메트리 프레임워크에서 중요한 개념 중 하나가 엠프티(empty) 지오메트리이다. 엠프티 지오메트리는 기하학적 연산(3.2절) 수행 과정에서 자연스럽게 생성된다. 예를 들어 `POINT (0 0)`과 `POINT (1 1)`의 교차(intersection) 여부를 검토한다고 하자.

```{r}
#| echo: false
#| eval: false
#| message: true

(e <- st_intersection(st_point(c(0,0)), st_point(c(1,1))))
# GEOMETRYCOLLECTION EMPTY

```

```         
# GEOMETRYCOLLECTION EMPTY
```

두 포인트는 인터섹트하지 않으므로 엠프티 집합이 도출된다. 엠프티 포인트를 비엠프티 지오메트리와 결합(합집합 연산)하면, 엠프티 포인트는 결과에서 사라진다.

모든 지오메트리 유형은 다음과 같이 엠프티 지오메트리를 나타내는 특별한 값을 가진다.

```{r}
#| echo: false
#| eval: false
#| message: true
st_point()
```

```{r}
#| echo: false
#| eval: false
#| message: true
st_linestring(matrix(1,1,3)[0,], dim = "XYM")
```

```         
# POINT EMPTY
```

```         
# LINESTRING M EMPTY
```

엠프티 집합이 생성된다는 점은 동일하고 디멘션이 다를 뿐이다(3.2절 참조).

### 10개의 부수적인 지오메트리

다음의 열 가지 지오메트리는 사용 빈도는 낮지만 점점 증가하는 추세에 있다.

| 유형 | 설명 |
|----|----|
| `CIRCULARSTRING` | 기본적인 곡선 유형으로, 직선 유형의 LINESTRING과 유사. 단일 세그먼트를 구성하려면 세 점이 필요하며, 이들은 시작점과 끝점(첫 번째와 세 번째 점) 그리고 호 상의 중간 점임. 예외적으로 닫힌 원의 경우에는 시작점과 끝점이 동일하며, 두 번째 점은 반드시 호의 중심, 즉 원의 반대편에 위치해야 함. 호를 연결할 때는 이전 호의 마지막 점이 다음 호의 첫 번째 점과 일치해야 하는데, 이는 `LINESTRING`에서도 동일한 규칙임. 따라서 유효한 문자열은 반드시 1보다 큰 홀수 개의 점을 가져야 함. |
| `COMPOUNDCURVE` | 곡선 세그먼트와 선형 세그먼트를 모두 포함하는 단일 연속 곡선. 구성 요소들이 잘 연결되어 있어야 하며, 모든 구성 요소의 끝점(마지막을 제외한)은 다음 구성 요소의 시작점과 일치해야 함. |
| `CURVEPOLYGON` | `COMPOUNDCURVE`가 내재된 사례: `CURVEPOLYGON( COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1))` |
| `MULTICURVE` | 곡선으로 이루어진 1차원 지오메트리 컬렉션. 라인 문자열, 서큘러 문자열 또는 컴파운드 문자열을 포함할 수 있음. |
| `MULTISURFACE` | 동일한 CRS를 사용하는 `SURFACE`로 구성된 2차원 지오메트리 컬렉션 |
| `CURVE` | 일반적으로 여러 점의 연결로 정의되는 1차원 지오메트리 객체로, 점들 간의 인터폴레이션 방식에 따라 커브의 하위 유형이 결정됨. |
| `SURFACE` | 2차원 지오메트리 객체 |
| `POLYHEDRALSURFACE` | 공통 경계 세그먼트를 공유하는 연속된 폴리곤들의 집합 |
| `TIN` | 오직 삼각형으로만 구성된 `POLYHEDRALSURFACE` |
| `TRIANGLE` | 세 개의 비공선적(non-collinear) 버텍스로 이루어진, 내부 경계가 없는 폴리곤(역자주: 세 점이 일직선 상에 놓이지 않음을 의미한다.) |

`CIRCULARSTRING`, `COMPOUNDCURVE`, `CURVEPOLYGON`은 SFA 표준에는 포함되지 않지만, SQL-MM Part 3 표준에는 포함되어 있다. 위 표의 설명은 PostGIS 매뉴얼에서 인용한 것이다.

### 텍스트 인코딩과 바이너리 인코딩

심플 피처 표준에는 두 가지 인코딩 방식이 포함된다. 하나는 텍스트 인코딩(text encoding), 다른 하나는 바이너리 인코딩(binary encoding)이다. 위에서 사용된 WKT는 사람이 읽을 수 있는(human-readable) 방식이며, WKB(well-known binary) 인코딩은 기계가 읽을 수 있는(machine-readable) 방식이다. WKB 인코딩은 정보 손실이 없으며, 일반적인 텍스트 인코딩 및 디코딩보다 처리 속도가 빠르다. 이러한 이유로 WKB 인코딩은 R의 **sf** 패키지와 GDAL, GEOS, liblwgeom, s2geometry 라이브러리 간의 모든 통신에 사용된다(그림 1.7).

## 지오메트리에 적용되는 연산

심플 피처 지오메트리의 속성을 추출할 수 있으며, 심플 피처 지오메트리들의 결합으로 새로운 지오메트리가 생성된 경우에도 그 속성을 추출할 수 있다. 이 절에서는 *기하* 속성에만 초점을 맞춘 연산을 간략히 다룬다. 비기하학적 피처 속성 분석은 5장에서 다룬다. 이 절의 일부 내용은 Pebesma (2018)에서 가져왔다.

기하학적 속성에 대한 연산은 입력과 출력에 따라 분류할 수 있다. 먼저, 출력 관점에서 다음과 같이 구분된다.

-   **프레디케이트**(predicate): 특정 속성이 `TRUE`인지 여부를 판단하는 논리값

-   **측도**(measure): 양적 값(수치이며 측정 단위가 가질 수 있음)

-   **변형**(transformation): 새롭게 생성된 지오메트리

연산은 적용 대상 지오메트리의 수에 따라 다음과 같이 분류할 수 있다.

-   **단항**(unary): 단일 지오메트리에 적용

-   **이항**(binary): 두 개의 지오메트리 쌍에 적용

-   **다항**(n-ary): 여러 지오메트리 집합에 적용

### 단항 프레디케이트

단항 프레디케이트는 하나의 지오메트리의 특정 속성을 설명한다. `is_simple`, `is_valid`, `is_empty`와 같는 프레디케이트는 각각 지오메트리가 심플한지, 밸리드한지, 엠프티한지의 여부를 논리값을 반환한다. `is_longlat` 프레디케이트는 주어진 CRS가 경위도 좌표계인지, 평면 좌표계인지 여부를 반환한다. `is(geometry, class)`는 지오메트리가 특정 클래스에 속하는지를 확인한다.

### 이항 프레디케이트와 DE-9IM

DE-9IM(Dimensionally Extended Nine-Intersection Model)(Clementini, Di Felice, and Oosterom 1993; Egenhofer and Franzosa 1991)은 2차원 공간($R^2$)에서 두 지오메트리 간의 정성적 관계를 설명하는 모형이다. 모든 지오메트리는 *디멘션* 값을 가진다.

-   포인트 지오메트리: 0

-   라인 지오메트리: 1

-   폴리곤 지오메트리: 2

-   엠프티 지오메트리: F(거짓)

모든 지오메트리는 내부(I), 경계(B), 외부(E)를 가지며, 이들 요소의 역할은 폴리곤의 경우 특히 명확하다.

-   **라인**의 경계는 종점에 의해 형성되고, 선상의 모든 비종점이 내부를 구성한다.

-   **포인트**는 0차원의 내부를 가지지만, 경계는 없다.

```{r}
#| echo: false
#| eval: false
#| label: fig-3-2
#| fig-cap: "DE-9IM: 폴리곤의 내부, 경계, 외부(행)와 라인스트링의 내부, 경계, 외부(열) 간의 교차"

library(sf)
polygon <- po <- st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0))))
p0 <- st_polygon(list(rbind(c(-1,-1), c(2,-1), c(2,2), c(-1,2), c(-1,-1))))
line <- li <- st_linestring(rbind(c(.5, -.5), c(.5, 0.5)))
s <- st_sfc(po, li)

par(mfrow = c(3,3))
par(mar = c(1,1,1,1))

# "1020F1102"
# 1: 1
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("I(pol)",intersect(),"I(line) = 1")))
lines(rbind(c(.5,0), c(.5,.495)), col = 'red', lwd = 2)
points(0.5, 0.5, pch = 1)

# 2: 0
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("I(pol)",intersect(),"B(line) = 0")))
points(0.5, 0.5, col = 'red', pch = 16)

# 3: 2
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("I(pol)",intersect(),"E(line) = 2")))
plot(po, col = '#ff8888', add = TRUE)
plot(s, col = c(NA, 'darkgreen'), border = 'blue', add = TRUE)

# 4: 0
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("B(pol)",intersect(),"I(line) = 0")))
points(.5, 0, col = 'red', pch = 16)

# 5: F
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("B(pol)",intersect(),"B(line) = F")))

# 6: 1
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("B(pol)",intersect(),"E(line) = 1")))
plot(po, border = 'red', col = NA, add = TRUE, lwd = 2)

# 7: 1
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("E(pol)",intersect(),"I(line) = 1")))
lines(rbind(c(.5, -.5), c(.5, 0)), col = 'red', lwd = 2)

# 8: 0
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("E(pol)",intersect(),"B(line) = 0")))
points(.5, -.5, col = 'red', pch = 16)

# 9: 2
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("E(pol)",intersect(),"E(line) = 2")))
plot(p0 / po, col = '#ff8888', add = TRUE)
plot(s, col = c(NA, 'darkgreen'), border = 'blue', add = TRUE)

```

![DE-9IM: 폴리곤의 내부, 경계, 외부(행)와 라인의 내부, 경계, 외부(열) 간의 교차(빨간색으로 표시)](https://r-spatial.org/book/03-Geometries_files/figure-html/fig-de9im-1.png){#fig-3-2}

그림 3.2는 폴리곤과 라인의 내부(I), 경계(B), 외부(E) 영역 간의 교차를 빨간색으로 표시한 것이다. 각 그래프의 제목에는 교차 결과로 도출되는 차원 값(0, 1, 2 또는 F)이 나타나 있다. 폴리곤 지오메트리와 라인 지오메트리 간의 관계는 이러한 차원 값의 조합으로 표현된다.

```{r}
#| echo: false
#| eval: false
#| message: true
st_relate(polygon, line)
```

```         
#      [,1]       
# [1,] "1020F1102"
```

첫 세 문자는 *첫 번째* 지오메트리(폴리곤)의 내부에 대한 것으로, 그림 3.2에서는 첫 번째 행에 배열되어 있다.(역자 주: 위의 9자리 문자는 그림 3.2에 나타난 9개 교차 결과의 차원을 표시한 것이다. 차원 값은 행 단위로 지그재그 방식—첫 번째 행은 왼쪽에서 오른쪽, 두 번째 행은 오른쪽에서 왼쪽—으로 읽는다.) 더 나아가, 지오메트리 쌍에 대해 *마스크*(mask) 문자열로 표현된 특정 조건의 만족 여부를 질의할 수 있다.(역자 주: 마스크 문자열은 원하는 지오메트리 간 공간 관계를 질의하거나 필터링할 수 있도록 해준다.) 예를 들어, 문자열 `"*0*******"`는 두 번째 지오메트리가 첫 번째 지오메트리의 내부와 하나 이상의 경계*점*을 공유할 때 `TRUE`로 평가된다. 여기서 기호 `*`는 차원 값(0, 1, 2 또는 F) 중 어느 것이든 올 수 있음을 의미한다. 이 경우, 마스크 문자열 `"T********"`를 사용하면 내부가 서로 교차하는 모든 지오메트리 쌍을 필터링할 수 있다. 여기서 기호 `T`는 차원 값이 0, 1, 2이면서 비엠프티 교차가 존재함을 뜻한다.

더 나아가, 이항 프레디케이트는 DE-9IM에서 규정된 정의를 활용하여 일반 언어의 동사 형태로 표현될 수 있다. 예를 들어, 프레디케이트 `equals`는 관계 `"T*F**FFF*"`와 동일하다. 어떤 두 지오메트리가 이 관계를 만족한다면, (위상적으로) 동일한 지오메트리로 간주할 수 있지만, 노드의 순서는 서로 다를 수 있다.

이항 프레디케이트를 나열하면 다음과 같다.

| 프레디케이트 | 의미 | 역프레디케이트 |
|----|----|----|
| `contains` | A 포인트 어느 것도 B의 외부에 있지 않다. | `within` |
| `contains_properly` | A는 B를 포함하며, B의 어떤 포인트도 A의 경계 상에 있지 않다. |  |
| `covers` | B의 어떤 포인트도 A의 외부에 있지 않다. | `covered_by` |
| `covered_by` | `covers`의 반대 | `covers` |
| `crosses` | A와 B는 일부 내부 포인트를 공유하지만 모든 포인트를 공유하는 것은 아니다. |  |
| `disjoint` | A와 B는 어떤 포인트도 서로 공유하지 않는다. | `intersects` |
| `equals` | A와 B는 위상적으로 동일하다. 노드 순서나 노드 수가 다를 수 있으며, A가 B를 포함하고 A가 B의 내부에 있는 것과 동일하다. |  |
| `equals_exact` | A와 B는 기하학적으로 동일하며, 노드 순서도 동일하다. |  |
| `intersects` | A와 B가 완전 분리의 관계를 가지지 않는다. | `disjoint` |
| `is_within_distance` | A가 주어진 거리보다 B에 더 가깝게 위치해 있다. |  |
| `within` | B의 어떤 포인트도 A의 외부에 있지 않다. | `contains` |
| `touches` | A와 B는 최소한 한 개의 경계 포인트를 공유한다. 내부 포인트를 공유하는 것은 아니다. |  |
| `overlaps` | A와 B가 다수의 포인트를 공유한다. 디멘션은 A와 B의 디멘션과 동일하다. |  |
| `related` | A와 B가 주어진 마스크 패턴을 준수하는지의 여부를 반환한다. |  |

위키피디어의 DE-9IM 페이지에서는 개별 동사에 해당하는 `relate` 마스크 패턴을 확인할 수 있다. 이는 *covers*와 *contains*처럼, 의미를 직관적으로 이해하기 어려운 동사(또는 그 반대 동사)가 존재하기 때문이다.

-   A가 B를 *컨테인*(contains) 하는 경우, B는 A의 외부나 *경계*와 어떤 포인트도 공유하지 않는다.

-   A가 B를 *커버*(covers) 하는 경우, B는 A의 외부와 어떤 포인트도 공유하지 않는다.

### 단항 측도

단항 측도(unary measure)는 하나의 지오메트리에 대해, 그 속성을 나타내는 측정값이나 양을 반환한다.

| 측도 | 반환값 |
|----|----|
| `dimension` | 포인트는 0, 라인은 1, 폴리곤은 2, 엠프티 지오메트리에 대해서는 `NA` |
| `area` | 지오메트리의 면적 |
| `length` | 라인 지오메트리의 길이 |

### 이항 측도

이항 측도(binary measure)는 두 지오메트리를 입력으로 받아, 그들 사이의 관계를 수치나 패턴으로 반환한다. 예를 들어, `distance`는 두 지오메트리 간의 거리를 반환하며, 질적 측도로서 마스크 없이 사용하는 `relate`는 관계 패턴을 제공한다. 두 지오메트리 간 기하학적 관계에 대한 자세한 설명은 3.2.2절에 제시되어 있다.

### 단항 변환자

단항 변환자(unary transformer)는 하나의 지오메트리에 작용하여, 새로운 지오메트리를 생성·반환한다.

| 변환자 | 반환 지오메트리 |
|----|----|
| `centroid` | 투입 지오메트리의 센트로이드로 구성된 `POINT` 유형의 지오메트리 |
| `buffer` | 투입 지오메트리보다 더 큰(혹은 더 작은) 지오메트리: 버퍼 사이즈에 따라 산출 지오메트리의 크기가 달라짐 |
| `jitter` | 이변량 균등 분포를 이용해 약간 위치가 변형된 지오메트리 |
| `wrap_dateline` | 날짜 변경선을 더 이상 덮거나 교차하지 않는 조각들로 분할된 지오메트리 |
| `boundary` | 투입 지오메트리의 경계를 가진 지오메트리 |
| `convex_hull` | 투입 지오메트리의 컨벡스헐을 가진 지오메트리(그림 3.3)(역자주: 컨벡스헐은 주어진 포인트 집합을 모두 포함하는 가장 작은 볼록 다각형을 의미한다.) |
| `line_merge` | `MULTILINESTRING` 내의 `LINESTRING` 요소들을 결합하여 더 긴 `LINESTRING`을 형성한 지오메트리 |
| `make_valid` | 밸리드하게 교정된 지오메트리 |
| `node` | 노드가 없는 교차점에 노드를 추가한 라인 지오메트리로 개별 라인 지오메트리에 적용 |
| `point_on_surface` | 서피스에 임의의 포인트를 가진 지오메트리 |
| `polygonize` | 폐쇄 링을 형성하는 라인으로부터 생성된 폴리곤 지오메트리 |
| `segmentize` | 주어진 밀도 또는 최소 거리를 만족하는 노드로 구성된 라인 지오메트리 |
| `simplify` | 버텍스/노드를 제거함으로써 단순화된 라인 혹은 폴리곤 지오메트리 |
| `split` | 라인스트링에 의해 분할된 지오메트리 |
| `transform` | 새로운 CRS로 변환 혹은 전환된 지오메트리(2장) |
| `triangulate` | 들로네 삼각망으로 구성된 지오메트리(그림 3.3)(역자주: 들로네 삼각망은 보로노이 테셀레이션과 상호 대응하는 삼각분할 방법으로, 점들을 삼각형으로 연결하되, 삼각형의 외접원 안에 다른 점이 들어가지 않도록 한다) |
| `voronoi` | 투입 지오메트리로부터 형성된 보로노이 테셀레이션(그림 3.3)(역자주: 보로노이 테셀레이션은 평면을 여러 구역으로 분할하는 방법으로, 각 구역 내의 모든 지점이 해당 구역의 중심점에 가장 가깝도록 정의된다.) |
| `zm` | `Z` 좌표 및 `M` 좌표가 수정된(일부 좌표의 삭제 혹은 새로운 좌표의 첨가) 지오메트리 |
| `collection_extract` | 특정 유형의 `GEOMETRYCOLLECTION`으로부터 일부를 추출한 지오메트리 |
| `cast` | 유형이 전환된 지오메트리 |
| `+` | 주어진 벡터만큼 전위된 지오메트리 |
| `*` | 스칼라 또는 매트릭스가 곱해진 지오메트리 |

```{r}
#| echo: false
#| eval: false
#| label: fig-3-3
#| fig-cap: "포인트의 집합, 왼편은 컨벡스헐(빨간색), 가운데는 보로노이 폴리곤, 오른편은 들로네 삼각망"

par(mar = rep(0,4), mfrow = c(1, 3))
set.seed(133331)
mp <- st_multipoint(matrix(runif(20), 10))
plot(mp, cex = 2)
plot(st_convex_hull(mp), add = TRUE, col = NA, border = 'red')
box()
plot(mp, cex = 2)
plot(st_voronoi(mp), add = TRUE, col = NA, border = 'red')
box()
plot(mp, cex = 2)
plot(st_triangulate(mp), add = TRUE, col = NA, border = 'darkgreen')
box()

```

![포인트의 집합, 왼편은 컨벡스헐, 가운데는 보로노이 폴리곤, 오른편은 들로네 삼각망](https://r-spatial.org/book/03-Geometries_files/figure-html/fig-vor-1.png){#fig-3-3}

### 이항 변환자

이항 변환자(binary transformer)는 두 지오메트리 쌍에 적용되어, 새로운 지오메트리를 생성하는 함수이다. 예를 들어, 다음과 같은 연산이 이에 해당한다.

| 함수 | 반환 지오메트리 | 인픽스 오퍼레이터 |
|----|----|----|
| `intersection` | 두 지오메트리의 겹치는 부분에 대한 지오메트리 | `&` |
| `union` | 두 지오메트리를 결합한 지오메트리로, 내부 경계를 제거하고, 중복되는 포인트, 노드, 또는 라인을 삭제 | `|` |
| `difference` | 두 번째 지오메트리와 중복되는 부분을 제거한 첫 번째 지오메트리 | `/` |
| `sym_difference` | 중복되는 부분을 제거한 이후에 두 지오메트리를 결합한 지오메트리로 `intersection`의 반대 | `%/%` |

### 다항 변환자

다항 변환자(n-ary transformer)는 지오메트리의 집합에 작용한다. `union` 연산을 적용하면 모든 지오메트리를 결합한 결과를 얻을 수 있다. 반대로, 동일한 차원을 가진 지오메트리 집합은 `MULTI` 유형 지오메트리나 `GEOMETRYCOLLECTION`으로 결합할 수도 있다. 이 경우 `union`을 적용하지 않으므로, 예를 들어 두 폴리곤 링이 경계선을 공유하는 경우처럼 밸리드하지 않은 지오메트리가 생성될 수 있다.

다항 `intersection`과 `difference`는 단일 인수를 받는 형식이지만, 모든 쌍, 세 쌍, 네 쌍 등으로 확장되어 순차적으로 작동한다. 그림 3.4를 보자. 세 개의 상자가 모두 겹치는 영역을 어떻게 식별할 수 있을까? 이항 `intersection`을 사용하면 모든 쌍(1-1, 1-2, 1-3, 2-1, 2-2, 2-3, 3-1, 3-2, 3-3)에 대한 교차 결과를 얻을 수 있다. 그러나 이 방식만으로는 두 개 이상의 지오메트리가 동시에 교차하는 영역을 식별할 수 없다. 그림 3.4 오른쪽은 다항 `intersection`의 결과를 보여준다. 여기서는 하나, 둘, 혹은 그 *이상*의 지오메트리가 교차하여 생성된 7개의 상호 중복 없는 고유 지오메트리를 확인할 수 있다.

```{r}
#| echo: false
#| eval: false
#| label: "왼쪽: 세 개의 정사각형이 서로 겹치고 있는데, 이들 모두가 겹치는 부분을 어떻게 확인할 수 있을까? 오른쪽: 상호 중복이 없는 고유한 다항 교차"

par(mar = rep(.1, 4), mfrow = c(1, 2))
sq <- function(pt, sz = 1) st_polygon(list(rbind(c(pt - sz), 
  c(pt[1] + sz, pt[2] - sz), c(pt + sz), c(pt[1] - sz, pt[2] + sz), c(pt - sz))))
x <- st_sf(box = 1:3, st_sfc(sq(c(0, 0)), sq(c(1.7, -0.5)), sq(c(0.5, 1))))
plot(st_geometry(x), col = NA, border = sf.colors(3, categorical = TRUE), lwd = 3)
plot(st_intersection(st_geometry(x)), col = sf.colors(7, categorical=TRUE, alpha = .5))

```

![왼쪽: 세 개의 정사각형이 서로 겹치고 있는데, 이들 모두가 겹치는 부분을 어떻게 확인할 수 있을까? 오른쪽: 상호 중복이 없는 고유한 다항 교차](https://r-spatial.org/book/03-Geometries_files/figure-html/fig-boxes-1.png){#fig-3-4}

유사하게, 집합 $\{s_1,s_2,s_3,...\}$에 다항 `difference`를 적용하면 $\{s_1,s_2-s_1,s_3-s_2-s_1,...\}$를 생성할 수 있다. 그 결과는 그림 3.5에 나타나 있다. 그림의 왼쪽은 원래 집합을, 오른쪽은 입력 지오메트리의 순서를 변경한 후의 집합을 보여준다. 이는 결과가 입력 지오메트리의 순서에 의존한다는 점을 명확히 하기 위함이다. 이렇게 얻어진 지오메트리들은 서로 겹치지 않는다.

```{r}
#| echo: false
#| eval: false
#| label: fig-3-5
#| fig-cap: "박스들에 서로 다른 순서로 differece를 적용한 결과: 왼쪽은 원래 순서이며, 오른쪽은 반대 순서"

par(mar = rep(.1, 4), mfrow = c(1, 2)) 
xg <- st_geometry(x)
plot(st_difference(xg), col = sf.colors(3, alpha = .5, categorical=TRUE))
plot(st_difference(xg[3:1]), col = sf.colors(3, alpha = .5, categorical=TRUE))

```

![박스들에 서로 다른 순서로 `differece`를 적용한 결과: 왼쪽은 원래 순서이며, 오른편은 반대 순서](https://r-spatial.org/book/03-Geometries_files/figure-html/fig-diff-1.png){#fig-3-5}

## 정밀도

기하학적 연산, 예를 들어 특정 점이 선 위에 있는지 여부를 판단하는 작업은, 좌표가 R에서 사용하는 8바이트 더블(double)과 같은 배정밀도 부동소수점 수로 표현될 경우 실패할 수 있다. 흔히 선택되는 해결책은 연산 전에 좌표의 정밀도(precision)를 제한하는 것이며, 이를 위해 *정밀도 모델*(precision model)이 사용된다. 가장 일반적인 방법은 하나의 계수 $p$를 선택하고, 원래 좌표 $c$를 반올림하여 새로운 좌표 $c'$를 계산하는 것이다.

$$
c'=\text {round} (p\cdot c)/p
$$

이러한 종류의 반올림은 좌표를 간격이 $1/p$ 인 규칙적인 그리드상의 점으로 변환하며, 이는 기하학적 연산에 유용하다. 그러나 이 반올림은 면적이나 거리와 같은 모든 계산에 영향을 미칠 수 있으며, 경우에 따라 밸리드 지오메트리를 무효화할 수도 있다. 특정 응용 분야에 가장 적합한 정밀도 값은 일반적으로 경험과 시행착오를 통해 결정된다.

## 커버리지: 테셀레이션과 래스터

OGC(Open Geospatial Consortium, 오픈지리공간컨소시움)는 *커버리지*(coverage)를 “시공간 도메인 내 임의의 직접 위치에 대해, 그 범위에서 값을 반환하는 함수 역할을 하는 피처”라고 정의한다(Baumann, Hirschorn, and Masó 2017). *함수*가 존재한다는 것은 시공간 도메인 내 모든 '포인트', 즉 특정 지점과 특정 시점의 모든 조합에 대해 범위 내의 *단일* 값을 얻을 수 있다는 것을 의미한다.(역자주: 범위는 함수가 반환하는 값들의 집합을 의미하는데, 함수는 시공간 내 위치별로 이 범위 안에서 값을 반한한다는 의미이다.) 이는 시공간적 현상에서 매우 흔히 나타나는 상황으로, 몇 가지 예를 들 수 있다.

-   경계 분쟁을 제외하면, 특정 시점의 특정 지역 내 모든 지점(도메인)은 단일 행정 단위(범위)에 속한다.
-   특정 시점의 특정 지역 내 모든 지점(도메인)은 특정한 *토지피복유형*(land cover type)(범위)을 갖는다.
-   특정 지역(도메인)의 모든 지점은 단일한 고도값(범위)을 가지며, 이는 보통 주어진 평균 해수면을 기준으로 측정된다.
-   3차원 기체의 모든 시공간적 지점(도메인)은 온도(범위)에 대해 단일 값을 갖는다.

여기서 주의할 점은, 관찰이나 측정에는 항상 시간과 공간이 소요되므로, 측정된 값은 본질적으로 시공간적 부피(volume)에 대한 평균값일 수밖에 없다는 것이다. 따라서 범위 변수를 무부피의 ‘포인트’에서 직접 측정하는 경우는 매우 드물다. 그러나 실제 많은 사례에서 측정된 부피는 ‘포인트’로 간주할 만큼 충분히 작다. 예를 들어, *토지피복유형*과 같은 변수는 구별되는 유형이 측정된 면적 단위와 의미 있게 연관되도록, 적절한 부피 단위를 선택해야 한다.(역자 주: 토지피복과 같은 범주형 변수는 측정된 공간 단위가 해당 범주를 대표할 수 있도록 설정되어야 한다. 즉, 각 토지피복 유형이 관찰된 공간 범위 안에서 충분한 대표성을 가질 수 있도록 적절한 공간 단위로 측정해야 한다는 의미이다.)

위에서 제시한 네 가지 예 중 처음 두 가지의 범위 변수는 *범주형*이고, 마지막 두 가지는 *연속형*이다. 범주형 범위 변수의 경우, 넓은 지역이 동일한 값을 가진다면 이러한 데이터를 효율적으로 표현하는 방법은 동일한 값을 갖는 지역의 경계를 저장하는 것이다. 예를 들어, 국가 경계가 이에 해당한다. 이는 심플 피처 지오메트리(폴리곤 또는 멀티폴리곤)를 사용하여 표현할 수 있지만, 다음과 같은 몇 가지 도전 과제가 뒤따른다.

-   심플 피처 폴리곤은 서로 겹치지 않고 틈새도 없어야 하지만, 이러한 조건이 항상 보장되는 것은 아니다.

-   심플 피처는 인접한 두 폴리곤의 경계에 위치한 포인트를 하나의 폴리곤에만 할당할 수 없는데, 이는 커버리지로서의 해석과 충돌한다.

### 토폴로지 모형

폴리곤 커버리지에서 겹침과 틈새가 없도록 보장하는 데이터 모형을 *토폴로지* 모형(topological model)이라 하며, GRASS GIS나 ArcGIS와 같은 지리정보시스템(GIS)에서 그 예를 확인할 수 있다. 토폴로지 모형에서는 폴리곤 경계를 한 번만 저장하고, 그 경계의 양쪽에 위치한 폴리곤을 함께 등록한다.

토폴로지 모형에서 동일한 범위 값을 가진 지역에 대해 (멀티)폴리곤 집합을 도출하는 것은 비교적 간단하다. 그러나 폴리곤 집합으로부터 토폴로지를 재정의하는 역과정을 수행하려면, 오류에 대한 임계값 설정과 더불어 겹침 및 틈새를 처리하는 구체적인 방법을 고려해야 한다.

### 래스터 테셀레이션

테셀레이션(tessellation)은 2차원 또는 3차원의 공간을 폴리곤으로 구성된 더 작은 요소들로 세분화하는 것을 의미한다. 규칙(regular) 테셀레이션은 삼각형, 사각형, 육각형과 같은 규칙 폴리곤으로 이루어진 테셀레이션을 뜻한다. 공간데이터에서 일반적으로 사용되는 정사각형 기반 테셀레이션을 *래스터* 데이터(raster data)라고 부른다. 래스터 데이터는 공간 차원 $d$를 규칙 셀로 나누며, 각 셀 $d_i$ 는 좌측 닫힘 및 우측 개방 범위(구간)로 정의된다.(역자주: 좌측 닫힘 우측 개방 범위란 구간의 왼쪽 끝점은 포함하지만, 오른쪽 끝점은 포함하지 않는다는 의미이다.)

$$
d_i=d_0+[i\times \delta,(i+1)\times \delta)
$$

여기서 $d_0$는 오프셋 값이고, $\delta$는 구간(셀 또는 픽셀)의 크기이다. 셀 인덱스 $i$는 임의의 값을 가질 수 있지만, 반드시 연속적인 정수여야 한다. $\delta$는 $y$축(북거)의 경우 보통 음수 값을 갖는데, 이는 래스터의 행 번호가 남쪽으로 갈수록 증가하는 반면 $y$ 좌표값은 감소하기 때문이다.

일반적인 폴리곤 테셀레이션에서는 두 폴리곤이 공유하는 경계에 위치한 점의 할당이 모호할 수 있다. 그러나 규칙 테셀레이션에서는 좌측 닫힘(`[`) 및 우측 개방(`)`) 구간을 사용하여 이러한 모호성을 해소한다. 이는 $y$ 좌표에 음의 $\delta$ 값이, $x$ 좌표에 양의 $\delta$ 값이 적용된 래스터의 경우, 각 셀의 모서리 점들 중 좌측 상단의 점만을 해당 셀의 일부로 간주한다는 의미이다. 이로 인해 발생할 수 있는 예기치 못한 결과의 한 예가 그림 3.6에 나타나 있다.

```{r}
#| echo: false
#| eval: false
#| label: fig-3-6
#| fig-cap: "래스터화의 예기치 못한 결과: 각 셀의 좌측 상단 지점만 셀 내부로 간주되기 때문에 대각선 아래에 위치하면서 붉은 선과 에 접촉한 셀들도 래스터로 전환되었다."

library(stars) |> suppressPackageStartupMessages()
par(mar = rep(1, 4))
ls <- st_sf(a = 2, st_sfc(st_linestring(rbind(c(0.1, 0), c(1, .9)))))
grd <- st_as_stars(st_bbox(ls), nx = 10, ny = 10, xlim = c(0, 1.0), ylim = c(0, 1),
   values = -1)
r <- st_rasterize(ls, grd, options = "ALL_TOUCHED=TRUE")
r[r == -1] <- NA
plot(st_geometry(st_as_sf(grd)), border = 'orange', col = NA, 
     reset = FALSE, key.pos = NULL)
plot(r, axes = FALSE, add = TRUE, breaks = "equal", main = NA) # ALL_TOUCHED=FALSE;
plot(ls, add = TRUE, col = "red", lwd = 2)

```

![래스터화의 예기치 못한 결과: 각 셀의 좌측 상단 지점만 셀 내부로 간주되기 때문에, 대각선 아래에 위치하면서 붉은 선과 접촉한 셀들도 래스터로 전환되었다.](https://r-spatial.org/book/03-Geometries_files/figure-html/fig-rasterizeline-1.png){#fig-3-6}

시간 차원을 좌측 닫힘 및 우측 개방 구간으로 세분하는 것은 매우 일반적인 방식이며, 이는 R의 **xts** 패키지와 같은 시계열 소프트웨어에서 암묵적인 기본 가정이기도 하다. 즉, 시간 스탬프(시점)는 해당 시간 간격의 시작을 나타낸다. 다른 모형과 결합하는 것도 가능하다. 예를 들어, 심플 피처 폴리곤을 사용해 공간을 세분하고 이를 규칙 시간 테셀레이션과 결합하면, 시공간 *벡터 데이터 큐브*(vector data cube) 개념을 구현할 수 있다. 래스터 및 벡터 데이터 큐브에 관한 논의는 6장에서 다룬다.

앞서 언급했듯이, $R^2$에 대한 규칙 테셀레이션을 생성할 때는 정사각형뿐 아니라 삼각형과 육각형 폴리곤을 사용할 수 있다. 이를 3차원 구체로 확장하면 큐브, 정팔면체, 정이십면체, 정십이면체 등 다양한 형태가 가능하다. 큐브 기반 공간 인덱스에는 s2geometry가 있으며, H3 라이브러리는 정이십면체를 기반으로 하면서 밀집화 과정에서 주로 육각형을 사용한다. 지구 전체를 포괄하는 이러한 모자이크는 일반적으로 *이산 글로벌 그리드*(discrete global grid)라고 불린다.

## 네트워크

공간적 네트워크는 일반적으로 라인(`LINESTRING`) 요소로 구성되지만, 네트워크로서의 완결성을 위해 추가적인 위상적 특성을 갖는다.

-   라인스트링의 시작점과 끝점은 다른 라인스트링의 시작점이나 끝점에 연결될 수 있으며, 이를 통해 노드와 엣지의 집합이 형성된다.

-   엣지는 방향성을 가질 수 있으며, 이 경우 연결(흐름, 수송)은 한 방향으로만 가능하다.

**osmar**(Schlesinger and Eugster 2013), **stplanr**(Lovelace, Ellison, and Morgan 2022), **sfnetworks**(van der Meer et al. 2022)와 같은 R 패키지는 네트워크 객체를 구성하고 이를 다루는 기능을 제공하며, 네트워크를 통한 최단 또는 최속 경로 계산을 지원한다. **spatstat** 패키지(Baddeley, Turner, and Rubak 2022; Baddeley, Rubak, and Turner 2015)는 선형 네트워크 상에서도 포인트 패턴 분석 기능을 제공한다(11장). Lovelace, Nowosad, and Muenchow(2019)의 12장은 네트워크 데이터를 활용한 교통 애플리케이션을 다룬다.

## 연습문제

다음의 연습문제를 풀되, 적절한 부분에서 R을 활용하라.

1.  2차원(평면) 공간에서 심플 피처 지오메트리로 표현할 수 없는 지오메트리의 두 가지 예를 제시하고, 그림으로 표현하시오.

2.  좌표 10.542, 0.01, 45321.6789를 정밀도 값 1, 1e3, 1e6, 및 1e-2를 사용하여 재계산하시오.

3.  다항 교차가 필요한 실제 문제 사례를 제시하시오.

4.  지점별로 하나의 폐쇄 폴리곤을 가지는 보로노이 다이어그램(그림 3.3)을 만드는 방법을 설명하시오.

5.  다음의 지오메트리에 대해 단항 측도 `dimension`을 계산하시오. `POINT Z (0 1 1)`, `LINESTRING Z (0 0 1,1 1 2)`, `POLYGON Z ((0 0 0,1 0 0,1 1 0,0 0 0))`

6.  `LINESTRING(0 0,1 0)`과 `LINESTRING(0.5 0,0.5 1)`의 DE-9IM 관계를 설명하고, 각 문자의 의미도 함께 설명하시오.

7.  심플 피처 폴리곤의 집합을 하나의 커버리지를 만들 수 있는지 답하시오. 가능하다면, 어떤 제약 조건에서 가능한지 설명하시오.

8.  **sf** 패키지의 `nc` 카운티 데이터를 사용하여 네 개의 카운티가 동시에 접촉하는 포인트들을 추출하시오.

9.  $y$축에 대한 $\delta$ 값이 양수일 경우, 그림 3.6은 어떻게 달라지는지 설명하시오.
