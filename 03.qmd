---
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
---

# 지오메트리 {#sec-geometry}

2장에서 좌표계에 대해 배웠기 때문에 이 장에서는 좌표계를 이용하여 지오메트리를 어떻게 정의할 수 있는지에 대해 배울 것이다. 다음의 사항이 다루어진다.

-   심플 피처(simple feature): 포인트, 라인, 폴리곤 지오메트리를 다루는 표준

-   지오메트리에 적용되는 오퍼레이션

-   커버리지(coveratge): 공간 혹은 시공간의 함수

-   테셀레이션(tessellation): 하나의 지역을 여러개의 하위지역으로 분할한 것

-   네트워크

구면 지오메트리는 4장에서 논의되며, 래스터와 공간 혹은 시공간을 직사각형 형태로 분할한 또 다른 세분 체계는 6장에서 다룬다.

## 심플 피쳐 지오메트리

심플 피처 지오메트리는 피처의 지오메트리를 설명하는 방법이다. 여기서 피처란 지오메트리를 가진 사물을 의미하는데, 암묵적으로 시간 속성을 가질 수 있고, 사물 자체를 묘사하기 위한 라벨이나 사물을 정량적으로 측정한 값과 관련된 속성을 가질 수 있다. 단순 피처 지오메트리의 주된 용도는 2차원 공간의 기하학적 형태를 포인트, 라인, 또는 폴리곤에 의거해 설명하는 것이다. "단순"이라는 형용사가 붙은 이유는 라인이나 폴리곤 지오메트리 역시 포인트 지오메트리와 그것을 연결한 직선으로 표현될 수 있기 때문이다.

심플 피처 억세스(access)는 심플 피처 지오메트리를 설명하는 표준으로(Herring 2011, 2010; ISO 2004), 다음의 사항이 포함되어 있다.

-   클래스 위계

-   오퍼레이션의 집합

-   이항 엔코딩과 텍스트 엔코딩

먼저 가장 일반적으로 사용되는 7가지 단순 피처 지오메트리 유형에 대해 논의할 것이다.

### 7개의 대표 지오메트리

단일(single) 피처를 나타내기 위해 사용되는 가장 일반적인 심플 피처 지오메트리 유형은 다음과 같다.

| 유형 | 설명 |
|------------------------------------|------------------------------------|
| `POINT` | 단일 포인트 지오메트리 |
| `MULTIPOINT` | 포인트의 집합 |
| `LINESTRING` | 단일 라인스트링(두개 이상의 포인트가 직선으로 연결되어 있음) |
| `MULTILINESTRING` | 라인스트링의 집합 |
| `POLYGON` | 내부 링(구멍을 의미)을 가질 수 있는 외부 링 |
| `MULTIPOLYGON` | 폴리곤의 집합 |
| `GEOMETRYCOLLECTION` | 위에서 언급된 모든 지오메트리의 집합 |

```{r}
#| echo: false
#| label: fig-3-1
#| fig-cap: "심플 피처 지오메트리의 주요 유형"

library(sf) |> suppressPackageStartupMessages()
par(mfrow = c(2,4))
par(mar = c(1,1,1.2,1))

# 1
p <- st_point(0:1)
plot(p, pch = 16)
title("point")
box(col = 'grey')

# 2
mp <- st_multipoint(rbind(c(1,1), c(2, 2), c(4, 1), c(2, 3), c(1,4)))
plot(mp, pch = 16)
title("multipoint")
box(col = 'grey')

# 3
ls <- st_linestring(rbind(c(1,1), c(5,5), c(5, 6), c(4, 6), c(3, 4), c(2, 3)))
plot(ls, lwd = 2)
title("linestring")
box(col = 'grey')

# 4
mls <- st_multilinestring(list(
  rbind(c(1,1), c(5,5), c(5, 6), c(4, 6), c(3, 4), c(2, 3)),
  rbind(c(3,0), c(4,1), c(2,1))))
plot(mls, lwd = 2)
title("multilinestring")
box(col = 'grey')

# 5 polygon
po <- st_polygon(list(rbind(c(2,1), c(3,1), c(5,2), c(6,3), c(5,3), c(4,4), c(3,4), c(1,3), c(2,1)),
    rbind(c(2,2), c(3,3), c(4,3), c(4,2), c(2,2))))
plot(po, border = 'black', col = '#ff8888', lwd = 2)
title("polygon")
box(col = 'grey')

# 6 multipolygon
mpo <- st_multipolygon(list(
    list(rbind(c(2,1), c(3,1), c(5,2), c(6,3), c(5,3), c(4,4), c(3,4), c(1,3), c(2,1)),
        rbind(c(2,2), c(3,3), c(4,3), c(4,2), c(2,2))),
    list(rbind(c(3,7), c(4,7), c(5,8), c(3,9), c(2,8), c(3,7)))))
plot(mpo, border = 'black', col = '#ff8888', lwd = 2)
title("multipolygon")
box(col = 'grey')

# 7 geometrycollection
gc <- st_geometrycollection(list(po, ls + c(0,5), st_point(c(2,5)), st_point(c(5,4))))
plot(gc, border = 'black', col = '#ff6666', pch = 16, lwd = 2)
title("geometrycollection")
box(col = 'grey')

```

그림 3.1은 이러한 기본 지오메트리 유형의 예를 보여준다. 지오메트리를 표현한 사람이 읽을 수 있는 WKT 표기법은 다음과 같다.

``` r
POINT (0 1)
MULTIPOINT ((1 1), (2 2), (4 1), (2 3), (1 4))
LINESTRING (1 1, 5 5, 5 6, 4 6, 3 4, 2 3)
MULTILINESTRING ((1 1, 5 5, 5 6, 4 6, 3 4, 2 3), (3 0, 4 1, 2 1))
POLYGON ((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),
    (2 2, 3 3, 4 3, 4 2, 2 2))
MULTIPOLYGON (((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),
    (2 2, 3 3, 4 3, 4 2, 2 2)), ((3 7, 4 7, 5 8, 3 9, 2 8, 3 7)))
GEOMETRYCOLLECTION (
    POLYGON ((2 1, 3 1, 5 2, 6 3, 5 3, 4 4, 3 4, 1 3, 2 1),
      (2 2 , 3 3, 4 3, 4 2, 2 2)),
    LINESTRING (1 6, 5 10, 5 11, 4 11, 3 9, 2 8),
    POINT (2 5),
    POINT (5 4)
)
```

좌표는 공백으로 구분되고, 포인트는 쉼표로 구분된다. 집합은 괄호로 묶여 있으며, 쉼표로 구분된다. 폴리곤은 외부 링과 (만일 있다면) 내부 링(구멍을 나타냄)으로 구성된다.

지오메트리의 개별 포인트는 최소한 두 개의 좌표를 포함하며, 이 좌표는 x와 y 순서로 나열된다. 이 좌표가 타원체 좌표를 나타내는 경우, x는 일반적으로 경도를, y는 위도를 의미하지만, 경우에 따라 위도와 경도의 순서로 나열될 수도 있다(섹션 2.4 및 섹션 7.7.6 참조).

### 심플 지오메트리, 타당한 지오메트리, 링 디렉션

라인리스팅은 자기 교차하지 않을 때 심플이라고 부를 수 있다.

```{r}
#| echo: false
#| message: true

(ls <- st_linestring(rbind(c(0,0), c(1,1), c(2,2), c(0,2), c(1,1), c(2,0))))

```

```{r}
#| echo: false
#| message: true

c(is_simple = st_is_simple(ls))

```

타당한 폴리곤과 멀티폴리곤은 다음의 모든 프로프티를 보유한다.

-   폴리곤 링은 닫혀있다(첫번째 포인트와 마지막 포인트는 동일하다)

-   폴리곤 구멍(내부 링)은 외부 링의 안쪽에 있다.

-   폴리곤 내부 링은 외부 링과 한 지점에서 만날 수는 있지만 라인을 공유할 수는 없다.

-   폴리곤 링은 자신의 경로를 반복하지 않는다.

-   멀티폴리곤에서 외부 링은 다른 외부 링과 한 지점에서 만날 수는 있지만 라인을 공유할 수는 없다.

이것들 어느 하나라도 만족시키지 못한다면 해당 지오메트리는 타당하지 않다. 타당하지 않는 지오메트리는 일반적으로 오퍼레이션 과정에서 오류를 발생시키지만, 보통 사전에 타당한 지오메트리로 수정된다.

또 다른 규칙은 폴리곤의 외부 링은 반시계 방향으로 감겨야 하며, 구멍은 시계 방향으로 감겨야 한다는 것이다. 그러나 이러한 규칙을 따르지 않는 폴리곤도 여전히 타당한 것으로 간주된다. 이러한 '시계 방향' 개념은 구체에서의 그리 유용하지 않다. 예를 들어, 적도를 폴리곤으로 간주할 경우, 북반구와 남반구 중 어느 쪽이 '내부'라고 할 수 있는가? 여기서 채택된 규칙은 폴리곤을 변을 시계 방향으로 탐색할 때 왼쪽에 있는 영역을 폴리곤의 내부로 간주하는 것이다(7.3절 참조).

### Z 좌표와 M 좌표

심플 피처 지오메트리의 단일 포인트(버텍스)는 X 좌표와 Y 좌표 외에 다음을 가질 수 있다.

-   Z 좌표: 고도

-   M 좌표: 측정치

M 속성이 버텍스의 프로퍼티라는 점을 염두에 두면 M 좌표는 유용하게 사용될 수 있을 것으로 보인다. 예를 들어, LINESTRING을 통해 일종의 경로 데이터를 엔코딩한다고 하면, 개별 버텍스에 시간 속성을 할당할 수 있다. 그러나 경로가 자기-교차하게 되면 비타당 혹은 비심플(non-simple)이 된다. 자기-교차성을 검토하기 위해 X 좌표와 Y 좌표만을 고려할 때는 드러나지 않는다.

Z와 M은 자주 사용되지 않으며, 이를 유용하게 활용할 수 있는 소프트웨어 지원도 (아직) 드물다. 그래도 Z와 M의 WKT 표현은 비교적 쉽게 이해할 수 있다.

```{r}
#| echo: false
#| message: true

st_point(c(1,3,2))

```

```{r}
#| echo: false
#| message: true

st_point(c(1,3,2), dim = "XYM")

```

```{r}
#| echo: false
#| message: true

st_linestring(rbind(c(3,1,2,4), c(4,4,2,2)))

```

### 엠프티 지오메트리

피쳐 지오메트리 프레임워크에서 매우 중요한 개념이 엠프티(empty) 지오메트리이다. 엠프티 지오메트리는 기하학적 오퍼레이션(3.2절)을 실행할 때 자연스럽게 생성된다. 예를 들어 `POINT (0 0)`과 `POINT (1 1)`의 인터섹션 여부를 검토한다고 하자.

```{r}
#| echo: false
#| message: true

(e <- st_intersection(st_point(c(0,0)), st_point(c(1,1))))
# GEOMETRYCOLLECTION EMPTY

```

두 포인트는 교차하지 않으므로 엠프티 집합이 도출된다. 엠프티 포인트를 비어있지 않은 지오메트리와 결합하면(합집합을 구하면) 엠프티 포인트는 소실된다.

모든 지오메트리 유형은 엠프티 지오메트리를 나타내는 특정한 값을 가지고 있다.

```{r}
#| echo: false
#| message: true

st_point()

```

```{r}
#| echo: false
#| message: true

st_linestring(matrix(1,1,3)[0,], dim = "XYM")

```

엠프티 집합이 생성된다는 점에서는 동일하고 단지 디멘션만 다를 뿐이다(3.2절 참조).

### 10개의 부수적인 지오메트리

다음의 10가지 지오메트리는 매우 드물게 사용되지만, 사용 빈도가 증가하는 경향이 있다.

| 유형 | 설명 |
|------------------------------------|------------------------------------|
| `CIRCULARSTRING` | 서큘러스트링은 기본적인 곡선 유형으로 직선 유형의 LINESTRING과 유사하다. 단일 세그먼트는 세 점이 필요하며, 시작점과 끝점(첫 번째와 세 번째 점) 및 호 상의 다른 점이 필요하다. 예외는 닫힌 원의 경우로, 이 경우 시작점과 끝점이 동일하다. 이 경우 두 번째 점은 반드시 호의 중심, 즉 원의 반대편이어야 한다. 호를 연결하려면 이전 호의 마지막 점이 다음 호의 첫 번째 점이 되며, 이는 LINESTRING에서도 동일하다. 따라서 타당한 서큘러 문자열은 1보다 큰 홀수 개의 점을 가져야 한다. |
| `COMPOUNDCURVE` | 컴파운트커브는 곡선(서큘러) 세그먼트와 선형 세그먼트를 모두 포함하는 단일 연속 곡선이다. 구성 요소를 잘 갖추고 있어야 하며, 모든 구성 요소의 끝점(마지막을 제외하고)은 다음 구성 요소의 시작점과 일치해야 한다. |
| `CURVEPOLYGON` | 커브폴리곤 속에 컴파운트커브가 포함된 예: `CURVEPOLYGON( COMPOUNDCURVE( CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1))` |
| `MULTICURVE` | 멀티커브는 곡선으로 구성된 1차원 지오메트리 컬렉션이다. 이 컬렉션은 라인 문자열, 서큘러 문자열 또는 컴파운드 문자열을 포함할 수 있다. |
| `MULTISURFACE` | 멀티서피스는 동일한 CRS를 사용하는 서피스로 구성된 2차원 지오메트리 컬렉션이다. |
| `CURVE` | 커브는 일반적으로 몇 개의 점의 연결로 정의되는 1차원 지오메트리 객체이며, 점들 간의 인터폴레이션 형태에 따라 커브의 하위 유형이 정의된다. |
| `SURFACE` | 서피스는 2차원 지오메트리 객체이다. |
| `POLYHEDRALSURFACE` | 폴리헤드럴서피스는 공통 경계 세그먼트를 공유하는 연속적인 폴리곤의 컬렉션이다. |
| `TIN` | 불규칙삼각망(triangulated irregular network)은 오직 삼각형으로만 구성된 폴리헤드럴서피스이다. |
| `TRIANGLE` | 트라이앵글은 세 개의 비공선적(non-collinear) 버텍스로 구성된(역자주: 세 점이 일직선 상에 놓이지 않음을 의미한다), 내부 경계가 없는 폴리곤이다. |

`CIRCULARSTRING`, `COMPOUNDCURVE`, `CURVEPOLYGON`은 SFA 표준에 언급되지 않지만 SQL-MM 파트3 표준에는 포함되어 있다. 위 표의 설명 부분은 PostGIS 매뉴얼에서 그대로 가져온 것이다.

### 텍스트 엔코딩과 바이너리 엔코딩

심플 피처 표준에는 도 가지 엔코딩 방식이 포함되어 있다. 하나는 텍스트 인코딩이고 다른 하나는 바이너리 인코딩이다. 위에서 사용된 KWT는 인간-해독가능(human-readable)이고, KWB(well-known binary) 인코딩은 기계-해동가능(machine-readable)이다. WKB 인코딩은 정보 손실이 없으며 일반적인 텍스트 인코딩(및 디코딩)보다 작업 속도가 빠르다. 이는 R 패키지 **sf**와 GDAL, GEOS, liblwgeom, s2geometry 라이브러리 간의 모든 통신에서 사용된다(그림 1.7).

## 지오메트리에 적용되는 오퍼레이션

심플 피처 지오메트리의 프로퍼티를 추출하는 것이 가능하며, 심플 피처 지오메트리의 결합을 통해 새로운 지오메트리가 생성된 경우, 그것의 프로퍼티를 추출하는 것 역시 가능하다. 이 섹션에서는 기하학적 프로퍼티에 전적으로 초점을 맞춘 오퍼레이션에 대해서만 간략하게 다룬다. 5장에서는 비기하학적 피처 속성 분석에 초점을 맞춘다. 이 섹션의 일부 내용은 Pebesma (2018)로부터 가져온 것이다.

기하학적 프로퍼티에 대한 오퍼레이션을 투입과 산출에 의거해 분류하는 것이 가능하다. 우선 산출의 관점에서, 다음과 같이 구분할 수 있다.

-   프레디케이트(predicate): 특정 프로퍼티가 TRUE임을 주장하는 논리값

-   측정치(measure): 양(수치, 측정 단위가 있을 수 있음)

-   변형(transformation): 새롭게 생성된 지오메트리

오퍼레이션이 어떤 지오메트리에 적용되느냐에 따라 다음과 같이 분류하는 것이 가능하다.

-   유너리(unary)단일 지오메트리에 적용

-   바이너리(binary): 지오메트리의 쌍에 적용

-   에너리(n-ary): 지오메트리의 집합에 적용

### 유너리 프리디케이트: 단항 조건식(unary predicate)

유너리 프리디케이트는 하나의 지오메트리의 하나의 프로퍼티를 설명한다. `is_simple`, `is_valid`, `is_empty`와 같는 프리디케이트는 각각 지오메트리가 심플한지, 타당한지, 엠프티한지의 여부에 대한 논리값을 반환한다. `is_longlat` 프리디케이트는 주어진 CRS가 경위도 좌표계에 기반하고 있는지 평면 좌표계에 기반하고 있는지의 여부를 반환한다. `is(geometry, class)`는 지오메트리가 특정한 클래스에 속하는지의 여부를 확인한다.

### 바이너리 프리디케이트와 DE-9IM: 이항 조건식(binary predicate)과 DE-9IM

DE-9IM(Dimensionally Extended Nine-Intersection Model)(Clementini, Di Felice, and Oosterom 1993; Egenhofer and Franzosa 1991)은 2차원 공간($R^2$)에서 두 지오메트리간의 정성적 관계를 설명하는 모델이다. 모든 지오메트리는 디멘션 값을 가진다.

-   포인트는 0

-   라인 지오메트리는 1

-   폴리곤 지오메트리는 2

-   엠프티 지오메트리는 F(거짓)

모든 지오메트리는 내부(I), 경계(B), 외부(E)를 가지며, 이것들이 어떤 역할은 하는지는 폴리곤의 경우에 보다 명확히 드러난다.

-   라인의 경계는 종점에 의해 형성되고, 선상의 모든 비종점이 내부를 구성한다.

-   포인트는 0차원의 내부를 가지지만, 경계는 없다.

```{r}
#| echo: false
#| label: fig-3-2
#| fig-cap: "DE-9IM: 폴리곤의 내부, 경계, 외부(행)와 라인스트링의 내부, 경계, 외부(열) 간의 인터섹션"

library(sf)
polygon <- po <- st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0))))
p0 <- st_polygon(list(rbind(c(-1,-1), c(2,-1), c(2,2), c(-1,2), c(-1,-1))))
line <- li <- st_linestring(rbind(c(.5, -.5), c(.5, 0.5)))
s <- st_sfc(po, li)

par(mfrow = c(3,3))
par(mar = c(1,1,1,1))

# "1020F1102"
# 1: 1
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("I(pol)",intersect(),"I(line) = 1")))
lines(rbind(c(.5,0), c(.5,.495)), col = 'red', lwd = 2)
points(0.5, 0.5, pch = 1)

# 2: 0
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("I(pol)",intersect(),"B(line) = 0")))
points(0.5, 0.5, col = 'red', pch = 16)

# 3: 2
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("I(pol)",intersect(),"E(line) = 2")))
plot(po, col = '#ff8888', add = TRUE)
plot(s, col = c(NA, 'darkgreen'), border = 'blue', add = TRUE)

# 4: 0
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("B(pol)",intersect(),"I(line) = 0")))
points(.5, 0, col = 'red', pch = 16)

# 5: F
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("B(pol)",intersect(),"B(line) = F")))

# 6: 1
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("B(pol)",intersect(),"E(line) = 1")))
plot(po, border = 'red', col = NA, add = TRUE, lwd = 2)

# 7: 1
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("E(pol)",intersect(),"I(line) = 1")))
lines(rbind(c(.5, -.5), c(.5, 0)), col = 'red', lwd = 2)

# 8: 0
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("E(pol)",intersect(),"B(line) = 0")))
points(.5, -.5, col = 'red', pch = 16)

# 9: 2
plot(s, col = c(NA, 'darkgreen'), border = 'blue', main = expression(paste("E(pol)",intersect(),"E(line) = 2")))
plot(p0 / po, col = '#ff8888', add = TRUE)
plot(s, col = c(NA, 'darkgreen'), border = 'blue', add = TRUE)

```

그림 3.2는 폴리곤과 라인스트링의 I, B 및 E 간의 인터섹션을 빨간색으로 표시한 것이다. 개별 그래프의 제목에 인터섹션의 결과 도출되는 디멘션(0, 1, 2, 또는 F)이 표시되어 있다. 폴리곤 지오메트리와 라인 지오메트리의 관계는 바로 이러한 디멘션의 연속(concatenation)이다.

```{r}
#| echo: false
#| message: true

st_relate(polygon, line)

```

첫 세 문자는 *첫 번째* 지오메트리(폴리곤)의 내부와 관련이 있다. 그림 3.2에는 첫 번째 지오메트리가 행에 배열되어 있다. 더 나아가 지오메트리의 쌍에 대해 *마스크(mask) 문자열*로 표현된 특정한 조건의 만족 여부도 질의할 수 있다. 예를 들어, 문자열 `"0******"`는 두 번째 지오메트리가 첫 번째 지오메트리의 내부와 하나 이상의 경계 점을 공유할 때 `TRUE`로 평가된다. 여기서 기호 `*`는 디멘션(0, 1, 2 또는 F)을 의미하는 것으로 네 개 중 어는 것도 올 수 있다. 마스크 문자열 `"T********"`은 내부가 서로 교차하는 지오메트리 쌍을 찾아내느데, 여기서 기호 T는 차원 디멘션이 0, 1, 2이면서 비엠프티 인터섹션인 경우를 의미한다.

더 나아가 바이너리 프리디케이트는 DE-9IM에서 규정된 정의를 활용함으로써 일반 언어 동사로 표현될 수 있다. 예를 들어, 프리디케이트 `equals`는 관계 `"T*F**FFF*"`와 동일하다. 어떤 두 지오메트리가 이러한 관계를 만족한다면, 그 둘은 (위상적으로)는 동일하지만, 노드의 순서가 다를 수 있다.

바이너리 프리디케이트를 나열하면 다음과 같다.

| 프리디케이트 | 의미 | 역프리디케이트 |
|------------------------|------------------------|------------------------|
| `contains` | A 포인트 어느 것도 B의 외부에 있지 않다. | `within` |
| `contains_properly` | A는 B를 포함하며, B의 어떤 포인트도 A의 경계 상에 있지 않다. |  |
| `covers` | B의 어떤 포인트도 A의 외부에 있지 않다. | `covered_by` |
| `covered_by` | covers의 반대 |  |
| `crosses` | A와 B는 일부 내부 포인트를 공유하지만 모든 포인트를 공유하는 것은 아니다. |  |
| `disjoint` | A와 B는 어떤 포인트도 서로 공유하지 않는다. | `intersects` |
| `equals` | A와 B는 위상적으로 동일하다. 노드 순서나 노드 수가 다를 수 있으며, A가 B를 포함하고 A가 B의 내부에 있는 것과 동일하다. |  |
| `equals_exact` | A와 B는 기하학적으로 동일하며, 노드 순서도 동일하다. |  |
| `intersects` | A와 B가 완전 분리의 관계를 가지지 않는다. | `disjoint` |
| `is_within_distance` | A가 주어진 거리보다 B에 더 가깝게 위치해 있다. |  |
| `within` | B의 어떤 포인트도 A의 외부에 있지 않다. | `contains` |
| `touches` | A와 B는 최소한 한 개의 경계 포인트를 공유한다. 내부 포인트를 공유하는 것은 아니다. |  |
| `overlaps` | A와 B가 다수의 포인트를 공유한다. 디멘션은 A와 B의 디멘션과 동일하다. |  |
| `related` | A와 B가 주어진 마스크 패턴을 준수하는지의 여부를 반환한다. |  |

위키피디어의 DE-9IM 페이지를 가면, 개별 동사에 해당하는 `relate` 마스크 패턴을 확인할 수 있다. 왜냐하면 *covers*와 *contains*와 같은 동사(그 역도 마찬가지)는 그 의미를 직관적으로 파악하기 어려울 때가 있다.

-   만일 A가 B를 포함한다면, B는 A의 외부나 경계와 어떠한 공유 포인트도 없다.

-   만일 A가 B를 덮으면, B는 A의 외부와 어떠한 공유 포인트도 없다.

### 유너리 측도

유너리 측도는 지오메트리의 퍼로퍼티를 설명하는 측정값이나 양을 반환한다.

| 측도 | 반환값 |
|------------------------------------|------------------------------------|
| `dimension` | 포인트는 0, 라인은 1, 폴리곤은 2, 엠프티 지오메트리에 대해서는 NA |
| `area` | 지오메트리의 면적 |
| `length` | 라인 지오메트리의 길이 |

### 바이너리 측도

distance는 지오메트리 간의 거리를 반환한다. 질적 측도로서의 (마스크가 없는) `relate`는 관계 패턴을 제공한다. 두 지오메트리간의 기하학적 관련성에 대한 설명은 섹션 3.2.2에 나타나 있다.

### 유너리 변환자

유너리 변환자는 지오메트리별로 작동하며, 각 지오메트리에 대해 새로운 지오메트리를 반환한다.

| 변환자 | 반환 지오메트리 |
|------------------------------------|------------------------------------|
| `centroid` | 투입 지오메트리의 센트로이드로 구성된 POINT 유형의 지오메트리 |
| `buffer` | 투입 지오메트리보다 더 큰(혹은 더 작은) 지오메트리: 버퍼 사이즈에 따라 산출 지오메트리의 크기가 달라짐 |
| `jitter` | 이변량 균등 분포를 이용하여 조금 전위된 지오메트리 |
| `wrap_dateline` | 날짜 변경선(데이라인)을 더 이상 덮거나 교차하지 않는 조각으로 분할된 지오메트리 |
| `boundary` | 투입 지오메트리의 경계를 가진 지오메트리 |
| `convex_hull` | 투입 지오메트리의 컨벡스헐을 가진 지오메트리(그림 3.3) |
| `line_merge` | MULTILINESTRING 내의 LINESTRING 요소들을 결합하여 더 긴 LINESTRING을 형성한 지오메트리 |
| `make_valid` | 타당하게 교정된 지오메트리 |
| `node` | 노드가 없는 교차점에 노드를 추가한 라인 지오메트리. 개별적인 라인 지오메트리에만 적용됨 |
| `point_on_surface` | 서피스에 임의의 포인트를 가진 지오메트리 |
| `polygonize` | 폐쇄 링을 형성하는 라인으로부터 생성된 폴리곤 지오메트리 |
| `segmentize` | 주어진 밀도 또는 최소 거리를 만족하는 노드로 구성된 라인 지오메트리 |
| `simplify` | 버텍스/노드를 제거함으로써 단순화된 라인 혹은 폴리곤 지오메트리 |
| `split` | 라인스트링에 의해 분할된 지오메트리 |
| `transform` | 새로운 CRS로 변형 혹은 전환된 지오메트리(2장) |
| `triangulate` | 들로네(Delauney) 삼각망으로 구성된 지오메트리(그림 3.3) |
| `voronoi` | 투입 지오메트리로부터 형성된 보로노이(Voronoi) 테셀레이션(그림 3.3) |
| `zm` | Z 좌표 및 M 좌표가 수정된(일부 좌표의 삭제 혹은 새로운 좌표의 첨가) 지오메트리 |
| `collection_extract` | 특정 유형의 GEOMETRYCOLLECTION으로부터 일부를 추출한 지오메트리 |
| `cast` | 유형이 전환된 지오메트리 |
| `+` | 주어진 벡터만큼 전위된 지오메트리 |
| `*` | 스칼라 또는 매트릭스가 곱해진 지오메트리 |

```{r}
#| echo: false
#| label: fig-3-3
#| fig-cap: "포인트의 집합, 왼편은 컨벡스 헐(빨간색), 가운데는 보로노이 폴리곤, 오른편은 들로네 삼각망"

par(mar = rep(0,4), mfrow = c(1, 3))
set.seed(133331)
mp <- st_multipoint(matrix(runif(20), 10))
plot(mp, cex = 2)
plot(st_convex_hull(mp), add = TRUE, col = NA, border = 'red')
box()
plot(mp, cex = 2)
plot(st_voronoi(mp), add = TRUE, col = NA, border = 'red')
box()
plot(mp, cex = 2)
plot(st_triangulate(mp), add = TRUE, col = NA, border = 'darkgreen')
box()

```

### 바이너리 변환자

바이러니 변환자는 지오메트리 쌍에 적용되어 새로운 지오메트리를 생성하는 함수이다. 다음과 같은 것이 있다.

| 함수 | 반환 지오메트리 | 인픽스 오퍼레이터 |
|------------------------|------------------------|------------------------|
| `intersection` | 두 지오메트리 겹치는 부분에 대한 지오메트리 | `&` |
| `union` | 두 지오메트리를 결합한 지오메트리로, 내부 경계를 제거하고, 중복되는 포인트, 노드, 또는 라인을 삭제한다. | `|` |
| `difference` | 두 번째 지오메트리와 중복되는 부분을 제거한 첫 번째 지오메트리 | `/` |
| `sym_difference` | 중복되는 부분을 제거한 이후에 두 지오메트리를 결한한 지오메트리로 `intersection`의 반대 | `%/%` |

### 에너리 변환자

에너리 변환자는 지오메트리의 집합에 작용한다. `union`을 적용하면 모든 지오메트리의 결합 결과를 얻을 수 있다. 이런 방식이 아니라면, 동일한 차원을 가진 지오메트리 집합은 MULTI-유형 지오메트리로 결합하거나 GEOMETRYCOLLECTION으로 결합할 수 있다. 이 경우, `union`을 적용하지 않았기 때문에 두 폴리곤 링이 공유 경계선을 가질 때와 같이 타당하지 않은 지오메트리가 생성될 수 있다.

에너리 `intersection`과 `difference`의 경우 형식적으로는 단일 아규먼트를 취하지만 모든 쌍, 세 쌍, 네 쌍 등에 대해 순차적으로 작동한다. 그림 3.4를 살펴보자. 세 개의 상자가 모두 겹치는 영역을 어떻게 식별할 수 있을까? 바이너리 intersection을 사용하면 모든 쌍(1-1, 1-2, 1-3, 2-1, 2-2, 2-3, 3-1, 3-2, 3-3)에 대한 intersection을 얻을 수 있다. 하지만 두 개 이상의 지오메트리가 교차하는 영역을 식별할 수는 없다. 그림 3.4의 오른쪽 그림은 에너리 intersection을 보여주는데, 한 개, 두 개, 또는 *더 많은* 지오메트리의 교차를 통해 생성된 7개의 겹치지 않는 고유한 지오메트리를 확인할 수 있다.

```{r}
#| echo: false
#| label: "왼쪽: 세 개의 겹치는 정사각형이 있는데, 모든 사각형이 겹치는 부분을 어떻게 확인할 수 있을까 오른쪽: 서로 겹치지 않는 고유한 에너리 교차"

par(mar = rep(.1, 4), mfrow = c(1, 2))
sq <- function(pt, sz = 1) st_polygon(list(rbind(c(pt - sz), 
  c(pt[1] + sz, pt[2] - sz), c(pt + sz), c(pt[1] - sz, pt[2] + sz), c(pt - sz))))
x <- st_sf(box = 1:3, st_sfc(sq(c(0, 0)), sq(c(1.7, -0.5)), sq(c(0.5, 1))))
plot(st_geometry(x), col = NA, border = sf.colors(3, categorical = TRUE), lwd = 3)
plot(st_intersection(st_geometry(x)), col = sf.colors(7, categorical=TRUE, alpha = .5))

```

유사하게, 집합 $\{s_1,s_2,s_3,...\}$에 에너리 difference를 적용하여 $\{s_1,s_2-s_1,s_3-s_2-s_1,...\}$를 생성할 수 있다. 결과가 그림 3.5에 나타나 있는데, 왼편에는 원래 집합을 보여주고 있고, 오른편에는 투입 지오메트리의 순서를 바꾼 후의 집합을 보여주고 있다. 이는 결과가 입력 지오메트리의 순서에 의존한다는 사실을 명확히 하기 위함이다. 결과로 얻어진 지오메트리는 서로 겹치지 않는다.

```{r}
#| echo: false
#| label: fig-3-5
#| fig-cap: "박스를 서로다른 순서에 따라 differece를 적용한 결과: 왼쪽은 원리 순서이고 오른쪽은 반대 순서"

par(mar = rep(.1, 4), mfrow = c(1, 2)) 
xg <- st_geometry(x)
plot(st_difference(xg), col = sf.colors(3, alpha = .5, categorical=TRUE))
plot(st_difference(xg[3:1]), col = sf.colors(3, alpha = .5, categorical=TRUE))

```

## 정밀도

## 커버리지: 테셀레이션과 래스터

### 토폴로지 모델

### 래스터 테셀레이션

## 네트워크

## 연습문제
