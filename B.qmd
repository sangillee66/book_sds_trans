---
date-modified: last-modified
number-sections: false
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
---

# R 기초 {#sec-basics}

여기서는 이 책을 읽는 데 필요한 최소한의 R 기초를 간략히 소개한다. R 기초에 대한 더 자세한 내용은 Wickham(2014) 2장을 참고하라.

## 파이프 오퍼레이터

`|>` (파이프) 기호는 '*그렇다면*'이라고 읽으면 이해하기 쉽다.

```{r}
#| eval: false
a |> b() |> c() |> d(n = 10)
```

위의 코드는 `a`를 `b()` 함수에 전달한 후, 결과를 `c()` 함수에 전달하고, 다시 `d()` 함수에 전달하며, 마지막 호출에서 `n = 10`을 지정하는 것과 같다. 즉, 다음과 동일하다.

```{r}
#| eval: false
d(c(b(a)), n = 10)
```

혹은 중간 결과를 변수에 담아 다음과 같이 쓸 수도 있다.

```{r}
#| eval: false
tmp1 <- b(a)
tmp2 <- c(tmp1)
tmp3 <- d(tmp2, n = 10)
```

많은 사람들은 이러한 파이프 형태가 실행 순서가 읽는 순서(왼쪽에서 오른쪽)를 따르기 때문에 읽기 쉽다고 생각한다. 중첩 함수 호출과 마찬가지로, 중간 결과에 이름을 붙일 필요가 없다. 그러나 중첩 함수 호출과 마찬가지로, 예상과 다른 중간 결과를 디버그하기는 어렵다. 또한 중간 결과는 메모리에 존재하므로, 어느 방식도 메모리 할당을 절약하지 못한다는 점에 유의해야 한다. 이 책에서 사용하는 R 4.1.0에 도입된 네이티브 파이프(`|>`)는 **magrittr** 패키지의 `%>%` 파이프로 안전하게 대체할 수 있다.

## 데이터 구조

Chambers (2016)가 언급했듯이, "*R에서 존재하는 모든 것은 객체*"이다. 여기에는 데이터 객체뿐 아니라 언어 객체나 함수와 같이 특수 객체도 포함된다. 이 절에서는 R의 기본 데이터 구조를 살펴본다.

### 동질 벡터

데이터 객체는 데이터를 포함하며, 경우에 따라 메타데이터도 가진다. 데이터는 항상 벡터 형태이며, 벡터는 하나의 유형만 가질 수 있다. 유형은 `typeof()` 함수로 확인하고, 길이는 `length()` 함수로 확인한다. 벡터는 `c()` 함수로 생성한다.

```{r}
#| eval: false
typeof(1:10)
# [1] "integer"
length(1:10)
# [1] 10
typeof(1.0)
# [1] "double"
length(1.0)
# [1] 1
typeof(c("foo", "bar"))
# [1] "character"
length(c("foo", "bar"))
# [1] 2
typeof(c(TRUE, FALSE))
# [1] "logical"
```

이런 종류의 벡터를 동질(homogeneous) 벡터라고 부르는데, 이는 한 가지 유형의 데이터만을 포함할 수 있기 때문이다.

또한 벡터는 길이가 0일 수도 있다는 점에 유의해야 한다.

```{r}
#| eval: false
i <- integer(0)
typeof(i)
# [1] "integer"
i
# integer(0)
length(i)
# [1] 0
```

벡터의 요소는 `[]` 혹은 `[[]]`를 사용하여 추출할 수 있으며, 할당 구문에서는 해당 요소를 다른 값으로 대체할 수도 있다.

```{r}
#| eval: false
a <- c(1,2,3)
a[2]
# [1] 2
a[[2]]
# [1] 2
a[2:3]
# [1] 2 3
a[2:3] <- c(5,6)
a
# [1] 1 5 6
a[[3]] <- 10
a
# [1]  1  5 10
```

차이점은 `[]`는 인덱스 *범위*(또는 복수 인덱스)에 대해 작업할 수 있는 반면, `[[]]`는 단일 벡터 요소에만 접근한다는 점이다.

### 이질 벡터: `list`

두 번째 벡터 유형은 `list`로, 서로 다른 유형의 데이터를 함께 담을 수 있다는 점에서 이질(heterogeneous) 벡터라고 불린다.

```{r}
#| eval: false
l <- list(3, TRUE, "foo")
typeof(l)
# [1] "list"
length(l)
# [1] 3
```

리스트에서 `[]`와 `[[]]`는 추가적인 차이가 있다. `[]`는 항상 리스트 자체를 반환하는 반면, `[[]]`는 해당 리스트 요소의 *내용*을 반환한다.

```{r}
#| eval: false
l[1]
# [[1]]
# [1] 3
l[[1]]
# [1] 3
```

교체를 수행할 때, 리스트를 지정할 경우에는 `[]`를 사용하고, 새로운 값을 지정할 경우에는 `[[]]`를 사용한다.

```{r}
#| eval: false
l[1:2] <- list(4, FALSE)
l
# [[1]]
# [1] 4
# 
# [[2]]
# [1] FALSE
# 
# [[3]]
# [1] "foo"
l[[3]] <- "bar"
l
# [[1]]
# [1] 4
# 
# [[2]]
# [1] FALSE
# 
# [[3]]
# [1] "bar"
```

리스트의 각 요소에 *이름*을 부여할 수 있다.

```{r}
#| eval: false
l <- list(first = 3, second = TRUE, third = "foo")
l
# $first
# [1] 3
# 
# $second
# [1] TRUE
# 
# $third
# [1] "foo"
```

`l[["second"]]`처럼 이름을 사용하거나, 더 간단한 표기법을 사용할 수도 있다.

```{r}
#| eval: false
l$second
# [1] TRUE
l$second <- FALSE
l
# $first
# [1] 3
# 
# $second
# [1] FALSE
# 
# $third
# [1] "foo"
```

이름을 사용하는 것은 편리해 보일 수 있지만, 먼저 이름 속성에서 이름을 찾아야 한다는 점에 유의해야 한다(아래 참조).

### NULL과 리스트 요소의 제거

`NULL`은 R에서 널(null) 값을 표현하는 방식이다. 단순 비교에서는 직관적이지 않은 결과가 나올 수 있으므로 주의해야 한다.

```{r}
#| eval: false
3 == NULL # not FALSE!
# logical(0)
NULL == NULL # not even TRUE!
# logical(0)
```

따라서 NULL은 특별히 취급할 필요가 있으며, 이를 확인할 때는 `is.null()` 함수가 유용하다.

```{r}
#| eval: false
is.null(NULL)
# [1] TRUE
```

리스트에서 특정 요소를 제거하려면, 해당 요소를 제외한 새로운 리스트를 만들면 된다.

```{r}
#| eval: false
l <- l[c(1,3)] # remove second, implicitly
l
# $first
# [1] 3
# 
# $third
# [1] "foo"
```

또는, 제거하려는 요소에 `NULL`을 할당하는 방법도 있다.

```{r}
#| eval: false
l$second <- NULL
l
# $first
# [1] 3
# 
# $third
# [1] "foo"
```

### 속성

예를 들어, 임의의 메타데이터 객체를 데이터 객체에 결합할 수 있다.

```{r}
#| eval: false
a <- 1:3
attr(a, "some_meta_data") = "foo"
a
# [1] 1 2 3
# attr(,"some_meta_data")
# [1] "foo"
```

이 메타데이터는 조회하거나 다른 값으로 교체할 수 있다.

```{r}
#| eval: false
attr(a, "some_meta_data")
# [1] "foo"
attr(a, "some_meta_data") <- "bar"
attr(a, "some_meta_data")
# [1] "bar"
```

본질적으로 객체의 속성은 이름이 지정된 리스트이며, 전체 리스트를 다음과 같이 불러오거나 설정할 수 있다.

```{r}
#| eval: false
attributes(a)
# $some_meta_data
# [1] "bar"
attributes(a) = list(some_meta_data = "foo")
attributes(a)
# $some_meta_data
# [1] "foo"
```

R은 여러 속성을 특별하게 취급하며, 전체 내용은 `?attributes`에서 확인할 수 있다. 이제 몇 가지 주요 속성에 대해 살펴보자.

#### 객체 클래스와 `class` 속성

R의 모든 객체는 "클래스를 가진다." `class(obj)`는 `obj`의 클래스명을 담은 문자 벡터를 반환한다. 일부 객체는 기본 벡터처럼 *암시적* 클래스를 가진다.

```{r}
#| eval: false
class(1:3)
# [1] "integer"
class(c(TRUE, FALSE))
# [1] "logical"
class(c("TRUE", "FALSE"))
# [1] "character"
```

클래스는 명시적으로 설정할 수도 있다. 이를 위해 `attr()` 함수를 사용하거나, 표현식의 왼쪽에 `class`를 배치하여 지정할 수 있다.

```{r}
#| eval: false
a <- 1:3
class(a) <- "foo"
a
# [1] 1 2 3
# attr(,"class")
# [1] "foo"
class(a)
# [1] "foo"
attributes(a)
# $class
# [1] "foo"
```

이 경우 새로 지정된 클래스가 기존의 암시적 클래스를 덮어쓴다. 이렇게 하면 메서드 이름에 클래스 이름을 덧붙여 `foo` 클래스용 메서드를 정의할 수 있다.

```{r}
#| eval: false
print.foo <- function(x, ...) { 
    print(paste("an object of class foo with length", length(x)))
}
print(a)
# [1] "an object of class foo with length 3"
```

이러한 메서드를 제공하는 목적은 일반적으로 소프트웨어를 더 쉽게 사용할 수 있도록 하는 것이지만, 동시에 객체를 더 불투명하게 만들 수도 있다. 따라서 클래스 속성을 제거한 후 객체를 출력해 "무엇으로 구성되어 있는지" 확인하는 것이 유용하다.

```{r}
#| eval: false
unclass(a)
# [1] 1 2 3
```

좀 더 구체적인 예로, **sf** 패키지를 사용해 폴리곤을 생성하는 경우를 생각해보자.

```{r}
#| eval: false
library(sf) |> suppressPackageStartupMessages()
p <- st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,0))))
p
# POLYGON ((0 0, 1 0, 1 1, 0 0))
```

이는 WKT(well-known-text) 형식으로 출력된다. 데이터 구조를 확인하려면 다음과 같이 하면 된다.

```{r}
#| eval: false
unclass(p)
# [[1]]
#      [,1] [,2]
# [1,]    0    0
# [2,]    1    0
# [3,]    1    1
# [4,]    0    0
```

#### `dim` 속성

`dim` 속성은 행렬이나 어레이(array)의 차원을 설정한다.

```{r}
#| eval: false
a <- 1:8
class(a)
# [1] "integer"
attr(a, "dim") <- c(2,4) # or: dim(a) = c(2,4)
class(a)
# [1] "matrix" "array"
a
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8
attr(a, "dim") <- c(2,2,2) # or: dim(a) = c(2,2,2)
class(a)
# [1] "array"
a
# , , 1
# 
#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4
# 
# , , 2
# 
#      [,1] [,2]
# [1,]    5    7
# [2,]    6    8
```

### `names` 속성

이름이 지정된 벡터는 `names` 속성에 해당 이름을 저장한다. 위에서는 리스트 예시를 보았고, 숫자 벡터의 예시는 다음과 같다.

```{r}
#| eval: false
a <- c(first = 3, second = 4, last = 5)
a["second"]
# second 
#      4
attributes(a)
# $names
# [1] "first"  "second" "last"
```

다른 이름 속성으로는 행렬이나 어레이의 `dimnames`가 있다. 이 속성은 차원의 이름뿐 아니라, 각 차원에 연결된 값의 레이블도 지정한다.

```{r}
#| eval: false
a <- matrix(1:4, 2, 2)
dimnames(a) <- list(rows = c("row1", "row2"),
                    cols = c("col1", "col2"))
a
#       cols
# rows   col1 col2
#   row1    1    3
#   row2    2    4
attributes(a)
# $dim
# [1] 2 2
# 
# $dimnames
# $dimnames$rows
# [1] "row1" "row2"
# 
# $dimnames$cols
# [1] "col1" "col2"
```

`data.frame` 객체는 행과 열을 가지며, 각각의 행과 열에는 이름이 지정되어 있다.

```{r}
#| eval: false
df <- data.frame(a = 1:3, b = c(TRUE, FALSE, TRUE))
attributes(df)
# $names
# [1] "a" "b"
# 
# $class
# [1] "data.frame"
# 
# $row.names
# [1] 1 2 3
```

### `structure`의 사용

프로그래밍 시, 객체를 반환하기 전에 속성을 추가하거나 수정하는 패턴은 매우 흔하다. 예를 들어 다음과 같다.

```{r}
#| eval: false
f <- function(x) {
   a <- create_obj(x) # call some other function
   attributes(a) <- list(class = "foo", meta = 33)
   a
}
```

마지막 두 문장은 다음과 같이 축약할 수 있다.

```{r}
#| eval: false
f <- function(x) {
   a <- create_obj(x) # call some other function
   structure(a, class = "foo", meta = 33)
}
```

여기서 `structure()` 함수는 첫 번째 아규먼트로 받은 객체의 속성을 추가하거나 교체하고, 값이 `NULL`이면 해당 속성을 제거한다.

## `MULTIPOLYGON` 객체 분할하기

`MULTIPOLYGON`이 포함된 `sf` 객체는 여러 개의 개별 조각으로 분리할 수 있다. 예를 들어, 위의 예시와 같이 `nc` 데이터셋을 사용한다고 가정해 보자.

```{r}
#| eval: false
system.file("gpkg/nc.gpkg", package = "sf") |> 
    read_sf() -> nc
```

`nc` 객체의 속성을 확인하면 다음과 같은 내용을 볼 수 있다.

```{r}
#| eval: false
attributes(nc)
# $names
#  [1] "AREA"      "PERIMETER" "CNTY_"     "CNTY_ID"   "NAME"     
#  [6] "FIPS"      "FIPSNO"    "CRESS_ID"  "BIR74"     "SID74"    
# [11] "NWBIR74"   "BIR79"     "SID79"     "NWBIR79"   "geom"     
# 
# $row.names
#   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
#  [16]  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
#  [31]  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45
#  [46]  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60
#  [61]  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75
#  [76]  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
#  [91]  91  92  93  94  95  96  97  98  99 100
# 
# $class
# [1] "sf"         "tbl_df"     "tbl"        "data.frame"
# 
# $sf_column
# [1] "geom"
# 
# $agr
#      AREA PERIMETER     CNTY_   CNTY_ID      NAME      FIPS 
#      <NA>      <NA>      <NA>      <NA>      <NA>      <NA> 
#    FIPSNO  CRESS_ID     BIR74     SID74   NWBIR74     BIR79 
#      <NA>      <NA>      <NA>      <NA>      <NA>      <NA> 
#     SID79   NWBIR79 
#      <NA>      <NA> 
# Levels: constant aggregate identity
```

`geom`이라는 이름의 지오메트리 컬럼이 있음을 확인할 수 있으며, 이 컬럼만 추출할 수 있다.

```{r}
#| eval: false
nc$geom
# Geometry set for 100 features 
# Geometry type: MULTIPOLYGON
# Dimension:     XY
# Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6
# Geodetic CRS:  NAD27
# First 5 geometries:
# MULTIPOLYGON (((-81.5 36.2, -81.5 36.3, -81.6 3...
# MULTIPOLYGON (((-81.2 36.4, -81.2 36.4, -81.3 3...
# MULTIPOLYGON (((-80.5 36.2, -80.5 36.3, -80.5 3...
# MULTIPOLYGON (((-76 36.3, -76 36.3, -76 36.3, -...
# MULTIPOLYGON (((-77.2 36.2, -77.2 36.2, -77.3 3...
```

해당 컬럼만 포함된 객체가 다음과 같은 속성을 가지고 있음을 확인할 수 있다.

```{r}
#| eval: false
attributes(nc$geom)
# $n_empty
# [1] 0
# 
# $crs
# Coordinate Reference System:
#   User input: NAD27 
#   wkt:
# GEOGCRS["NAD27",
#     DATUM["North American Datum 1927",
#         ELLIPSOID["Clarke 1866",6378206.4,294.978698213898,
#             LENGTHUNIT["metre",1]]],
#     PRIMEM["Greenwich",0,
#         ANGLEUNIT["degree",0.0174532925199433]],
#     CS[ellipsoidal,2],
#         AXIS["geodetic latitude (Lat)",north,
#             ORDER[1],
#             ANGLEUNIT["degree",0.0174532925199433]],
#         AXIS["geodetic longitude (Lon)",east,
#             ORDER[2],
#             ANGLEUNIT["degree",0.0174532925199433]],
#     USAGE[
#         SCOPE["Geodesy."],
#         AREA["North and central America: Antigua and Barbuda - onshore. Bahamas - onshore plus offshore over internal continental shelf only. Belize - onshore. British Virgin Islands - onshore. Canada onshore - Alberta, British Columbia, Manitoba, New Brunswick, Newfoundland and Labrador, Northwest Territories, Nova Scotia, Nunavut, Ontario, Prince Edward Island, Quebec, Saskatchewan and Yukon - plus offshore east coast. Cuba - onshore and offshore. El Salvador - onshore. Guatemala - onshore. Honduras - onshore. Panama - onshore. Puerto Rico - onshore. Mexico - onshore plus offshore east coast. Nicaragua - onshore. United States (USA) onshore and offshore - Alabama, Alaska, Arizona, Arkansas, California, Colorado, Connecticut, Delaware, Florida, Georgia, Idaho, Illinois, Indiana, Iowa, Kansas, Kentucky, Louisiana, Maine, Maryland, Massachusetts, Michigan, Minnesota, Mississippi, Missouri, Montana, Nebraska, Nevada, New Hampshire, New Jersey, New Mexico, New York, North Carolina, North Dakota, Ohio, Oklahoma, Oregon, Pennsylvania, Rhode Island, South Carolina, South Dakota, Tennessee, Texas, Utah, Vermont, Virginia, Washington, West Virginia, Wisconsin and Wyoming - plus offshore . US Virgin Islands - onshore."],
#         BBOX[7.15,167.65,83.17,-47.74]],
#     ID["EPSG",4267]]
# 
# $class
# [1] "sfc_MULTIPOLYGON" "sfc"             
# 
# $precision
# [1] 0
# 
# $bbox
#  xmin  ymin  xmax  ymax 
# -84.3  33.9 -75.5  36.6
```

네 번째 리스트 요소의 *내용*을 불러온다.

```{r}
#| eval: false
nc$geom[[4]] |> format(width = 60, digits = 5)
# [1] "MULTIPOLYGON (((-76.009 36.32, -76.017 36.338, -76.033 36..."
```

해당 객체의 클래스가 리스트임을 확인한다.

```{r}
#| eval: false
typeof(nc$geom[[4]])
# [1] "list"
```

해당 객체의 속성을 확인한다.

```{r}
#| eval: false
attributes(nc$geom[[4]])
# $class
# [1] "XY"           "MULTIPOLYGON" "sfg"
```

그리고 `length`를 확인한다.

```{r}
#| eval: false
length(nc$geom[[4]])
# [1] 3
```

길이 속성은 외부 링의 개수를 나타낸다. 멀티폴리곤은 하나 이상의 폴리곤으로 구성될 수 있으며, 대부분의 카운티는 하나의 폴리곤만 가지고 있음을 알 수 있다.

```{r}
#| eval: false
lengths(nc$geom)
#   [1] 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
#  [32] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3 2 1 1 1 1 1
#  [63] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 2 1 1
#  [94] 1 2 1 1 1 1 1
```

멀티폴리곤은 여러 폴리곤으로 구성된 리스트이다.

```{r}
#| eval: false
typeof(nc$geom[[4]])
# [1] "list"
```

네 번째 멀티폴리곤의 *첫 번째* 폴리곤 역시 리스트인데, 이는 폴리곤이 외부 링을 포함하고 그 뒤에 하나 이상의 내부 링(구멍)이 올 *수* 있기 때문이다.

```{r}
#| eval: false
typeof(nc$geom[[4]][[1]])
# [1] "list"
```

해당 폴리곤이 외부 링 하나만 가지고 있음을 확인할 수 있다.

```{r}
#| eval: false
length(nc$geom[[4]][[1]])
# [1] 1
```

해당 폴리곤의 유형, 차원, 그리고 첫 번째 좌표 집합은 다음과 같이 출력할 수 있다.

```{r}
#| eval: false
typeof(nc$geom[[4]][[1]][[1]])
# [1] "double"
dim(nc$geom[[4]][[1]][[1]])
# [1] 26  2
head(nc$geom[[4]][[1]][[1]])
#       [,1] [,2]
# [1,] -76.0 36.3
# [2,] -76.0 36.3
# [3,] -76.0 36.3
# [4,] -76.0 36.4
# [5,] -76.1 36.3
# [6,] -76.2 36.4
```

속성은 변경 가능하다. 예를 들어, 세 번째 좌표의 위도 값을 다음과 같이 수정할 수 있다.

```{r}
#| eval: false
nc$geom[[4]][[1]][[1]][3,2] <- 36.5
```
