---
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
editor_options: 
  chunk_output_type: console
---

# 데이터 큐브 {#sec-datacube}

데이터 큐브(data cube)는 시간에 걸쳐 일련의 지오메트리 특성을 반복적으로 관찰할 때 자연스럽게 형성된다. 시간 정보는 건물의 건축 연도나 사람의 생년월일을 기록하는 것처럼 피처의 속성으로 간주될 수 있다(5장 참조). 그러나 시간 정보가 속성을 관측한 시점이나 해당 속성에 대한 예측 시점을 나타내는 경우도 있다. 이러한 경우, 시간은 공간과 동등한 위상을 가지며, 시간과 공간은 함께 우리가 관찰ㆍ모델링ㆍ예측ㆍ예보하는 물리적 차원을 설정한다.

우리 세상을 바라보는 한 가지 방법은 세 개의 공간 차원과 한 개의 시간 차원을 포함하는 4차원 공간으로 상정하는 것이다. 이 관점에서 사건은 시간 차원에서의 크기를 지속 시간으로 갖는 '사물' 또는 '객체'가 된다(Galton 2004). 이러한 관점은 우리가 세상을 경험하고 묘사하는 방식과는 다소 맞지 않지만, 데이터 분석의 관점에서는 네 개의 숫자(와 참조 체계) 만으로 관측의 시공간 좌표를 충분히 설명할 수 있.

우리는 데이터 큐브를 공간 및/또는 시간과 관련된 하나 이상의 어레이 차원을 가진 어레이 데이터로 정의한다(Lu, Appel, and Pebesma 2018). 이는 래스터 데이터, 속성을 가진 피처, 시계열 데이터가 모두 데이터 큐브의 특수한 경우임을 의미한다. 데이어 큐브는 3차원 구조에 한정될 필요가 없으므로, 실제로는 큐브라기 보다는 *하이퍼큐브*(hypercube)에 가깝다. 또한 서로 다른 차원의 범위가 동일하거나 비교 가능한 단위를 가질 필요가 없기 때문에, 더 적절한 용어는 *하이퍼-직사각형*(hyper-retangle)일 될 것이다. 그러나 편의상 여기서는 데이터 큐브라는 용어를 사용한다.

데이터 큐브의 표준 형식은 그림 6.1에 제시되어 있으며, 이는 동일한 지역에 대해 서로 다른 시간 단계에서 수집(관찰 또는 모델링)된 래스터 레이어 세트를 원근법 플롯으로 나타낸 것이다. 세 개의 큐브 차원(경도, 위도, 시간)은 서로 직교 관계를 이룬다. 임의의 2차원 큐브 슬라이스는 특정 값에서 하나의 차원을 고정함으로써 얻어지고, 1차원 슬라이스는 특정 값에서 두 개의 차원을 고정함으로써 얻어진다. 스칼라는 세 개의 차원을 특정 값에서 고정했을 때 얻어진다.

```{r}
#| echo: false
#| eval: false
#| label: fig-6-1
#| fig-cap: "위도, 경도, 시간의 세 차원을 가지 래스터 데이터 큐브"

# (C) 2019, Edzer Pebesma, CC-BY-SA
set.seed(1331)
library(stars) |> suppressPackageStartupMessages()
library(colorspace)
tif <- system.file("tif/L7_ETMs.tif", package = "stars")
r <- read_stars(tif)

nrow <- 5
ncol <- 8
m <- r[[1]][1:nrow,1:ncol,1]
dim(m) <- c(x = nrow, y = ncol) # named dim
s <- st_as_stars(m)
# s
attr(s, "dimensions")[[1]]$delta = 3
attr(s, "dimensions")[[2]]$delta = -.5
attr(attr(s, "dimensions"), "raster")$affine = c(-1.2, 0.0)

plt <- function(x, yoffset = 0, add, li = TRUE) {
    attr(x, "dimensions")[[2]]$offset = attr(x, "dimensions")[[2]]$offset + yoffset
    l <- st_as_sf(x, as_points = FALSE)
    pal <- sf.colors(10)
    if (li)
        pal <- lighten(pal, 0.3 + rnorm(1, 0, 0.1))
    if (! add)
        plot(l, axes = FALSE, breaks = "equal", pal = pal, reset = FALSE, border = grey(.75), key.pos = NULL, main = NULL, xlab = "time")
    else
        plot(l, axes = TRUE, breaks = "equal", pal = pal, add = TRUE, border = grey(.75))
    u <- st_union(l)
    # print(u)
    plot(st_geometry(u), add = TRUE, col = NA, border = 'black', lwd = 2.5)
}

pl <- function(s, x, y, add = TRUE, randomize = FALSE) {
  attr(s, "dimensions")[[1]]$offset = x
  attr(s, "dimensions")[[2]]$offset = y
  m <- r[[1]][y + 1:nrow,x + 1:ncol,1]
  if (randomize)
    m <- m[sample(y + 1:nrow),x + 1:ncol]
  dim(m) = c(x = nrow, y = ncol) # named dim
  s[[1]] = m
  plt(s, 0, add)
  plt(s, 1, TRUE)
  plt(s, 2, TRUE)
  plt(s, 3, TRUE)
  plt(s, 4, TRUE)
  plt(s, 5, TRUE)
  plt(s, 6, TRUE)
  plt(s, 7, TRUE)
  plt(s, 8, TRUE, FALSE)
}

plot.new()
par(mar = rep(0.5,4))
plot.window(xlim = c(-12,15), ylim = c(-5,10), asp=1)
pl(s, 0, 0)
# box()
text(-10, 0, "time", srt = -90, col = 'black')
text(-5,  6.5, "latitude", srt = 25, col = 'black')
text( 5,  8.5, "longitude", srt = 0, col = 'black')

```

![위도, 경도, 시간의 세 차원을 가지 래스터 데이터 큐브](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-cube-1.png){#fig-6-1}

## 4차원 데이터 큐브

```{r}
#| echo: false
#| eval: false
#| label: fig-6-2
#| fig-cap: "x, y, 밴드, 시간의 네 차원을 가진 4차원 래스터 데이터 큐브"

# (C) 2021, Jonathan Bahlmann, CC-BY-SA
# https://github.com/Open-EO/openeo.org/tree/master/documentation/1.0/datacubes/.scripts
# based on work by Edzer Pebesma, 2019, here: https://gist.github.com/edzer/5f1b0faa3e93073784e01d5a4bb60eca

# plotting runs via a dummy stars object with x, y dimensions (no bands)
# to not be overly dependent on an input image, time steps and bands
# are displayed by replacing the matrix contained in the dummy stars object
# every time something is plotted

# packages, read input ----
set.seed(1331)
library(stars)
library(colorspace) |> suppressPackageStartupMessages()
library(scales) |> suppressPackageStartupMessages()

# make color palettes ----
blues <- sequential_hcl(n = 20, h1 = 211, c1 = 80, l1 = 40, l2 = 100, p1 = 2)
greens <- sequential_hcl(n = 20, h1 = 134, c1 = 80, l1 = 40, l2 = 100, p1 = 2)
reds <- sequential_hcl(n = 20, h1 = 360, c1 = 80, l1 = 40, l2 = 100, p1 = 2)
purples <- sequential_hcl(n = 20, h1 = 299, c1 = 80, l1 = 40, l2 = 100, p1 = 2)
greys <- sequential_hcl(n = 20, h1 = 0, c1 = 0, l1 = 40, l2 = 100, p1 = 2)

# matrices from raster ----
# make input matrices from an actual raster image
input <- read_stars("data/iceland_delta_cutout_2.tif") # this raster needs approx 6x7 format
# if the input raster is changed, every image where a pixel value is written as text needs to be checked and corrected accordingly
input <- input[,,,1:4]
warped <- st_warp(input, crs = st_crs(input), cellsize = 200) # warp to approx. 6x7 pixel

# these are only needed for resampling
warped_highres <- st_warp(warped, crs = st_crs(warped), cellsize = 100) # with different input, cellsize must be adapted
# this is a bit of a trick, because 3:4 is different format than 6:7
# when downsampling, the raster of origin isn't so important anyway
warped_lowres <- st_warp(warped_highres[,1:11,,], crs = st_crs(warped), cellsize = 390)
# plot(warped_lowres)
# image(warped[,,,1], text_values = TRUE)

t1 <- floor(matrix(runif(42, -30, 150), ncol = 7)) # create timesteps 2 and 3 randomly
t2 <- floor(matrix(runif(42, -250, 50), ncol = 7))

# create dummy stars object ----
make_dummy_stars <- function(x, y, d1, d2, aff) {
  m = warped_highres[[1]][1:x,1:y,1] # underlying raster doesn't matter because it's just dummy construct
  dim(m) = c(x = x, y = y) # named dim
  dummy = st_as_stars(m)
  attr(dummy, "dimensions")[[1]]$delta = d1
  attr(dummy, "dimensions")[[2]]$delta = d2
  attr(attr(dummy, "dimensions"), "raster")$affine = c(aff, 0.0)
  return(dummy)
}

s <- make_dummy_stars(6, 7, 2.5, -.5714286, -1.14) # mainly used, perspective
f <- make_dummy_stars(6, 7, 1, 1, 0) # flat
highres <- make_dummy_stars(12, 14, 1.25, -.2857143, -.57) # for resampling
lowres <- make_dummy_stars(3, 4, 5, -1, -2) # for resampling

# matrices from image ----
make_matrix <- function(image, band, n = 42, ncol = 7, t = 0) {
  # this is based on an input image with >= 4 input bands
  # n is meant to cut off NAs, ncol is y, t is random matrix for time difference
  return(matrix(image[,,,band][[1]][1:n], ncol = ncol) - t)
  # before: b3 <- matrix(warped[,,,1][[1]][1:42], ncol = 7) - t2
}

# now use function: 
b1 <- make_matrix(warped, 1)
b2 <- make_matrix(warped, 1, t = t1)
b3 <- make_matrix(warped, 1, t = t2)
g1 <- make_matrix(warped, 2)
g2 <- make_matrix(warped, 2, t = t1)
g3 <- make_matrix(warped, 2, t = t2)
r1 <- make_matrix(warped, 3)
r2 <- make_matrix(warped, 3, t = t1)
r3 <- make_matrix(warped, 3, t = t2)
n1 <- make_matrix(warped, 4)
n2 <- make_matrix(warped, 4, t = t1)
n3 <- make_matrix(warped, 4, t = t2)

# plot functions ----
plt <- function(x, yoffset = 0, add, li = TRUE, pal, print_geom = TRUE, border = .75, breaks = "equal") {
  # pal is color palette
  attr(x, "dimensions")[[2]]$offset = attr(x, "dimensions")[[2]]$offset + yoffset 
  l = st_as_sf(x, as_points = FALSE)
  if (li)
    pal <- lighten(pal, 0.2) # + rnorm(1, 0, 0.1))
  if (! add)
    plot(l, axes = FALSE, breaks = breaks, pal = pal, reset = FALSE, border = grey(border), key.pos = NULL, main = NULL, xlab = "time")
  else
    plot(l, axes = TRUE, breaks = breaks, pal = pal, add = TRUE, border = grey(border))
  u <- st_union(l)
  # print(u)
  if(print_geom) {
    plot(st_geometry(u), add = TRUE, col = NA, border = 'black', lwd = 2.5)
  } else {
    # not print geometry
  }
}

pl_stack <- function(s, x, y, add = TRUE, nrM, imgY = 7, inner = 1) {
  # nrM is the timestep {1, 2, 3}, cause this function
  # prints all 4 bands at once
  attr(s, "dimensions")[[1]]$offset = x
  attr(s, "dimensions")[[2]]$offset = y
  # m <- r[[1]][y + 1:nrow,x + 1:ncol,1]
  m <- eval(parse(text=paste0("n", nrM)))
  s[[1]] <- m[,c(imgY:1)] # turn around to have same orientation as flat plot
  plt(s, 0, TRUE,  pal = purples)
  m <- eval(parse(text=paste0("r", nrM)))
  s[[1]] <- m[,c(imgY:1)]
  plt(s, 1*inner, TRUE,  pal = reds)
  m <- eval(parse(text=paste0("g", nrM)))
  s[[1]] <- m[,c(imgY:1)]
  plt(s, 2*inner, TRUE,  pal = greens)
  m <- eval(parse(text=paste0("b", nrM)))
  s[[1]] <- m[,c(imgY:1)]
  plt(s, 3*inner, TRUE, pal = blues) # li FALSE deleted
}

# flat plot function
# prints any dummy stars with any single matrix to position
pl <- function(s, x, y, add = TRUE, randomize = FALSE, pal, m, print_geom = TRUE, border = .75, breaks = "equal") {
  # m is matrix to replace image with
  # m <- t(m)
  attr(s, "dimensions")[[1]]$offset = x
  attr(s, "dimensions")[[2]]$offset = y
  # print(m)
  s[[1]] <- m
  plt(s, 0, add = TRUE, pal = pal, print_geom = print_geom, border = border, breaks = breaks)
  #plot(s, text_values = TRUE)
}

print_segments <- function(x, y, seg, by = 1, lwd = 4, col = "black") {
  seg <- seg * by
  seg[,1] <- seg[,1] + x
  seg[,3] <- seg[,3] + x
  seg[,2] <- seg[,2] + y
  seg[,4] <- seg[,4] + y
  segments(seg[,1], seg[,2], seg[,3], seg[,4], lwd = lwd, col = col)
}

# time series ----

# from: cube1_ts_6x7_bigger.png
offset = 26
plot.new()
#par(mar = c(3, 2, 7, 2))
par(mar = c(0, 0, 0, 0))
#plot.window(xlim = c(10, 50), ylim = c(-3, 10), asp = 1)
plot.window(xlim = c(-15, 75), ylim = c(-3, 10), asp = 1)
pl_stack(s, 0, 0, nrM = 3)
pl_stack(s, offset, 0, nrM = 2)
pl_stack(s, 2 * offset, 0, nrM = 1)
# po <- matrix(c(0,-8,7,0,15,3.5,  0,1,1,5,5,14), ncol = 2)
heads <- matrix(c(3.5, 3.5 + offset, 3.5 + 2*offset, 14,14,14), ncol = 2)
points(heads, pch = 16) # 4 or 16
segments(c(-8, 7, 0, 15), c(-1,-1,3,3), 3.5, 14) # first stack pyramid
segments(c(-8, 7, 0, 15) + offset, c(-1,-1,3,3), 3.5 + offset, 14) # second stack pyramid
segments(c(-8, 7, 0, 15) + 2*offset, c(-1,-1,3,3), 3.5 + 2*offset, 14) # third stack pyramid
arrows(-13, 14, 72, 14, angle = 20, lwd = 2)  # timeline
text(7.5, 3.8, "x", col = "black")
text(-10, -2.5, "bands", srt = 90, col = "black")
text(-4.5, 1.8, "y", srt = 27.5, col = "black")
y <- 15.8
text(69, y, "time", col = "black")
text(3.5, y, "2020-10-01", col = "black")
text(3.5 + offset, y, "2020-10-13", col = "black")
text(3.5 + 2*offset, y, "2020-10-25", col = "black")

```

![x, y, 밴드, 시간의 네 차원을 가진 4차원 래스터 데이터 큐브](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-cube4d-1.png){#fig-6-2}

그림 6.2는 4차원 래스터 데이터 큐브를 보여준다(Appel and Pebesma 2019). 여기서 스펙트럼 차원('밴드')을 가진 3차원 래스터 데이터 큐브가 네 번째 차원인 시간 축을 따라 배열되어 있다.(역자주: 여기서 '밴드'는 원격탐사에사 사용되는 용어로, 다중분광 센서가 태양의 전자기 복사 에너지 중 특정 파장대를 감지하는 범위를 의미한다.) 컬러 이미지 데이터는 항상 세 개의 밴드(파란색, 녹색, 빨간색)를 가지며, 이 예제는 스펙트럼 원격탐사 데이터에서 흔히 발견되는 네 번째 밴드(근적외선, NIR)를 포함한다.

그림 6.3은 정확히 동일한 데이터를 평면적으로 배열한 패싯 플롯(또는 산점도 행렬)으로 나타낸 것이다. 플롯의 두 차원($x$ 및 $y$)은 기본적으로는 *밴드*와 *시간* 차원을 의미하지만, 각 세부 플롯 내부에서는 실제 공간 좌표계를 나타낸다.

```{r}
#| echo: false
#| eval: false
#| label: fig-6-3
#| fig-cap: "두 차원을 기준으로 평면 배열한 4차원 래스터 데이터"

# flat ----
xlabels <- seq(attr(warped, "dimensions")[[1]]$offset + attr(warped, "dimensions")[[1]]$delta / 2, length.out = attr(warped, "dimensions")[[1]]$to, by = attr(warped, "dimensions")[[1]]$delta)
ylabels <- seq(attr(warped, "dimensions")[[2]]$offset + attr(warped, "dimensions")[[2]]$delta / 2, length.out = attr(warped, "dimensions")[[2]]$to, by = attr(warped, "dimensions")[[2]]$delta)

print_labels <- function(x, y, off, lab, horizontal, cex = 1) {
  if(horizontal) { # x
    for(i in 0:(length(lab)-1)) {
      text(x + i*off, y, lab[i+1], cex = cex, srt = 90)
    }
  } else { # y
    lab <- lab[length(lab):0]
    for(i in 0:(length(lab)-1)) {
      text(x, y + i*off, lab[i+1], cex = cex)
    }
  }
}

# before: width=1000, xlim(-2, 33), date labels x=31
plot.new()
# par(mar = c(0,0,0,0))
par(mar = c(3,0,0,0))
plot.window(xlim = c(-2, 40), ylim = c(0, 25), asp = 1)
pl(f, 7, 0, pal = blues, m = b1)
pl(f, 7, 10, pal = blues, m = b2)
pl(f, 7, 20, pal = blues, m = b3)
pl(f, 14, 0, pal = greens, m = g1)
pl(f, 14, 10, pal = greens, m = g2)
pl(f, 14, 20, pal = greens, m = g3)
pl(f, 21, 0, pal = reds, m = r1)
pl(f, 21, 10, pal = reds, m = r2)
pl(f, 21, 20, pal = reds, m = r3)
pl(f, 28, 0, pal = purples, m = n1)
pl(f, 28, 10, pal = purples, m = n2)
pl(f, 28, 20, pal = purples, m = n3)
print_labels(28.5, -2, 1, xlabels, horizontal = TRUE, cex = 0.7)
print_labels(36, 0.5, 1, ylabels, horizontal = FALSE, cex = 0.7)
# arrows(6, 27, 6, 0, angle = 20, lwd = 2)
# text(5, 14, "time", srt = 90, col = "black")
text(10, 28, "blue", col = "black")
text(17, 28, "green", col = "black")
text(24, 28, "red", col = "black")
text(31, 28, "nir", col = "black")
text(3, 23.5, "2020-10-01", col = "black")
text(3, 13.5, "2020-10-13", col = "black")
text(3, 3.5, "2020-10-25", col = "black")

```

![두 차원을 기준으로 평면 배열한 4차원 래스터 데이터](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-cube4d2-1.png){#fig-6-3}

## 디멘션, 속성, 서포트

시공간상의 현상은 *정의역*(domain)이 공간과 시간이고, *치역*(range)이 하나 이상의 관측된 속성인 함수로 볼 수 있다.(역자주: 정의역은 함수에 입력될 수 있는 값들의 집합이고, 치역은 함수가 출력할 수 있는 값들의 집합, 즉 가능한 결과값의 범위를 의미한다.) 명확하게 식별 가능한 이산적 사건이나 객체의 경우, 치역은 일반적으로 이산적이며, 이러한 이산성은 시작과 끝의 정밀한 좌표를 설정함으로써 확보되며 이는 벡터 지오메트리와 잘 부합한다. 반면, 기온이나 토지이용 유형처럼 모든 위치에서 값을 가지는 연속적 현상은 무한히 많은 값을 나타내야 하므로, 보통 해당 시공간 도메인(범위)을 *일정하게* 이산화(discretization)하는 전략이 사용된다. 이러한 고려는 널리 알려져 있는 여러 데이터 구조로 이어진다.

-   시계열: 시간의 함수로서 타임라인으로 표현되는 데이터 구조

-   이미지 또는 래스터: 2차원 공간데이터를 위한 데이터 구조

-   이미지의 시간적 시퀀스: 동적 공간데이터를 위한 데이터 구조

세 번째의 데이터 구조는 변수 $Z$가 $x, y, t$에 의존하는 경우이다.

$$
Z=f(x,y,t)
$$

이는 시공간 어레이 또는 *데이터 큐브*의 전형적인 형태이다. 정의역을 일정하게 이산화한 지점들이 입체적 모양을 형성하며, 그 형태가 큐브와 유사하기 때문이다. 치역을 구성하는 변수(여기서는 $x, y, t$ )를 큐브 *디멘션*이라고 부른다. 데이터 큐브는 여러 속성을 가질 수 있다.

$$
\{Z_1,Z_2,...,Z_p\}=f(x,y,t)
$$

만약 $Z$가 함수형 변수라면, 예를 들어 전자기 스펙트럼에서 측정된 반사율 값인 경우, 스펙트럼 파장 $\lambda$가 추가적인 차원을 형성할 수 있다($Z=f(x,y,t,\lambda)$). 6.5절에서는 컬러 밴드를 속성으로 표현하는 대안적 방식을 다룬다.

다중 시간 차원도 가능하다. 예를 들어, 여러 시점 $t$에 대해 미래의 여러 시점 $t'$에 대한 예측을 수행하거나, 시간을 연도ㆍ연중 일자ㆍ하루 중 시간 등 여러 차원으로 나누는 경우이다. 데이터 큐브의 가장 일반적인 정의는 $n$개의 차원에서 $p$개의 속성으로의 함수적 매핑이다.

$$
\{Z_1,Z_2,...,Z_p\}=f(D_1,D_2,...,D_n)
$$

여기서는 하나 이상의 공간 차원과 0개 이상의 시간 차원을 가진 모든 데이터셋을 데이터 큐브로 간주한다. 이렇게 하면 다음과 같은 경우를 모두 포괄할 수 있다.

-   심플 피처(3.1절)

-   피처 집합에 대한 시계열

-   래스터 데이터

-   다분광 래스터 데이터(이미지)

-   다분광 래스터 데이터의 시계열(비디오)

### 규칙 디멘션, GDAL의 지오트랜스폼

데이터 큐브는 보통 다차원 어레이에 저장되며, 1-기반 어레이 인덱스 $i$와 일정하게 이산화된 차원 변수 $x$ 사이의 일반적인 관계는 다음과 같다.

$$
x=o_x+(i-1)d_x
$$

여기서 여기서 $o_x$는 원점이고, $d_x$ 해당 디멘션의 그리드 간격이다.

그림 1.6 b-c와 같은 더 일반적인 경우에서, $x$와 $y$ 및 어레이 인덱스 $i$와 $j$ 사이의 관계는 다음과 같다.

$$
x=o_x+(i-1)d_x+(j-1)a_1
$$

$$
y=o_y+(i-1)a_2+(j-1)d_y
$$

여기서 $a_1$과 $a_2$를 아핀(affine) 파라미터라고 하며, 이것은 GDAL에서 사용하는 이른바 *지오변환*(geostransform)이다. $a_1=a_2=0$일 경우, 위 수식은 $d_x=d_y$인 정사각형 셀을 가진 그림 1.6a의 규칙 래스터로 단순화된다. 정수 인덱스의 경우, 좌표는 그리드 셀의 시작 모서리 좌표이며, 셀 면적(픽셀)은 인덱스 값이 $i$(포함)에서 $i+1$(제외)로 범위가 설정된 영역을 차지한다. 대부분의 이미지 형식에서 $d_y$는 음수이며, 이는 이미지 행 인덱스가 $y$값이 감소함에 따라(남쪽으로) 증가함을 의미한다. 왼쪽 상단 그리드 셀의 *중심* 좌표를 얻기 위해서는, $d_y$가 음수인 경우 $i=1.5$와 $j=1.5$를 사용한다.

직교형 래스터(그림 1.6의 네 번째 사례)의 경우, 어레이 인덱스를 차원 값에 매핑하기 위한 별도의 테이블이 필요하다. 예를 들어 NetCDF 파일은 공간 차원(좌표) 변수의 모든 값을 항상 저장하는데, 이는 주로 공간 그리드 셀의 중심 좌표값이거나 오프셋 값이다. 추가로, 그리드 셀의 경계를 저장하여 직교 차원을 정의하거나, 좌표 변수 값과 셀 경계 간의 관계를 명확히 표현할 수도 있다.

곡선형 래스터의(그림 1.6의 다섯 번째 사례)의 경우, 모든 $i,j$ 조합을 $x,y$ 쌍에 매핑하는 어레이가 필요하거나, 이를 수행하는 파라미터 함수(투영 또는 역투영 함수)가 필요하다. NetCDF 파일은 일반적으로 이 두 가지를 모두 제공한다. GDAL은 이러한 어레이를 지리위치(geolocation) 어레이라고 부르며, 이에 대한 변환 기능을 폭넓게 지원한다.

### 큐브 차원과 서포트

5.1절에서는 속성 변수의 *공간적* 서포트를 해당 관측 또는 예측과 관련된 지오메트리의 크기(길이, 면적, 부피)로 정의하였다. 이 개념은 *시간적* 서포트에도 적용된다. 시간은 시작과 종료가 명시된 기간으로 보고되는 경우가 많지 않지만, 종종 타임스탬프 자체가 기간을 암시한다. 예를 들어 ISO-8601 표준에서는 '2021'이 해당 연도 전체를, '2021-01'은 해당 연월 전체를 의미한다. 또 다른 경우에는, 현재 레코드의 타임스탬프에서 다음 레코드의 타임스탬프까지(타임스템프 자체는 제외)를 기간으로 간주하기도 한다.

예를 들어, MODIS 위성 이미지는 16일 동안의 관측을 단일 이미지로 합성한 식생 지수(NDVI 및 EVI)를 제공하는데, 이는 16일 '블록 서포트'를 갖는다. 반면 Sentinel-2나 Landsat-8은 특정 시점의 '스냅샷' 이미지를 제공하므로 '포인트 서포트'를 가진다. 시간적 포인트 서포트 데이터를 월별 값으로 집계할 경우, 해당 월에 속하는 모든 이미지를 선택하여 집계하면 된다. 그러나 MODIS의 16일 합성과 같이 시간적 블록 서포트를 가진 이미지를 다른 기간 단위로 집계할 때는, 목표 기간과 합성 기간의 겹치는 정도에 따라 가중치를 부여해야 한다.(역자주: 예를 들어, 세 개의 16일 합성 이미지(2024-12-17\~2025-01-01, 2025-01-01\~2025-01-16, 2025-01-16\~2025-02-01)가 있고, 목표 기간이 2025년 1월 평균이라면, 각 합성 이미지의 해당 합성 기간과 목표 기간의 중첩 비율에 따라 각각 1/16, 15/16, 16/16이 된다.) 이는 5.3절에서 다룬 면적-가중 인터폴레이션과 유사한 개념으로, 시간 영역에서의 가중 집계라 할 수 있다.

## 데이터 큐브 오퍼레이션

### 큐브의 분할: 필터

데이터 큐브는 특정 차원을 일정한 값으로 고정하여 여러 개의 서브-큐브로 분할할 수 있다. 그림 6.4는 시간, 스펙트럼, 또는 공간 디멘션을 이러한 방식으로 고정해 얻은 서브-큐브를 보여준다. 이 때 공간 필터링은 특정 공간 차원을 단일 값으로 고정하는 대신, 특정 하위-영역을 선택하는 방식으로 이루어는데, 이 방법이 더 일반적이다. $x$ 또는 $y$를 고정하면 해당 값의 횡단면을 따라 서브-큐브가 생성되며, 이를 통해 하나의 공간 차원과 하나의 시간 차원에서 속성을 색상으로 표현한 호브몰러 다이어그램(Hovmöller diagram)을 만들 수 있다.

```{r}
#| echo: false
#| eval: false
#| label: fig-6-4
#| fig-cap: "시간, 밴드, 또는 공간을 기준으로 한 데이터 큐브 필터링"

# filter ----
# mask <- matrix(c(rep(NA, 26), 1,NA,1,NA,1,1,1, rep(NA, 9)), ncol = 7)
mask <- matrix(c(NA,NA,NA,NA,NA,NA,
                 NA,NA,NA,NA,NA,NA,
                 NA,NA,NA, 1, 1, 1,
                 NA,NA, 1, 1, 1,NA,
                 NA,NA,NA, 1, 1,NA,
                 NA,NA,NA,NA,NA,NA,
                 NA,NA,NA,NA,NA,NA), ncol = 7)

print_grid <- function(x, y) {
  pl(f, 0+x, 0+y, pal = blues, m = b1)
  pl(f, 0+x, 10+y, pal = blues, m = b2)
  pl(f, 0+x, 20+y, pal = blues, m = b3)
  pl(f, 7+x, 0+y, pal = greens, m = g1)
  pl(f, 7+x, 10+y, pal = greens, m = g2)
  pl(f, 7+x, 20+y, pal = greens, m = g3)
  pl(f, 14+x, 0+y, pal = reds, m = r1)
  pl(f, 14+x, 10+y, pal = reds, m = r2)
  pl(f, 14+x, 20+y, pal = reds, m = r3)
  pl(f, 21+x, 0+y, pal = purples, m = n1)
  pl(f, 21+x, 10+y, pal = purples, m = n2)
  pl(f, 21+x, 20+y, pal = purples, m = n3)
}
print_alpha_grid <- function(x,y, alp = 0.2, geom = FALSE) {
  pl(f, 0+x, 0+y, pal = alpha(blues, alp), print_geom = geom,  m = b1, border = 1)
  pl(f, 0+x, 10+y, pal = alpha(blues, alp), print_geom = geom,  m = b2, border = 1)
  pl(f, 0+x, 20+y, pal = alpha(blues, alp), print_geom = geom,  m = b3, border = 1)
  pl(f, 7+x, 0+y, pal = alpha(greens, alp), print_geom = geom,  m = g1, border = 1)
  pl(f, 7+x, 10+y, pal = alpha(greens, alp), print_geom = geom,  m = g2, border = 1)
  pl(f, 7+x, 20+y, pal = alpha(greens, alp), print_geom = geom,  m = g3, border = 1)
  pl(f, 14+x, 0+y, pal = alpha(reds, alp), print_geom = geom,  m = r1, border = 1)
  pl(f, 14+x, 10+y, pal = alpha(reds, alp), print_geom = geom,  m = r2, border = 1)
  pl(f, 14+x, 20+y, pal = alpha(reds, alp), print_geom = geom,  m = r3, border = 1)
  pl(f, 21+x, 0+y, pal = alpha(purples, alp), print_geom = geom,  m = n1, border = 1)
  pl(f, 21+x, 10+y, pal = alpha(purples, alp), print_geom = geom,  m = n2, border = 1)
  invisible(pl(f, 21+x, 20+y, pal = alpha(purples, alp), print_geom = geom,  m = n3, border = 1))
}

print_grid_filter <- function(x, y) {
  pl(f, 0+x, 0+y, pal = blues, m = matrix(b1[mask == TRUE], ncol = 7))
  pl(f, 0+x, 10+y, pal = blues, m = matrix(b2[mask == TRUE], ncol = 7))
  pl(f, 0+x, 20+y, pal = blues, m = matrix(b3[mask == TRUE], ncol = 7))
  pl(f, 7+x, 0+y, pal = greens, m = matrix(g1[mask == TRUE], ncol = 7))
  pl(f, 7+x, 10+y, pal = greens, m = matrix(g2[mask == TRUE], ncol = 7))
  pl(f, 7+x, 20+y, pal = greens, m = matrix(g3[mask == TRUE], ncol = 7))
  pl(f, 14+x, 0+y, pal = reds, m = matrix(r1[mask == TRUE], ncol = 7))
  pl(f, 14+x, 10+y, pal = reds, m = matrix(r2[mask == TRUE], ncol = 7))
  pl(f, 14+x, 20+y, pal = reds, m = matrix(r3[mask == TRUE], ncol = 7))
  pl(f, 21+x, 0+y, pal = purples, m = matrix(n1[mask == TRUE], ncol = 7))
  pl(f, 21+x, 10+y, pal = purples, m = matrix(n2[mask == TRUE], ncol = 7))
  pl(f, 21+x, 20+y, pal = purples, m = matrix(n3[mask == TRUE], ncol = 7))
}

print_grid_time_filter <- function(x, y) { # 3x1, 28x7
  pl(f, 0+x, 10+y, pal = blues, m = b3)
  pl(f, 7+x, 10+y, pal = greens, m = g3)
  pl(f, 14+x, 10+y, pal = reds, m = r3)
  pl(f, 21+x, 10+y, pal = purples, m = n3)
}

print_grid_bands_filter <- function(x, y, pal = greys) { # 1x3 6x27
  pl(f, 0+x, 0+y, pal = pal, m = n1)
  pl(f, 0+x, 10+y, pal = pal, m = n2)
  pl(f, 0+x, 20+y, pal = pal, m = n3)
}

# build exactly like reduce
plot.new()
par(mar = c(3,3,3,3))
x <- 120
y <- 100
down <- 0
plot.window(xlim = c(0, x), ylim = c(0, y), asp = 1)
print_grid(x/2-28/2,y-27)
print_alpha_grid((x/3-28)/2, 0-down) # alpha grid
print_grid_time_filter((x/3-28)/2, -10-down) # select 3rd
print_alpha_grid(x/3+((x/3-6)/2) -10.5, 0-down) # alpha grid
print_grid_bands_filter(x/3+((x/3-12.4)), 0-down, pal = purples)
print_alpha_grid(2*(x/3)+((x/3-28)/2), 0-down) # alpha grid
print_grid_filter(2*(x/3)+((x/3-28)/2), 0-down)
text(3, 13.5-down, "time", srt = 90, col = "black")
text(43, 13.5-down, "time", srt = 90, col = "black")
text(83, 13.5-down, "time", srt = 90, col = "black")
text(20, 30, "bands", col = "black")
text(60, 30, "bands", col = "black")
text(100, 30, "bands", col = "black")
arrows(x/2-28/2,y-30, x/6,32, angle = 20, lwd = 2)
arrows(x/2,y-30, x/2,32, angle = 20, lwd = 2)
arrows(x/2+28/2,y-30, 100, 32, angle = 20, lwd = 2)
# points(seq(1,120,10), seq(1,120,10))
text(28.5,49, "filter temporally", srt = 55.5, col = "black", cex = 0.8)
text(57,49, "filter bands", srt = 90, col = "black", cex = 0.8)
text(91.5,49, "filter spatially", srt = -55.5, col = "black", cex = 0.8)
print_labels(x = x/2-28/2 + 3, y = y+4, off = 7, lab = c("blue", "green", "red", "nir"),
             horizontal = TRUE, cex = 0.6)
print_labels(x = x/2-28/2 - 9, y = y-23, off = 10, lab = c("2020-10-01", "2020-10-13", "2020-10-25"),
             horizontal = FALSE, cex = 0.6)
print_labels(x = x/2-28/2 + 21.5, y = y-30, off = 1, lab = xlabels,
             horizontal = TRUE, cex = 0.3)
print_labels(x = x/2-28/2 + 30, y = y-26.5, off = 1, lab = ylabels,
             horizontal = FALSE, cex = 0.3)

```

![시간, 밴드 혹은 공간을 기준으로 한 데이터 큐브 필터링](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-cube4filter-1.png){#fig-6-4}

### 디멘션에 함수 적용

잘 사용되는 또 다른 오퍼레이션은 하나 이상의 큐브 디멘션에 함수를 적용하는 것이다. 가장 간단한 예로는 `abs`, `sin` , `sqrt`와 같은 함수를 큐브의 모든 값에 적용하거나, 큐브 전체 값을 단일 스칼라로 반환하는 경우(예: 전체 평균이나 최대값 계산)가 있다. 또 다른 예로는 선택된 디멘션에만 함수를 적용하는 방식이 있다. 예를 들어, 그림 6.5처럼 각 개별(픽셀/밴드) 시계열에 시간적 로패스 필터(low-pass filter)를 적용하거나, 그림 6.6처럼 모든 밴드ㆍ시간 조합에 대해 각 공간 슬라이스에 공간적 로패스 필터를 적용하는 경우가 이에 해당한다.(역자주: 로패스 필터링은 데이터에서 저주파 성분은 통과시키고 고주파 성분은 차단하는 기법으로, 원본 이미지보다 평활화된 이미지를 생성한다. 하이패스 필터를 적용하면 반대로 저주파 성분은 차단하고 고주파 성분은 통과시켜 경계나 세부 구조가 강조된 이미지를 얻을 수 있다.)

```{r}
#| echo: false
#| eval: false
#| label: fig-6-5
#| fig-cap: "시계열 데이터에 로패스 필터링 적용하기"

print_text = function(s, x, y, m) {
  # m <- t(m) # transverse for correct order
  # print(m)
  r <- rep(seq(0.5, 5.5, 1), 7)
  r <- r + x # consider offsets
  u <- c(rep(0.5, 6), rep(1.5, 6), rep(2.5, 6), 
         rep(3.5, 6), rep(4.5, 6), rep(5.5, 6), rep(6.5, 6))
  u <- u + y # offset
  tab <- matrix(c(r,u), nrow = 42, byrow = FALSE) # make point table
  for (i in 1:42) {
    #text(tab[i, 1], tab[i, 2], labels = paste0("", m[i]), cex = 1.1)
    text(tab[i, 1], tab[i, 2], labels = paste0("", m[i]), cex = 0.8)
    }
}
time_arrow_seg <- matrix(c(c(-1.0, 0.3, 1.5, 2.7, 3.9, 5.1), c(-1.0, 0.3, 1.5, 2.7, 3.9, 5.1),
                           c(-0.5, 0.7, 1.9, 3.1, 4.3, 5.6), c(-0.5, 0.7, 1.9, 3.1, 4.3, 5.6)), ncol = 4)
time_arrow_flag_seg <- matrix(c(c(-1.0, 1.5, 2.7, 3.9), c(-1.0, 1.5, 2.7, 3.9),
                                c(0.7, 1.9, 3.1, 5.6), c(0.7, 1.9, 3.1, 5.6)), ncol = 4)

b11 <- b2 - t1
b12 <- b1 - t2 + t1

brks <- seq(0, 1000, 50)
# png("exp_apply_ts.png", width = 2400, height = 1000, pointsize = 24)
plot.new()
par(mar = c(2,2,2,2))
x <- 30
y <- 10 # 7.5
plot.window(xlim = c(0, x), ylim = c(0, y), asp = 1)
pl(f, 4.8, 3.8, pal = blues, m = b3, breaks = brks)
print_text(s, 4.8, 3.8, m = b3)
pl(f, 3.6, 2.6, pal = blues, m = b11, breaks = brks)
print_text(s, 3.6, 2.6, m = b11)
pl(f, 2.4, 1.4, pal = blues, m = b12, breaks = brks)
print_text(s, 2.4, 1.4, m = b12)
pl(f, 1.2, .2, pal = blues, m = b2, breaks = brks)
print_text(s, 1.2, .2, m = b2)
pl(f, 0, -1, pal = blues, m = b1, breaks = brks)
print_text(s, 0, -1, m = b1) # print text on left first stack
pl(f, 24.8, 3.8, pal = alpha(greys, 0.1), m = matrix(rep("NA", 42), ncol = 7))
pl(f, 23.6, 2.6, pal = blues, m = (b12 + b11 + b3) / 3, breaks = brks)
print_text(s, 23.6, 2.6, m = floor((b12 + b11 + b3) / 3))
pl(f, 22.4, 1.4, pal = blues, m = (b2 + b12 + b11) / 3, breaks = brks)
print_text(s, 22.4, 1.4, m = floor((b2 + b12 + b11) / 3))
pl(f, 21.2, .2, pal = blues, m = (b1 + b2 + b12) / 3, breaks = brks)
print_text(s, 21.2, .2, m = floor((b1 + b2 + b12) / 3))
pl(f, 20, -1, pal = alpha(greys, 0.1), m = matrix(rep("NA", 42), ncol = 7))
print_segments(5.7, 1.7, seg = time_arrow_seg, col = "forestgreen")
arrows(12.5, 9, 20, 9, lwd = 2)
cex <- .9
text(16.3, 8.3, "apply_dimension(dimension = 't')", cex = cex)
print_segments(9.7, 1.7, time_arrow_seg, col = "forestgreen") # draw ma explanation
text(-0.5 + 10, -0.5 + 2, "496", cex = cex)
text(.7 + 10, .7 + 2, "363", cex = cex)
text(1.9 + 10, 1.9 + 2, "658", cex = cex)
text(3.1 + 10, 3.1 + 2, "230", cex = cex)
text(4.3 + 10, 4.3 + 2, "525", cex = cex)
t_formula <- expression("t"[n]*" = (t"[n-1]*" + t"[n]*" + t"[n+1]*") / 3")
# text(13.8, 3, t_formula, srt = 45, cex = 1.2)
text(14.4, 3.6, "calculate moving average", srt = 45, cex = cex)
arrows(15, 5.7, 18, 5.7, lwd = 2)
print_segments(15.4, 1.7, seg = time_arrow_seg, col = "forestgreen") # draw ma explanation
text(-0.5 + 15.7, -0.5 + 2, "NA", cex = cex)
text(.7 + 15.7, .7 + 2, "505", cex = cex)
text(1.9 + 15.7, 1.9 + 2, "417", cex = cex)
text(3.1 + 15.7, 3.1 + 2, "471", cex = cex)
text(4.3 + 15.7, 4.3 + 2, "NA", cex = cex)
print_segments(25.7, 1.7, seg = time_arrow_seg, col = "forestgreen")

```

![시계열 데이터에 로패스 필터링 적용하기](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-cube4apply1-1.png){#fig-6-5}

```{r}
#| echo: false
#| eval: false
#| label: fig-6-6
#| fig-cap: "공간 슬라이스에 로패스 필터링 적용하기"

# apply ----

abs_brks <- seq(-500,500, 50)
abs_pal <- sequential_hcl(n = 20, h1 = 211, c1 = 80, l1 = 30, l2 = 100, p1 = 1.2)

vNeumann_seg <- matrix(c(c(0,0,1,1,2,2,1,1,0,0,-1,-1), c(0,-1,-1,0,0,1,1,2,2,1,1,0), 
                         c(0,1,1,2,2,1,1,0,0,-1,-1,0), c(-1,-1,0,0,1,1,2,2,1,1,0,0)), ncol = 4)

apply_filter <- function(input, pad = TRUE, padValue = 1) {
  ras <- raster::focal(raster::raster(input), w = matrix(c(0,0.2,0, 0.2,0.2,0.2, 0,0.2,0), ncol = 3), pad = pad, padValue = padValue)
  ras <- raster::as.matrix(ras)
  ras[ras == "NaN"] <- -999
  return(floor(ras))
}

brks <- seq(0, 1000, 50)
plot.new()
par(mar = c(0,2,0,0))
x = 30
y = 7.5
plot.window(xlim = c(0, x), ylim = c(0, y), asp = 1)
pl(f, 3, 2, pal = blues, m = b3, breaks = brks)
pl(f, 1.5, .5, pal = blues, m = b2, breaks = brks)
pl(f, 0, -1, pal = blues, m = b1, breaks = brks)
print_text(s, 0, -1, m = b1) # print text on left first stack
print_segments(2, 3, seg = vNeumann_seg, lwd = 3)
pl(f, 23, 2, pal = blues, m = apply_filter(b3), breaks = brks)
pl(f, 21.5, 0.5, pal = blues, m = apply_filter(b2), breaks = brks)
pl(f, 20, -1, pal = blues, m = apply_filter(b1), breaks = brks)
print_text(s, 20, -1, m = apply_filter(b1)) # set pad = FALSE for -99
print_segments(22, 3, seg = vNeumann_seg, lwd = 3)
arrows(11, 4, 17.5, 4, lwd = 3)
text(14.3, 3.5, "apply_kernel()", cex = 1.4)
print_segments(13.8, 1, seg = vNeumann_seg, lwd = 3)
cex = .8
text(14.3, 1.5, "0.2", cex = cex)
text(13.3, 1.5, "0.2", cex = cex)
text(15.3, 1.5, "0.2", cex = cex)
text(14.3, 2.5, "0.2", cex = cex)
text(14.3, .5, "0.2", cex = cex)

```

![공간 슬라이스에 로패스 필터링 적용하기](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-cube4apply2-1.png){#fig-6-6}

### 디멘션 축소

전체 데이터 큐브에 `mean` 함수를 적용하면 모든 차원이 사라지고, 결과로 생성된 '데이터 큐브"는 차원 0을 갖게 된다. 함수는 특정 디멘션 집합에만 적용할 수도 있는데, 이 경우 해당 디멘션만 사라지거나 *축소*된다. 필터링이 이러한 디멘션 축소의 한 형태라는 점은 이미 살펴본 바 있다. 마찬가지로, 모든 시계열의 최대값을 계산하거나 각 공간 슬라이스의 평균을 구하는 작업, NDVI와 같은 밴드 지수를 계산하여 서로 다른 스펙트럼 값을 단일한 새로운 '밴드'로 요약하는 것도 모두 차원 축소에 해당한다. 그림 6.7은 이러한 다양한 옵션을 보여준다.

```{r}
#| echo: false
#| eval: false
#| label: fig-6-7
#| fig-cap: "데이터 큐브의 차원 축소"

# reduce ----

# calc mean over time
timeB <- (b1 + b2 + b3) / 3
timeG <- (g1 + g2 + g3) / 3
timeR <- (r1 + r2 + r3) / 3
timeN <- (n1 + n2 + n3) / 3

print_grid_time <- function(x, y) { # 3x1, 28x7
  pl(f, 0+x, 10+y, pal = blues, m = timeB)
  pl(f, 7+x, 10+y, pal = greens, m = timeG)
  pl(f, 14+x, 10+y, pal = reds, m = timeR)
  pl(f, 21+x, 10+y, pal = purples, m = timeN)
}

# calc ndvi
ndvi1 <- (n1 - r1) / (n1 + r1)
ndvi2 <- (n2 - r2) / (n2 + r2)
ndvi3 <- (n3 - r3) / (n3 + r3)

print_grid_bands <- function(x, y, pal = greys) { # 1x3 6x27
  pl(f, 0+x, 0+y, pal = pal, m = ndvi1)
  pl(f, 0+x, 10+y, pal = pal, m = ndvi2)
  pl(f, 0+x, 20+y, pal = pal, m = ndvi3)
}

plte = function(s, x, y, add = TRUE, randomize = FALSE, pal, m) {
  attr(s, "dimensions")[[1]]$offset = x
  attr(s, "dimensions")[[2]]$offset = y
  # m = r[[1]][y + 1:nrow,x + 1:ncol,1]
  # dim(m) = c(x = nrow, y = ncol) # named dim
  # s[[1]] = m
  # me <- floor(mean(s[[1]]))
  me <- floor(mean(m))
  if (me[1] > 100) { # in case non-artificial grids with very high
    me <- m / 10     # numbers are used, make them smaller
    me <- floor(mean(me))
  }
  text(x,y,me,cex = 0.8)
}

print_grid_spat <- function(x, y) {
  x = x + 3
  y = y + 3.5
  plte(s, 0+x, 0+y, pal = blues, m = b1)
  plte(s, 0+x, 10+y, pal = blues, m = b2)
  plte(s, 0+x, 20+y, pal = blues, m = b3)
  plte(s, 7+x, 0+y, pal = greens, m = g1)
  plte(s, 7+x, 10+y, pal = greens, m = g2)
  plte(s, 7+x, 20+y, pal = greens, m = g3)
  plte(s, 14+x, 0+y, pal = reds, m = r1)
  plte(s, 14+x, 10+y, pal = reds, m = r2)
  plte(s, 14+x, 20+y, pal = reds, m = r3)
  plte(s, 21+x, 0+y, pal = purples, m = n1)
  plte(s, 21+x, 10+y, pal = purples, m = n2)
  plte(s, 21+x, 20+y, pal = purples, m = n3)
}

# png("exp_reduce.png", width = 1200, height = 1000, pointsize = 32)
plot.new()
#par(mar = c(3,3,3,3))
par(mar = c(3,0,2,0))
x = 120
y = 100
plot.window(xlim = c(0, x), ylim = c(0, y), asp = 1)
print_grid(x/2-28/2,y-27)
# print_alpha_grid((x/3-28)/2, 0) # alpha grid
print_grid_time((x/3-28)/2, 0) # off = 5.5
# print_alpha_grid(x/3+((x/3-6)/2) -10.5, 0) # alpha grid
print_grid_bands(x/3+((x/3-6)/2), 0)
print_alpha_grid(2*(x/3)+((x/3-28)/2), 0, alp = 0, geom = TRUE) # alpha grid
print_grid_spat(2*(x/3)+((x/3-28)/2), 0)
text(3, 13.5, "time", srt = 90, col = "black")
#segments(3.6, 8, 3.7, 19, col = "red", lwd=3)
segments(3.4, 8, 3.4, 19, col = "red", lwd = 3)
text(43, 13.5, "time", srt = 90, col = "black")
text(83, 13.5, "time", srt = 90, col = "black")
text(20, 30, "bands", col = "black")
text(60, 30, "bands", col = "black")
segments(53,29.8, 67,29.8, col = "red", lwd = 3)
text(100, 30, "bands", col = "black")
text(30, 7, "x", col = "black")
text(36, 13, "y", col = "black")
text(60, -3, "x", col = "black")
text(66, 3, "y", col = "black")
text(110, -3, "x", col = "black")
text(116, 3, "y", col = "black")
segments(108,-2.4, 112,-3.2, col = "red", lwd = 3)
segments(114,3.2, 118,2.4, col = "red", lwd = 3)
text(60, y+4, "bands", col = "black") # dim names on main
text(43, y-14, "time", srt = 90, col = "black")
text(x/2-28/2 + 24, y-30, "x", col = "black")
text(x/2-28/2 + 30, y-24, "y", col = "black")
arrows(x/2-28/2,y-30, x/6,32, angle = 20, lwd = 2)
arrows(x/2,y-30, x/2,32, angle = 20, lwd = 2)
arrows(x/2+28/2,y-30, 100, 32, angle = 20, lwd = 2)
# points(seq(1,120,10), seq(1,120,10))
text(28.5,49, "reduce temporally", srt = 55.5, col = "black", cex = 0.8)
text(57,49, "reduce bands", srt = 90, col = "black", cex = 0.8)
text(91.5,49, "reduce spatially", srt = -55.5, col = "black", cex = 0.8)

```

![데이터 큐브의 차원 축소](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-cube4reduce-1.png){#fig-6-7}

## 래스터 큐브를 벡터 큐브로 애그리게이션 하기

그림 6.8은 4차원 래스터 데이터 큐브를 3차원 *벡터 데이터 큐브*로 애그리게이션 하는 과정을 보여준다. 래스터의 픽셀은 벡터 지오메트리와의 공간적 인터섹션 관계에 따라 그룹화되며, 각 그룹은 평균이나 최대값과 같은 집계 함수를 통해 단일 값으로 축소된다. 예를 들어, 두 개의 공간적 디멘션 $x$와 $y$는 피처 지오메트리의 1차원적 시퀀스로 구성된 단일 디멘션으로 축소되는데, 여기서 피처 지오메트리는 $x$와 $y$의 좌표를 갖는 공간 상에서 정의된다. 애그리게이션은 `POINT` 지오메트리를 기준으로 수행할 수도 있으며, 이 경우에는 집계 함수가 필요 없다. `POINT` 위치에서의 속성값은 해당 위치의 픽셀 값을 쿼리하거나, 가장 가까운 픽셀로부터 인터폴레이션하여 *추출*할 수 있다.

```{r}
#| echo: false
#| eval: false
#| label: fig-6-8
#| fig-cap: "래스터 데이터 큐브를 벡터 데이터 큐브로 애그리게이션 하기"

# aggregate ----

mask_agg <- matrix(c(NA,NA,NA,NA,NA,NA,
                 NA, 1, 1,NA,NA,NA,
                  1, 1,NA,NA, 1,NA,
                  1,NA,NA, 1, 1,NA,
                  1,NA,NA, 1, 1,NA,
                  1,NA,NA,NA, 1,NA,
                 NA,NA,NA,NA,NA,NA), ncol = 7)

pl_stack_agg <- function(s, x, y, add = TRUE, nrM, imgY = 7, inner = 1) {
  # pl_stack that masks the added matrices
  # nrM is the timestep {1, 2, 3}, cause this function
  # prints all 4 bands at once
  attr(s, "dimensions")[[1]]$offset = x
  attr(s, "dimensions")[[2]]$offset = y
  # m = r[[1]][y + 1:nrow,x + 1:ncol,1]
  m <- eval(parse(text=paste0("n", nrM)))
  m <- matrix(m[mask_agg == TRUE], ncol = 7)
  s[[1]] = m[,c(imgY:1)] # turn around to have same orientation as flat plot
  plt(s, 0, TRUE,  pal = purples)
  m <- eval(parse(text=paste0("r", nrM)))
  m <- matrix(m[mask_agg == TRUE], ncol = 7)
  s[[1]] = m[,c(imgY:1)]
  plt(s, 1*inner, TRUE,  pal = reds)
  m <- eval(parse(text=paste0("g", nrM)))
  m <- matrix(m[mask_agg == TRUE], ncol = 7)
  s[[1]] = m[,c(imgY:1)]
  plt(s, 2*inner, TRUE,  pal = greens)
  m <- eval(parse(text=paste0("b", nrM)))
  m <- matrix(m[mask_agg == TRUE], ncol = 7)
  s[[1]] = m[,c(imgY:1)]
  plt(s, 3*inner, TRUE, pal = blues) # li FALSE
}

polygon_1 <- matrix(c(c(0.0, 5.1, 4.9,-2.3), c(0.0, 2.4, 3.1, 1.8),
                      c(5.1, 4.9,-2.3, 0.0), c(2.4, 3.1, 1.8, 0.0)), ncol = 4)

a <- make_dummy_stars(6, 7, 5, -1.14, -2.28)

print_vector_content <- function(x, y, cex = 0.8) {
  vec <- floor(rnorm(8, 250, 100))
  text( 0 + x,12 + y, vec[1], cex = cex)
  text( 0 + x, 8 + y, vec[2], cex = cex)
  text( 0 + x, 4 + y, vec[3], cex = cex)
  text( 0 + x, 0 + y, vec[4], cex = cex)
  text( 12 + x,12 + y, vec[5], cex = cex)
  text( 12 + x, 8 + y, vec[6], cex = cex)
  text( 12 + x, 4 + y, vec[7], cex = cex)
  text( 12 + x, 0 + y, vec[8], cex = cex)
}

print_ts <- function(off2, yoff2) {
  pl_stack(s, 0 + off2, yoff2, nrM = 3) # input 2
  pl_stack(s, off + off2, yoff2, nrM = 2)
  pl_stack(s, 2 * off + off2, yoff2, nrM = 1)
  arrows(-13 + off2, 14 + yoff2, 72 + off2, 14 + yoff2, angle = 20, lwd = 2)  # timeline
  heads <- matrix(c(3.5+off2, 3.5 + off + off2, 3.5 + 2*off + off2, 14+yoff2,14+yoff2,14+yoff2), ncol = 2)
  points(heads, pch = 16) # 4 or 16
  segments(c(-8, 7, 0, 15)+off2, c(-1,-1,3,3)+yoff2, 3.5+off2, 14+yoff2) # first stack pyramid
  segments(c(-8, 7, 0, 15) + off + off2, c(-1,-1,3,3)+yoff2, 3.5 + off + off2, 14+yoff2) # second stack pyramid
  segments(c(-8, 7, 0, 15) + 2*off + off2, c(-1,-1,3,3)+yoff2, 3.5 + 2*off + off2, 14+yoff2) # third stack pyramid
  text(7.5+off2, 4.3+yoff2, "x", col = "black", cex = secText)
  text(-9.5+off2, -2.5+yoff2, "bands", srt = 90, col = "black", cex = secText)
  text(-4.5+off2, 2+yoff2, "y", srt = 27.5, col = "black", cex = secText)
  text(69+off2, 15.5+yoff2+1, "time", col = "black")
  text(3.5+off2, 15.5+yoff2, "2020-10-01", col = "black")
  text(3.5 + off + off2, 15.5+yoff2, "2020-10-13", col = "black")
  text(3.5 + 2*off + off2, 15.5+yoff2, "2020-10-25", col = "black")
}

secText <- 0.8 # secondary text size (dimension naming)
off <- 26 # image stacks are always 26 apart
x <- 72 # png X
y <- 48 # png Y
yoff <- 30
plot.new()
par(mar = c(5,3,3,3))
plot.window(xlim = c(-5, x+4), ylim = c(-1, y), asp = 1)
print_ts(5, yoff)
col <- '#ff5555'
print_segments(10.57, yoff-.43, seg = polygon_1, col = col)
x = 3
segments(c(2, 0, -1.3)+x, c(-.2, 0, 1)+yoff, c(0, -1.3, 1)+x, c(0, 1, 2)+yoff, lwd = 4, col = col)
print_segments(10.57+off, yoff-.43, seg = polygon_1, col = col)
x = 3 + off
segments(c(2, 0, -1.3)+x, c(-.2, 0, 1)+yoff, c(0, -1.3, 1)+x, c(0, 1, 2)+yoff, lwd = 4, col = col)
print_segments(10.57+2*off, yoff-.43, seg = polygon_1, col = col)
x = 3 + 2 * off
segments(c(2, 0, -1.3)+x, c(-.2, 0, 1)+yoff, c(0, -1.3, 1)+x, c(0, 1, 2)+yoff, lwd = 4, col = col)
# old 75 28 poly 86.25, 27.15
pl_stack_agg(a, 5, 5, nrM = 1, inner = 3) # print masked enlargement
print_segments(16.25, 7.15, seg = polygon_1, by = 2, col = col)
x <- 1
y <- 8
segments(c(4, 0, -2.6)+x, c(-.4, 0, 2)+y, c(0, -2.6, 2)+x, c(0, 2, 4)+y, lwd = 4, col = col) # line in large
segments(-3, 25, -7, 9, lwd = 3, col = 'grey')
segments(21, 29, 27.5, 14, lwd = 3, col = 'grey')
text(10, 20, "1. Group by geometry", cex = 1.3)
vecM <- matrix(rep(1,8), ncol = 2)
text(57, 21, "2. Reduce to vector cube", cex = 1.3)
b <- make_dummy_stars(2, 4, 12, 4, 0)
pl(b, 48, -5, m = vecM, pal = alpha("white", 0.9), border = 0)
print_vector_content(54, -3)
pl(b, 46.5, -3.5, m = vecM, pal = alpha("white", 0.9), border = 0)
print_vector_content(52.5, -1.5)
pl(b, 45, -2, m = vecM, pal = alpha("white", 0.9), border = 0)
print_vector_content(51, 0)
text(51.5, 15, "Line_1", col = col)
text(63, 15, "Polygon_1", col = col)
text(57, 17.5, "Geometries", cex = 1.1)
text(42, 12, "blue")
text(42,  8, "green")
text(42,  4, "red")
text(42,  0, "nir")
text(38, 6, "Bands", srt = 90, cex = 1.1)
# arrows(13.5, -2, 13.5, -6, angle = 20, lwd = 3)
text(72, 15.5, "time", srt = 315, cex = 1.1)
arrows(69.5, 15, 72.5, 12, angle = 20, lwd = 2)
# print_segments(30, 35, seg = arrow_seg)

```

![래스터 데이터 큐브를 벡터 데이터 큐브로 애그리게이션 하기](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-cube4agg-1.png){#fig-6-8}

또 다른 벡터 데이터 큐브의 사례로는 대기질 데이터를 들 수 있다. 2차원의 $PM_{10}$ 데이터는 다음을 기준으로 구성될 수 있다.

-   모니터링 스테이션

-   시간 간격

이와 유사하게, 인구 수로 구성된 시계열 인구 데이터나 환자 수로 구성된 시계열 역학 데이터도 벡터 데이터 큐브로 정의될 수 있다. 예를 들어, 다음과 같은 기준이 있다.

-   지역: $n$개의 지역

-   연령 그룹: $m$개의 연령 그룹

-   연도: $p$개의 연도

이 경우, 데이터는 $nmp$로 구성된 어레이를 형성한다.

공간데이터사이언스에서 벡터 및 래스터 데이터 큐브를 다루는 것은 매우 유용하다. 이는 많은 변수가 공간적ㆍ시간적으로 변동하며, 디멘션 변경이나 애그리게이션과 같은 작업을 완전히 유연하면서도 체계적인 방식으로 수행할 수 있게 해주기 때문이다. 디멘션 변경의 예는 다음과 같다.

-   대기질 측정값을 규칙 그리드(래스터) 상에 인터폴레이션하는 것(12장)

-   포인트나 라인 분포 데이터로부터 밀도 값을 추정하는 것, 예를 들어 주 1회 비행기 통과 횟수를 1km 탐색 반경을 기준으로 추정하는 것(11장)

-   기후 모델 예측값을 행정구역별로 요약 지표로 애그리게이션하는 것

-   MODIS(250m 픽셀, 16일 주기)와 Sentinel-2(10m 픽셀, 5일 주기)와 같은 서로 다른 센서의 지구 관측 데이터를 결합하는 것

하나 이상의 디멘션을 완전히 애그리게이션하는 사례는 다음과 같다.

-   대기질 모니터링 스테이션 중 나쁨 수준 기록 지점 파악(시간)

-   질병 발생률에서 가장 크게 증가한 지역 탐색(공간, 시간)

-   지구 온난화 추세 분석(10년 당 지구 전체의 섭씨 온도 변화)

## 디멘션을 속성으로 교체하기

디멘션이 순서가 없는 범주적 성격을 띠는 경우, 속성 집합을 하나의 단일 디멘션으로 쉽게 변환할 수 있다. 즉, 아래 첫 번째 수식을 두 번째 수식으로 대체할 수 있다.

$$
\{Z_1,Z_2,...,Z_p\}=f(D_1,D_2,...,D_n)
$$

$$
Z=f(D_1,D_2,...,D_n,D_{n+1})
$$

여기서 $D_{n+1}$는 기수 $p$를 가지며 레이블로서 $Z_1,Z_2,...,Z_p$(라는 이름)을 갖는다. 그림 6.9는 대기질 스테이션에 대한 벡터 데이터 큐브를 보여주는데, 한 디멘션이 대기질 파라미터들로 구성되어 있음을 볼 수 있다. 그림 6.9와 같이 $Z_i$가 서로 전혀 다른 측정 단위를 갖는 경우 '파라미터' 디멘션 $D_{n+1}$을 축소할 때는 주의가 필요하다. 예를 들어, `mean` 또는 `max`와 같은 함수를 적용하는 것은 의미가 없지만, 각 변수의 임계값을 초과하는 관측치의 개수를 세는 것은 의미가 있을 수 있다.

```{r}
#| echo: false
#| eval: false
#| label: fig-6-9
#| fig-cap: "대기질의 시계열 데이터를 가진 벡터 데이터 큐브"

set.seed(1331)
library(stars)
library(colorspace)
tif <- system.file("tif/L7_ETMs.tif", package = "stars")
r <- read_stars(tif)

nrow <- 5
ncol <- 8
#m = matrix(runif(nrow * ncol), nrow = nrow, ncol = ncol)
m <- r[[1]][1:nrow,1:ncol,1]
dim(m) <- c(x = nrow, y = ncol) # named dim
s <- st_as_stars(m)
# s
attr(s, "dimensions")[[1]]$delta = 3 
attr(s, "dimensions")[[2]]$delta = -.5
attr(attr(s, "dimensions"), "raster")$affine = c(-1.2, 0.0)

plt <- function(x, yoffset = 0, add, li = TRUE) {
    attr(x, "dimensions")[[2]]$offset = attr(x, "dimensions")[[2]]$offset + yoffset 
    l = st_as_sf(x, as_points = FALSE)
    pal = sf.colors(10)
    if (li)
        pal = lighten(pal, 0.3 + rnorm(1, 0, 0.1))
    if (! add)
        plot(l, axes = FALSE, breaks = "equal", pal = pal, reset = FALSE, border = grey(.75), key.pos = NULL, main = NULL, xlab = "time")
    else
        plot(l, axes = TRUE, breaks = "equal", pal = pal, add = TRUE, border = grey(.75))
    u = st_union(l)
    plot(st_geometry(u), add = TRUE, col = NA, border = 'black', lwd = 2.5)
}

pl <- function(s, x, y, add = TRUE, randomize = FALSE) {
  attr(s, "dimensions")[[1]]$offset = x
  attr(s, "dimensions")[[2]]$offset = y
  m = r[[1]][y + 1:nrow,x + 1:ncol,1]
  if (randomize)
    m = m[sample(y + 1:nrow),x + 1:ncol]
  dim(m) = c(x = nrow, y = ncol) # named dim
  s[[1]] = m
  plt(s, 0, add)
  plt(s, 1, TRUE)
  plt(s, 2, TRUE)
  plt(s, 3, TRUE)
  plt(s, 4, TRUE)
  plt(s, 5, TRUE)
  plt(s, 6, TRUE)
  plt(s, 7, TRUE)
  plt(s, 8, TRUE, FALSE)
}

# point vector data cube:
plot.new()
par(mar = c(5, 0, 5, 0))
plot.window(xlim = c(-10, 16), ylim = c(-2,12), asp = 1)
library(spacetime)
data(air)
de = st_geometry(st_normalize(st_as_sf(DE)))
# 
pl(s, 0, 0, TRUE, randomize = TRUE)
de = de * 6 + c(-7, 9)
plot(de, add = TRUE, border = grey(.5))
text(-10, 0, "time", srt = -90, col = 'black')
text(-5,  7.5, "sensor location", srt = 25, col = 'black')
text( 7,  10.5, "air quality parameter", srt = 0, col = 'black')
text( 1.5,  8.5, expression(PM[10]), col = 'black', cex = .75)
text( 4.5,  8.5, expression(NO[x]), col = 'black', cex = .75)
text( 8,  8.5, expression(SO[4]), col = 'black', cex = .75)
text( 11,  8.5, expression(O[3]), col = 'black', cex = .75)
text( 14,  8.5, expression(CO), col = 'black', cex = .75)
# location points:
p <- st_coordinates(s[,1])
p[,1] <- p[,1]-1.4
p[,2] <- p[,2] + 8.2
points(p, col = grey(.7), pch = 16)
# centroids:
set.seed(131)
cent <- st_coordinates(st_sample(de, 8))
points(cent, col = grey(.7), pch = 16)
cent <- cent[rev(order(cent[,1])),]
seg <- cbind(p, cent[1:8,])
segments(seg[,1], seg[,2], seg[,3], seg[,4], col = 'grey')

```

![대기질의 시계열 데이터를 가진 벡터 데이터 큐브](https://r-spatial.org/book/06-Cubes_files/figure-html/fig-aqdc-1.png){#fig-6-9}

디멘션과 속성을 유연하게 교환할 수 있게 되면, 분석의 유연성과 확장 가능성이 크게 높아진다(Brown, 2010).

## 기타 동적 공간데이터

앞서 우리는 데이터 큐브 구조와 잘 맞는 다양한 동적 래스터 및 벡터 데이터의 예를 살펴보았다. 그러나 일부 데이터 유형은 그렇지 않다. 특히 시공간 포인트 패턴(11장)과 경로 데이터\[이동 데이터; 최근 리뷰는 Joo et al. (2020) 참조\]는 데이터 큐브로 처리하기보다는 보다 간단한 방식으로 다루어지는 경우가 많다. 시공간 포인트 패턴은 사건이나 객체의 시공간 좌표 집합을 의미한다. 예를 들어, 사고, 발병, 교통 체증, 번개와 같은 사례가 있다. 한편, 경로 데이터는 사람, 자동차, 위성, 동물과 같이 이동하는 객체의 공간적 위치를 시간 순서대로 기록한 시퀀스이다. 경로 데이터의 핵심 정보는 좌표값이며, 이를 일정하게 분할된 그리드 셀 체계의 위치값으로 변환하여 사용할 수 있다. 이러한 변환은 고밀도 지역에서 패턴을 빠르게 탐색하는 등 일부 분석에서 유용하지만, 좌표의 정확성이 손실되어 거리, 방향, 속도 계산과 같은 여러 접근을 어렵게 만든다. 그럼에도 불구하고, 이러한 데이터를 데이터 큐브 형태로 전환하여 사용하는 경우가 종종있다. 이 경우, 시간을 고정한 상태에서 공간을 이산화하거나, 공간을 고정한 상태에서 시간을 이산화하는 방법이 활용된다.

포인트 패턴이나 경로 데이터를 희소(sparse) 어레이 형태로 표현할 수 있으며, 이를 위해 SciDB(Brown, 2010) 또는 TileDB(Papadopoulos et al., 2016)와 같은 시스템을 사용할 수 있다. 이러한 방법은 좌표 정확도 손실의 문제를 상당 부분 완화할 수 있는데, 이를 위해 극도로 세밀한 그리드 디멘션을 선택하거나 데이터 포인트를 포함하는 그리드 셀만을 선택하는 전략이 가능하다. 경로 데이터의 경우에는 개체 단위를 식별하거나, 연속된 이동 시퀀스를 구분하기 위해 별도의 그룹화 디멘션을 추가해야 한다.

## 연습문제

다음의 연습문제에 대해 서술형으로 답하시오. 필요하거나 적절하다면, 주장을 설명하기 위해 R 코드를 활용하시오.

1.  데이터 큐브를 사용하여 이동하는 물체의 경로와 시퀀스 ($x$, $y$, $t$)를 표현하는 것이 어려운 이유를, 이 장의 내용을 바탕으로 답하시오.

2.  인구, 기대 수명, 국내총생산과 같은 변수로 구성된 사회경제적 벡터 데이터 큐브에서 국가와 연도를 디멘션으로 정렬할 때, 어떤 변수들이 공간 디멘션에 대한 블록 스포트를 가지며, 어떤 변수들이 시간 디멘션에 대한 블록 스포트을 가지는지 설명하시오.

3.  Sentinel-2 위성이 수집한 12개의 스펙트럼 밴드를 (i) 밴드별로 별도의 데이터 큐브를 구성하는 경우, (ii) 12개 밴드를 각각 속성으로 갖는 하나의 데이터 큐브로 구성하는 경우, (iii) 스펙트럼 디멘션을 가진 단일 속성 데이터 큐브로 구성하는 경우에 대해, 각각의 장점과 단점을 나열하시오.

4.  그림 1.6에 나타난 곡선 래스터가 특별한 데이터 큐브로 간주될 수 있는 이유를 설명하시오.

5.  다음 문제들이 데이터 큐브 오퍼레이션인 필터, 적용, 축소, 애그리게이션을 사용하여 어떻게 해결될 수 있는지, 그리고 어떤 순서로 적용해야 하는지 설명하시오. 또한 각 문제에 대해 적용되는 함수와, 결과 데이터 큐브의 디멘션(해당되는 경우)을 명시하시오.

    -   대기질 모니터링 스테이션의 시간별 $PM_{10}$ 측정치로부터, 스테이션별 일평균이 50 $\mu g/m^3$를 초과하는 연간 일수를 계산하시오.
    -   석유 유출의 항공 이미지 시퀀스를 사용하여, 석유 유출 범위가 가장 넓었던 시점과 그 때의 해당 범위를 찾으시오.
    -   10년간의 전 세계 일일 해수면 온도(SST) 래스터 맵을 사용하여, SST 값의 시간적 추세가 상위 10%에 해당하는 지역과 하위 10%에 해당하는 지역을 찾으시오.
