---
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
editor_options: 
  chunk_output_type: console
---

# 포인트 패턴 분석 {#sec-point}

포인트 패턴 분석은 공간상에 나타난 포인트의 분포 패턴을 기술하거나, 그러한 패턴을 생성한 프로세스에 대해 추론하는 기법이다. 여기서 핵심은 포인트의 위치 정보인데, 이 위치는 표본추출을 위해 임의로 정한 지점이 아니라 특정한 프로세스의 결과물이다(예: 동물 목격 지점, 사고 지점, 발병 지점, 수목 위치 등). 이는 모든 지점에서 해당 현상이 존재하지만 관측값은 연구자가 통제한 관측 지점에서만 얻어진다고 보는 지구통계학적 프로세스(12장)와 대조적이다. 지구통계학적 연구의 주된 관심은 관측 지점 자체가 아니라 관측되지 않은 지점의 값을 추정하는 데 있다. 반면, 포인트 패턴 분석에서는 연구 대상 지역의 모든 지점에서 관측이 이루어질 수 있다고 가정한다. 이 경우, 특정 지점에 포인트가 없다는 것은 관측이 이루어지지 않았다는 뜻이 아니라(지구통계학적 프로세스와의 차이점), 관측은 이루어졌지만 현상이 발생하지 않았다는 의미다. 확률 과정(random process)의 관점에서 보면, 포인트 패턴 분석에서는 위치가 확률 변수인 반면, 지구통계학적 분석에서 측정 변수가 고정된 위치를 갖는 랜덤 필드(random field)이다.

이 장에서는 **spatstat** 패키지(Baddeley, Turner, Rubak 2022)를 활용한 포인트 패턴 분석의 기초만을 다룬다. 포인트 패턴 이론과 **spatstat** 및 관련 패키지 사용에 대한 포괄적인 내용은 Baddeley, Rubak, Turner(2015)의 **spatstat** 저서에 잘 정리되어 있다. 여기서는 특정 주제만을 다루지만, 그렇다고 해서 이 주제들이 누락된 다른 주제들보다 더 중요하다는 의미는 아니다. 또한 **spatstat** 패키지와 보다 공간데이터사이언스 지향적인 패키지인 **sf** 및 **stars** 간의 인터페이스 설명에도 지면을 할애한다. 포인트 패턴 분석을 소개하는 또 다른 참고서로는 Stoyan et al.(2017)가 있으며, 시공간 포인트 프로세스 분석용 R 패키지인 **stpp**(Gabriel et al. 2022)에 대해서는 Gabriel, Rowlingson, Diggle(2013)을 참조할 수 있다.

포인트 패턴 분석에서 중요한 개념은 포인트 *패턴*과 포인트 *프로세스*를 구분하는 것이다. 포인트 프로세스는 포인트 패턴을 생성하는 확률 과정(stochastic process)이며, 우리가 다루는 데이터셋은 항상 포인트 패턴이다. 분석의 목적은 관찰된 패턴을 생성했을 가능성이 있는 포인트 프로세스의 특성을 파악하는 데 있다. 공간 포인트 프로세스의 주요 특성은 다음과 같다.

-   1차 특성: 강도 함수(intensity function)는 단위 면적당 포인트의 수를 나타내며, *이질적*(inhomogeneous) 포인트 프로세스에서는 공간적으로 변동한다.

-   2차 특성: 주어진 강도 함수(고정 혹은 변동) 하에서, 포인트들이 *서로* 독립적으로 분포하는지, 서로 끌어당기는 경향이 있는지(군집화), 혹는 서로 밀어내는 경향이 있는지(완전 공간 무작위성(complete spatial randomness)보다 더 규칙적인 분포인지)를 묘사한다.

## 관측 윈도우

포인트 패턴을 관측 윈도우(observation window)를 가진다. 관측 윈도우는 포인트가 기록될 수 있는 공간적 범위를 정의하며, 분석에서 중요한 역할을 한다. 다음 코드는 무작위 포인트 패턴을 생성하는 예시이다.

```{r}
#| eval: false
library(sf)
# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE
n <- 30
set.seed(13531) # remove this to create another random sequence
xy <- data.frame(x = runif(n), y = runif(n)) |> 
    st_as_sf(coords = c("x", "y"))
```

이 포인트들은 $[0,1]\times[1,0]$ 영역 내에 고르게 분포하고 있으며, 완전한 공간적 무작위 분포로도 표현할 수 있다. 그러나 영역의 크기가 커지면 '고르게 분포한다'고 말하기는 어려워 진다. 예를 들어, 아래 코드로 두 개의 정사각형 영역(`w1`과 `w2`)을 생성하는 예시를 보여준다(그림 11.1).

```{r}
#| eval: false
w1 <- st_bbox(c(xmin = 0, ymin = 0, xmax = 1, ymax = 1)) |> 
        st_as_sfc() 
w2 <- st_sfc(st_point(c(1, 0.5))) |> st_buffer(1.2)
```

![관찰 윈도우(회색)에 따라 동일한 포인트 패턴이 공간적으로 완전히 무작위로 나타날 수도 있고(왼쪽), 군집을 이루고 있는 것으로 나타날 수도 있다(오른쪽).](https://r-spatial.org/book/11-PointPattern_files/figure-html/fig-pp1-1.png){#fig-11-1}

**spatstat** 패키지는 포인트 패턴을 `ppp` 클라스의 객체로 저장한다. 모든 `ppp` 객체는 포인트의 위치 정보와 관측 윈도우(`owin` 클라스의 객체)를 함께 가진다. 다음 예시는 포인트 데이터를 이용해 `ppp` 객체를 생성하는 방법을 보여준다.

```{r}
#| eval: false
library(spatstat) |> suppressPackageStartupMessages()
as.ppp(xy)
# Planar point pattern: 30 points
# window: rectangle = [0.009, 0.999] x [0.103, 0.996] units
```

여기서 관측 윈도우를 별도로 지정되지 않으면, 포인트들의 바운딩 박스가 자동으로 관측 윈도우로 설정된다. 데이터셋의 첫 번째 피처로 폴리곤 지오메트리를 추가하면, 해당 폴리곤이 관측 윈도우로 사용된다.

```{r}
#| eval: false
(pp1 <- c(w1, st_geometry(xy)) |> as.ppp())
# Planar point pattern: 30 points
# window: polygonal boundary
# enclosing rectangle: [0, 1] x [0, 1] units
c1 <- st_buffer(st_centroid(w2), 1.2)
(pp2 <- c(c1, st_geometry(xy)) |> as.ppp())
# Planar point pattern: 30 points
# window: polygonal boundary
# enclosing rectangle: [-0.2, 2.2] x [-0.7, 1.7] units
```

포인트 패턴의 등질성(homogeneity)을 검정하기 위해, 적절한 방격 레이아웃을 설정할 수 있다.(역자주: 포인트 패턴의 등질성은 기대 밀도가 모든 지점에서 동일한지를 의미한다.) 예를 들어, 그림 11.2에는 3x3 레이아웃이 나타나 있다. 이를 사용하여 방격 빈도(quadrat count), 즉 방격별 포인트 수를 구할 수 있다.

```{r}
#| eval: false
par(mfrow = c(1, 2), mar = rep(0, 4))
q1 <- quadratcount(pp1, nx=3, ny=3)
q2 <- quadratcount(pp2, nx=3, ny=3)
plot(q1, main = "")
plot(xy, add = TRUE)
plot(q2, main = "")
plot(xy, add = TRUE)
```

![두 포인트 패턴의 3x3 방격 빈도](https://r-spatial.org/book/11-PointPattern_files/figure-html/fig-quadrat-1.png){#fig-11-2}

이 방격 빈도 정보를 이용하여 다음과 같이 $\chi^2$ 검정을 수행한다.

```{r}
#| eval: false
quadrat.test(pp1, nx=3, ny=3)
# Warning: Some expected counts are small; chi^2 approximation may be
# inaccurate
# 
#   Chi-squared test of CSR using quadrat counts
# 
# data:  pp1
# X2 = 8, df = 8, p-value = 0.9
# alternative hypothesis: two.sided
# 
# Quadrats: 9 tiles (irregular windows)
quadrat.test(pp2, nx=3, ny=3)
# Warning: Some expected counts are small; chi^2 approximation may be
# inaccurate
# 
#   Chi-squared test of CSR using quadrat counts
# 
# data:  pp2
# X2 = 43, df = 8, p-value = 2e-06
# alternative hypothesis: two.sided
# 
# Quadrats: 9 tiles (irregular windows)
```

이는 두 번째 사례가 CSR(완전공간무작위성) 패턴이 아님을 시사한다. 경고 메시지에 언급된 대로 기대빈도가 너무 작으므로 유의 확률(p-값)의 해석에는 각별한 주의가 필요하다.

`density()` 함수를 사용하면 커널 밀도를 계산할 수 있으며, 커널의 형태와 탐색 반경을 조정할 수 있다. 탐색 반경을 결정하는 파라미터 `sigma` 값은 `bw.diggle()` 함수의 교차검증을 통해 지정되며, 그림 11.3에 이렇게 생성된 밀도면이 나타나 있다.

```{r}
#| eval: false
den1 <- density(pp1, sigma = bw.diggle)
den2 <- density(pp2, sigma = bw.diggle)
```

![두 포인트 패턴에 대한 커널 밀도면](https://r-spatial.org/book/11-PointPattern_files/figure-html/fig-bwdiggle-1.png){#fig-11-3}

이러한 방식으로 생성된 밀도 지도는 본질적으로 래스터 이미지이므로, 이를 `stars` 객체로 변환할 수 있다.

```{r}
#| eval: false
library(stars)
# Loading required package: abind
s1 <- st_as_stars(den1)
(s2 <- st_as_stars(den2))
# stars object with 2 dimensions and 1 attribute
# attribute(s):
#        Min.  1st Qu. Median Mean 3rd Qu. Max. NA's
# v  6.28e-15 0.000153  0.304 6.77    13.1 42.7 3492
# dimension(s):
#   from  to offset   delta x/y
# x    1 128   -0.2  0.0187 [x]
# y    1 128    1.7 -0.0187 [y]
```

밀도면 하부 체적을 계산하면, 다음 코드에서 확인할 수 있듯이 표본 크기(30)와 유사한 값을 얻을 수 있다.(역자주: 여기서 '밀도면 하부 체적'이란 각 셀별로 면적과 밀도값을 곱하여 셀 체적을 구하고 모든 셀에 대한 이 체적값을 합한 값을 의미한다.)

```{r}
#| eval: false
s1$a <- st_area(s1) |> suppressMessages()
s2$a <- st_area(s2) |> suppressMessages()
with(s1, sum(v * a, na.rm = TRUE))
# [1] 29
with(s2, sum(v * a, na.rm = TRUE))
# [1] 30.7
```

여기에 밀도면을 외부 변수의 함수로 나타내는 모형화를 적용하면 더 흥미로운 결과를 얻을 수 있다. 예를 들어, `pp2`의 밀도를 푸아송 포인트 패턴 프로세스로 모형화한다고 가정해 보자(즉, 포인트 간에 상호작용이 없다고 가정). 이때 밀도의 변화는 '클러스터' 중심으로부터의 거리의 함수로 설명되며, 해당 거리값은 `stars` 객체에 포함되어 있다.

```{r}
#| eval: false
pt <- st_sfc(st_point(c(0.5, 0.5)))
st_as_sf(s2, as_points = TRUE, na.rm = FALSE) |>
  st_distance(pt) -> s2$dist
```

그런 다음 `ppm()` 함수를 사용하여 밀도를 모형화할 수 있으며, `formula`의 왼쪽에는 포인트 패턴 객체의 *이름*이 위치한다.

```{r}
#| eval: false
(m <- ppm(pp2 ~ dist, data = list(dist = as.im(s2["dist"]))))
# Nonstationary Poisson process
# Fitted to point pattern dataset 'pp2'
# 
# Log intensity:  ~dist
# 
# Fitted trend coefficients:
# (Intercept)        dist 
#        4.54       -4.24 
# 
#             Estimate  S.E. CI95.lo CI95.hi Ztest  Zval
# (Intercept)     4.54 0.341    3.87    5.21   *** 13.32
# dist           -4.24 0.700   -5.62   -2.87   *** -6.06
```

반환된 객체는 `ppm` 클래스이며, 이를 플로팅할 수 있다. 그림 11.4는 예측된 밀도면을 보여주며, 예측 표준오차 역시 플로팅할 수 있다.

![ppm 모형에 기반한 예측 밀도면](https://r-spatial.org/book/11-PointPattern_files/figure-html/fig-ppm-1.png){#fig-11-4}

모형에는 예측 메서드도 있어, 이를 통해 `im` 객체를 반환하며, 이 객체는 다음과 같이 `stars` 객체로 전환될 수 있다.

```{r}
#| eval: false
predict(m, covariates = list(dist = as.im(s2["dist"]))) |>
    st_as_stars()
# stars object with 2 dimensions and 1 attribute
# attribute(s):
#      Min. 1st Qu. Median Mean 3rd Qu. Max. NA's
# v  0.0698   0.529   2.13 6.62     7.3 89.7 3492
# dimension(s):
#   from  to offset   delta x/y
# x    1 128   -0.2  0.0187 [x]
# y    1 128    1.7 -0.0188 [y]
```

## CRS

**spatstat** 패키지의 모든 루틴은 데카르트 좌표계를 사용하는 2차원 데이터에 맞게 설계되어 있다. 따라서 타원 좌표계(위도, 경도)를 가진 객체를 변환하려고 시도하면 오류가 발생한다.

```{r}
#| eval: false
system.file("gpkg/nc.gpkg", package = "sf") |> 
    read_sf() |>
    st_geometry() |>
    st_centroid() |>
    as.ppp()
# Error: Only projected coordinates may be converted to spatstat
# class objects
```

**spatstat** 패키지의 데이터 구조로 변환되면, 원래의 CRS(좌표참조계) 정보가 손실된다. 이를 다시 `sf` 또는 `stars` 객체로 복원하려면 `st_set_crs()` 함수를 사용해야 된다.

## 마크 포인트 패턴과 선형 네트워크 상의 포인트

**spatstat** 패키지에서는 몇 가지 확장된 데이터 유형을 상호 변환할 수 있다. 마크(marked) 포인트 패턴은 각 포인트에 범주형 레이블 또는 숫자형 레이블이 '부여된' 포인트 패턴을 말한다. 예를 들어, **spatstat** 패키지에 포함된 `longleaf` 소나무 데이터셋은 가슴 높이에서 측정한 나무 직경 값을 숫자형 마크로 포함하고 있다.

```{r}
#| eval: false
longleaf
# Marked planar point pattern: 584 points
# marks are numeric, of storage type  'double'
# window: rectangle = [0, 200] x [0, 200] metres
ll <- st_as_sf(longleaf)
print(ll, n = 3)
# Simple feature collection with 585 features and 2 fields
# Geometry type: GEOMETRY
# Dimension:     XY
# Bounding box:  xmin: 0 ymin: 0 xmax: 200 ymax: 200
# CRS:           NA
# First 3 features:
#    spatstat.geom..marks.x.  label                           geom
# NA                      NA window POLYGON ((0 0, 200 0, 200 2...
# 1                     32.9  point                POINT (200 8.8)
# 2                     53.5  point                 POINT (199 10)
```

해당 값은 다음과 같이 `ppp` 객체로 다시 변환할 수 있다.

```{r}
#| eval: false
as.ppp(ll)
# Warning in as.ppp.sf(ll): only first attribute column is used for
# marks
# Marked planar point pattern: 584 points
# marks are numeric, of storage type  'double'
# window: polygonal boundary
# enclosing rectangle: [0, 200] x [0, 200] units
```

**spatstat** 패키지의 `psp` 클래스에 속하는 선분은 `LINESTRING` 지오메트리를 가진 `sf` 피처로 상호 변환할 수 있으며, 관측 윈도우를 나타내는 `POLYGON` 피처가 하나 포함된다.

```{r}
#| eval: false
print(st_as_sf(copper$SouthLines), n = 5)
# Simple feature collection with 91 features and 1 field
# Geometry type: GEOMETRY
# Dimension:     XY
# Bounding box:  xmin: -0.335 ymin: 0.19 xmax: 35 ymax: 158
# CRS:           NA
# First 5 features:
#     label                           geom
# 1  window POLYGON ((-0.335 0.19, 35 0...
# 2 segment LINESTRING (3.36 0.19, 10.4...
# 3 segment LINESTRING (12.5 0.263, 11....
# 4 segment LINESTRING (11.2 0.197, -0....
# 5 segment LINESTRING (6.35 12.8, 16.5...
```

마지막으로, 선형 네트워크상의 포인트 패턴은 **spatstat** 패키지에서 `lpp` 객체로 표현되며, 다음과 같이 `sf` 객체로 변환할 수 있다.

```{r}
#| eval: false
print(st_as_sf(chicago), n = 5)
# Simple feature collection with 620 features and 4 fields
# Geometry type: GEOMETRY
# Dimension:     XY
# Bounding box:  xmin: 0.389 ymin: 153 xmax: 1280 ymax: 1280
# CRS:           NA
# First 5 features:
#     label seg tp marks                           geom
# 1  window  NA NA  <NA> POLYGON ((0.389 153, 1282 1...
# 2 segment  NA NA  <NA> LINESTRING (0.389 1254, 110...
# 3 segment  NA NA  <NA> LINESTRING (110 1252, 111 1...
# 4 segment  NA NA  <NA> LINESTRING (110 1252, 198 1...
# 5 segment  NA NA  <NA> LINESTRING (198 1277, 198 1...
```

여기서는 처음 다섯 개 피처만 표시되어 있어 쉽게 눈에 띄지는 않지만, `label` 변수를 보면 포인트들도 이 객체에 포함되어 있음을 알 수 있다.

```{r}
#| eval: false
table(st_as_sf(chicago)$label)
# 
#   point segment  window 
#     116     503       1
```

네트워크의 *구조*에 관한 정보, 즉 `LINESTRING` 지오메트리가 어떻게 연결되어 있는지는 `sf` 객체에 포함되지 않는다.() 이런 측면에서 **sfnetworks** 패키지(van der Meer et al. 2022)는 좋은 대안이 될 수 있다. 이 패키지는 네트워크 위상 정보를 다룰 수 있을 뿐 아니라 OpenStreetMap에서 불러온 네트워크 데이터를 **spatstat** 패키지로 전달하는 기능도 제공한.

## 공간 샘플링과 포인트 프로세스를 시뮬레이션하기

**sf** 패키지에는 `MULTIPOINT`, 선형, 또는 폴리곤 지오메트리에서 포인트를 샘플링하는 `st_sample()` 메서드가 있으며, 여러 가지 공간 샘플링 전략을 지원한다. 기본적으로 'random', 'hexagonal', 'Fibonacci'(11.5절 참고), 'regular' 옵션을 제공한다. 'regular'는 정사각형 격자에서의 샘플링을, 'hexagonal'은 사실상 삼각형 격자에 해당하는 샘플링을 의미한다. 'random' 유형만 요청한 포인트 수를 정확히 반환하며, 다른 유형은 근사값을 반환한다.

`st_sample()` 함수는 샘플링 유형에 다른 값을 지정할 경우, **spatstat** 패키지의 포인트 프로세스 시뮬레이션 함수와도 연동된다. 예를 들어, `type = Thomas`로 설정하면 **spatstat** 패키지의 `rThomas()` 함수가 호출된다(그림 11.5).

```{r}
#| eval: false
kappa <- 30 / st_area(w2) # intensity
th <- st_sample(w2, kappa = kappa, mu = 3, scale = 0.05, 
    type = "Thomas")
nrow(th)
# [1] 90
```

![mu =3, scale = 0.05로 설정한 Thomas 프로세스](https://r-spatial.org/book/11-PointPattern_files/figure-html/fig-rThomas-1.png){#fig-11-5}

`?rThomas`를 실행하면 함수 `rThomas()`의 매개변수 `kappa`, `mu`, `scale`의 의미를 자세히 확인할 수 있다. 포인트 프로세스 시뮬레이션에서는 표본 크기를 지정하는 대신 강도를 지정한다. 이때 관측 윈도우 내에서 실제로 생성되는 표본 크기는 확률변수가 된다.

## 구체 상의 포인트를 시뮬레이션하기

**sf** 패키지에서 기본적으로 제공하는 또 다른 공간 무작위 샘플링 유형은 구면에서의 무작위 포인트 시뮬레이션이다. 그림 11.6은 그 한 예시로, 생성된 포인트들이 모두 해양에 위치해 있다. 구면에서 규칙적인 포인트 패턴을 시뮬레이션하려면 `st_sample()` 함수의 `type` 아규먼트를 `"Fibonacci"`로 지정하면 된다(González 2010).

![구면에서 해양부에만 제한된 샘플 포인트: 무작위 패턴(왼쪽)과 규칙 패턴(오른쪽)이 정사 도법 지도에 표시되어 있다.](https://r-spatial.org/book/11-PointPattern_files/figure-html/fig-srsglobe-1.png){#fig-11-6}

## 연습문제

1.  **spatstat** 패키지에서 `plot(longleaf)`로 생성되는 플롯과 동일한 결과를 **ggplot2** 패키지의 `geom_sf()` 함수 및 `sf::plot()` 함수를 사용하여 구현하시오.

2.  12장에서 사용된 NO$_2$ 데이터의 표본 위치를 적절한 관측 윈도우와 함께 `ppp` 객체로 변환하시오.

3.  NO$_2$ 데이터셋을 사용하여 밀도를 계산하고, 밀도면을 플로팅하시오. 이어서 밀도면을 `stars` 객체로 변환하고, 표면 하부 체적을 계산하시오.
