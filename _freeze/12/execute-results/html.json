{
  "hash": "72adb930155a09d70e49e684249ffee4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\n---\n\n\n# 공간적 인터폴레이션 {#sec-interpolation}\n\n공간적 인터폴레이션은 관측된 위치를 바탕으로 관측되지 않은 공간 위치에서 공간적으로 연속적인 변수(필드)의 값을 추정하는 활동이다. 공간적 인터폴레이션을 위한 통계적 방법론을 지구통계학(geostatistics)이라고 부르며, 공간적으로 연속적인 현상의 모델링, 예측, 시뮬레이션에 중점을 둔다. 공간적 인터폴레이션의 전형적인 상황은 결측값 문제이다. 즉, 한정된 샘플 위치 $s_i,i=1,...,n$ 에서 특정 현상의 속성 $Z(s)$가 관측되었다고 했을 때, 이를 바탕으로 연구 지역 내의 모든 위치 $s_0$에서 해당 속성 값을 알아내고자 한다. 결국 관측되지 않은 위치에 대해 속성값을 예측해야 하는 상황이다. 이러한 과정을 크리깅(kriging) 또는 가우시안 프로세스 예측(Gaussian Process prediction)이라고도 부른다. $Z(s)$에 화이트 노이즈 성분인 $\\epsilon$가 포함된 경우 $Z(s)=S(s)+\\epsilon$ (측정 에러 포함)로 주어질 수 있는데, 이 경우 $Z(s)$ 대신 $S(s)$를 예측하거나 시뮬레이션하는 것이 대안적 목표가 될 수 있다. 이것을 보통 *공간 필터링*(spatial filtering) 또는 *평활화*(smoothing)라고 부른다.\n\n이 장에서는 지구통계학적 데이터를 다루는 간단한 접근법, 간단한 인터폴레이션 기법, 그리고 공간적 자기상관, 공간 예측 및 시뮬레이션 모델링에 대해 다룬다. 13장에서는 다변량 및 시공간 지구통계하적 모델과 같은 보다 더 복잡한 모델에 중점을 둔다. 우리는 **gstat** 패키지(Pebesma and Graeler 2022; Pebesma 2004)를 주로 사용하게 되는데, 이 패키지는 비교적 다양한 비베이지안 지구통계적 분석 모델과 옵션을 제공하는 사용한다. R로 구현된 베이지안 방법은 Diggle, Tawn, and Moyeed (1998), Diggle and Ribeiro Jr. (2007), Blangiardo and Cameletti (2015), Wikle, Zammit-Mangion, and Cressie (2019)에서 찾을 수 있다. 대용량 데이터셋에 활용되는 기법의 개요와 비교는 Heaton et al. (2018)에서 제공된다.\n\n## 첫 번째 데이터셋\n\n**gstat** 패키지에 포함되어 있는 평균 NO₂ 데이터셋을 읽어 들인다. 이것은 13장에서 준비된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) |> suppressPackageStartupMessages()\nno2 <- read_csv(system.file(\"external/no2.csv\", \n    package = \"gstat\"), show_col_types = FALSE)\n```\n:::\n\n\n이 데이터셋에 UTM 투영을 적용하여 `sf` 객체로 전환한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\ncrs <- st_crs(\"EPSG:32632\")\nst_as_sf(no2, crs = \"OGC:CRS84\", coords = \n    c(\"station_longitude_deg\", \"station_latitude_deg\")) |>\n    st_transform(crs) -> no2.sf\n```\n:::\n\n\n그리고 나서, 국가 행정 경계를 불러 들이고, `ggplot` 패키지를 이용해 지도를 그린다(그림 12.1)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_sf(\"data/de_nuts1.gpkg\") |> st_transform(crs) -> de\n```\n:::\n\n\n![독일의 농촌 지역 관측소들에 높은 평균 NO$_2$ 값이 집중해 있다.](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-plotDE-1.png){#fig-12-1}\n\n이 데이터를 바탕으로 공간적 인터폴레이션을 수행하려면 먼저 인터폴레이션을 할 위치를 결정해야 한다. 이는 보통 연구 대상 지역 전체를 덮는 규칙적 그리드를 사용하여 수행된다. 객체 `de`의 국가 윤곽에 맞추어 독일 전역을 커버하는 10 km × 10 km의 규칙적 그리드를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stars) |> suppressPackageStartupMessages()\nst_bbox(de) |>\n  st_as_stars(dx = 10000) |>\n  st_crop(de) -> grd\ngrd\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#         Min. 1st Qu. Median Mean 3rd Qu. Max. NA's\n# values     0       0      0    0       0    0 2076\n# dimension(s):\n#   from to  offset  delta            refsys x/y\n# x    1 65  280741  10000 WGS 84 / UTM z... [x]\n# y    1 87 6101239 -10000 WGS 84 / UTM z... [y]\n```\n:::\n\n\n그리드 셀의 크기를 너무 세밀하게 하지 않은 것은 플롯 상에서 눈으로 확인해 보려는 의도이다.\n\n가장 간단한 공간적 인터폴레이션 기법은 역거리 가중법(inverse distance weighted)일 것이다. 인터폴레이션이 적용되는 지점으로부터의 거리의 역비례에 따라 가중치를 부여하여 가중 평균을 산출하는 기법이다.\n\n$$\n\\hat{z}(s_0)=\\frac{\\sum^n_{i=1} w_iz(s_i)}{\\sum^n_{i=1}w_i}\n$$\n\n여기서 $w_i=|s_0-s_i|^{-p}$으로 주어진다. 역거리를 위한 지수($p$)는 보통 2가 사용되는데, 교차 검증을 통해 최적화할 수도 있다. **gstat** 패키지의 `idw` 함수를 활용하면 역거리 가중 인터폴레이션을 수행할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gstat)\ni <- idw(NO2~1, no2.sf, grd)\n# [inverse distance weighted interpolation]\n```\n:::\n\n\n결과는 그림 12.2에 나타나 있다.\n\n![독일 NO$_2$ 집중도에 대한 역거리 가중 인터폴레이션의 결과](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-idw-1.png){#fig-12-2}\n\n## 샘플 베리오그램\n\n지구통계학적 방법을 사용하여 공간 예측을 수행하려면 먼저 평균과 공간적 자기상관을 위한 모델을 수립해야 한다. 가장 단순한 모델은 $Z(s)=m+e(s)$로 주어질 수 있는데, 평균은 알려지지 않은 고정값 $m$이고 공간적 자기상관은 $\\gamma (h)=0.5E(Z(s)-Z(s+h))^2$의 형태로 주어지는 베리오그램(variogram)을 통해 모델화된다. 유한 분산 $C(0)$를 가진 프로세스의 경우는 $\\gamma (h)=C(0)-C(h)$가 성립하는데, 이는 베리오그램이 코베리오그램(covariogram) 또는 공분산 함수(covariance function)와 관련되어 있음을 보여준다.\n\n샘플 베리오그램은 거리 인터벌 $h_i=[h_{i,0},h_{i,1}]$별 $\\gamma(h)$에 대한 추정값을 계산함으로써 획득된다.\n\n$$\n\\hat{\\gamma}(h_i)=\\frac{1}{2N(h_i)}\\sum^{N(h_i)}_{j=1}(z(s_i)-z(s_i+h'))^2,\\quad h_{i,0}\\le h' \\lt h_{i,1}\n$$\n\n여기에서 $N(h_i)$는 거리 구간 $h_i$에 해당하는 모든 샘플 쌍의 개수를 의미한다(역자주: 샘플 쌍의 거리가 해당 거리 구간 내에 포함되는 모든 샘플 쌍의 개수). **gstat** 패키지의 `variogram` 함수를 통해 샘플 베리오그램을 계산할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- variogram(NO2~1, no2.sf)\n```\n:::\n\n\n그림 12.3은 베리오그램의 결과를 플롯으로 나타낸 것이다.\n\n![샘플 베리오그램 플롯](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-vgm-1.png){#fig-12-3}\n\n`variogram` 함수는 내장된 디폴트 값을 최대 거리(`cutoff`: 경계 상자의 대각선 길이의 삼분의 일)와 (상수) 구간 너비(`width`: `cutoff`를 15로 나눈 값)에 적용하는데. 디폴트 값은 다음을 통해 변경할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv0 <- variogram(NO2~1, no2.sf, cutoff = 100000, width = 10000)\n```\n:::\n\n\n새로운 값의 결과는 그림 12.4에 나타나 있다.\n\n![디폴트 값을 조정해 생성된 샘플 베리오그램](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-vgm2-1.png){#fig-12-4}\n\n공식 NO₂ \\~ 1은 데이터 파일(NO₂)에서 관심 변수를 선택하고 평균 모델을 지정하는 데 사용된다. 여기서 \\~1은 절편만 있는(알려지지 않은 고정 평균) 모델을 지정한다.\n\n## 베리오그램 모델 적합\n\n공간 예측을 진행하기 위해서는 위에서 도출한 거리 구간별 추정값이 아니라 이론적으로 모든 거리 $h$에 적용될 수 있는 베리오그램 *모델* $\\gamma(h)$가 필요하다. 위의 구간별 추정값을 하나의 직선으로 연결하거나 구간별 추정값을 해당 구간에 대한 고정값이라고 가정하게 되면 문제가 발생한다. 즉, 이것은 비양수 정의 공분산 행렬(non-positive definite covariance matrices)을 갖는 통계 모델을 전제하는 것이 되고, 이것을 예측에 사용하는 것은 불가능한다.\n\n이를 피하기 위해 우리는 파라메트릭 모델 $\\gamma (h)$를 적합하여 추정값 $\\hat{\\gamma} (h)$를 구한다. 여기서 $\\hat{\\gamma} (h)$는 $\\gamma (h)$를 추정하는 데 관여한 모든 $h'$ 값의 평균값으로 설정한다. 예를 들어, 다음과 같은 지수 베리오그램 모델을 적합할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv.m <- fit.variogram(v, vgm(1, \"Exp\", 50000, 1))\n```\n:::\n\n\n결과는 그림 12.5에 나타나 있다.\n\n![샘플 베리오그램(가운데가 비어 있는 점) 상에 가중 최소 제곱법(실선) 및 최대 우도 추정법(점선)을 사용하여 적합한 모델이 표시되어 있다.](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-fitvariogrammodel-1.png){#fig-12-5}\n\n라인의 적합에 다음을 최소화하는 가중 최소 제곱법이 적용되었다.\n\n$$\n\\sum^n_{i=1}w_i(\\gamma (h_i)-\\hat{\\gamma}(h_i))^2,\n$$\n\n여기에서 가중치의 디폴트값은 $N(h_i)/h^2$으로 주어진다. `fit.method` 아규먼트를 통해 다른 가중치 옵션을 선택할 수 있다.\n\n가중 최소 제곱법 적합의 대안으로 최대 우도(ML) 또는 제한 최대 우도(parameter estimation) 모수 추정법을 사용할 수 있으며(Kitanidis and Lane 1985), 이 사례에서는 그림 12.5에서 점선으로 나타난 것처럼 비교적 유사한 적합 모델이 도출되었다. ML 유형 접근법의 장점은 방정식 12.1에서 거리 구간 $h_i$나 방정식 12.2에서 가중치 $w_i$를 선택할 필요가 없다는 것이다. 단점으로는 데이터가 다변량 정규 분포를 보인다는 강한 가정에 기반하고 있고, 더 큰 데이터셋의 경우 관측 수만큼의 선형 시스템을 반복적으로 풀어야 한다는 점 등이 있다. Heaton et al. (2018)은 대규모 데이터셋에 모델을 적합하는 데 특화된 접근법을 비교한다.\n\n## 크리깅 인터폴레이션\n\n일반적으로 인터폴레이션은 연구 대상 지역을 덮는 규칙적인 그리드 상의 지점들을 대상으로 이루어진다. 먼저 해당 지역을 커버하면서 그 외부는 `NA`로 채워진 래스터(`stars` 객체)를 생성한다.\n\n크리깅은 연구 대상 지역 내의 임의의 지점 $Z(s_0)$에 대한 속성값을 예측한다. **gstat** 패키지의 `krige` 함수를 통해 NO₂를 크리깅할 수 있으며, 이때 경향면 모델, 데이터, 예측 그리드, 베리오그램 모델을 아규먼트로 전달한다(그림 12.6).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- krige(NO2~1, no2.sf, grd, v.m)\n# [using ordinary kriging]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + geom_stars(data = k, aes(fill = var1.pred, x = x, y = y)) + \n    xlab(NULL) + ylab(NULL) +\n    geom_sf(data = st_cast(de, \"MULTILINESTRING\")) + \n    geom_sf(data = no2.sf) +\n    coord_sf(lims_method = \"geometry_bbox\")\n```\n:::\n\n\n![독일 NO$_2$ 집중도에 대한 크리깅의 결과](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-krigeovergermany-1.png){#fig-12-6}\n\n## 에어리어 평균: 블록 크리깅\n\n에어리어 평균을 계산하는 방법은 여러 가지가 있다. 가장 간단한 방법은 대상 폴리곤 내부에 포함된 포인트 샘플의 평균을 취하는 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- aggregate(no2.sf[\"NO2\"], by = de, FUN = mean)\n```\n:::\n\n\n더 복잡한 방법으로는 블록 크리깅(block kriging, Journel and Huijbregts 1978)이 있는데, 타깃 지역의 평균값을 추정하기 위해 모든 데이터를 활용한다. `krige` 함수에서 `newdata` 인수에 타깃 지역(폴리곤)을 전달하여 이를 수행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- krige(NO2~1, no2.sf, de, v.m)\n# [using ordinary kriging]\n```\n:::\n\n\n두 지도를 하나의 객체로 병합하여 단일 플롯을 생성한다(그림 12.7).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb$sample <- a$NO2\nb$kriging <- b$var1.pred\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nb |> select(sample, kriging) |> \n        pivot_longer(1:2, names_to = \"var\", values_to = \"NO2\") -> b2\nb2$var <- factor(b2$var, levels = c(\"sample\", \"kriging\"))\nggplot() + geom_sf(data = b2, mapping = aes(fill = NO2)) + facet_wrap(~var) +\n     scale_fill_gradientn(colors = sf.colors(20))\n```\n:::\n\n\n![단순 평균계산(왼쪽)과 블록 크리깅(오른쪽)을 통해 계산된 NO$_2$의 집계값](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-aggregations-1.png){#fig-12-7}\n\n패턴은 유사하지만, 단순 평균계산을 통한 샘플 평균이 블록 크리깅의 값보다 변동성이 더 크다는 것을 알 수 있다. 이는 크리깅의 평활화 효과 때문일 수 있는데, 집계 영역 외부의 데이터 포인트에도 가중치가 부여되기 때문이다.\n\n표준 오차에 대한 대략적인 추정치는 $\\sqrt{(\\sigma^2 /n)}$를 통해 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSE <- function(x) sqrt(var(x)/length(x))\na <- aggregate(no2.sf[\"NO2\"], de, SE)\n```\n:::\n\n\n샘플이 공간적으로 무작위 표본 추출을 통해 얻어진 경우, 디자인-기반 추론(10.4절)에서 실제 추정치가 이와 같았을 것이다. 블록 크리깅 분산은 모델-기반 추정치로, 크리깅의 부산물로 계산된다. 그림 12.8에서 두 값을 비교해 보면, 단순 평균계산 접근법이 블록 크리깅에 비해 구역 평균의 예측 오차가 더 큰 변동성을 보일 뿐만 아니라 값도 더 크다는 것을 확인할 수 있다.\n\n![단순 평균계산법(왼쪽)과 블록 크리깅(오른쪽)을 통해 획득된 평균 NO$_2$의 표준 오차](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-aggrSE-1.png){#fig-12-8}\n\n## 조건부 시뮬레이션\n\n필드 $Z(s)$의 조건부 평균이 아닌 하나 혹은 여러개의 조건부 실현이 필요할 경우, 조건부 시뮬레이션을 활용할 수 있다. 조건부 실현이 필요한 경우는 비선형 함수인 $g(\\cdot)$을 통해 $Z(s)$의 구역 평균 값, 즉 $g(Z(s))$를 추정해야 하는 상황이 해당된다. 간단한 예로는 $Z(s)$가 특정 임계값을 초과하는 지역이 존재하는 경우이다.\n\n`gstat` 패키지의 기본 접근 방식은 이를 위해 순차 시뮬레이션 알고리즘을 사용하는 것이다. 이 알고리즘은 예측이 이루어지는 위치들을 무작위로 순회하며 각 위치에서 다음과 같은 작업을 수행한다.\n\n-   크리깅 예측을 수행한다.\n\n-   크리깅 분산과 동일한 평균과 분산을 가진 정규 분포에서 난수를 생성한다.\n\n-   이 값을 조건부 데이터셋에 추가한다.\n\n-   새로운 무작위 시뮬레이션 위치를 찾는다.\n\n이것을 모든 위치에 반복 수행한다.\n\n`gstat` 패키지의 `krige` 함수가 이를 수행하며 `nsim` 아규먼트는 양수로 설정된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(13341)\n(s <- krige(NO2~1, no2.sf, grd, v.m, nmax = 30, nsim = 6))\n# drawing 6 GLS realisations of beta...\n# [using conditional Gaussian simulation]\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#       Min. 1st Qu. Median Mean 3rd Qu. Max.  NA's\n# var1  -5.7    6.12   8.68 8.88    11.5 23.9 12456\n# dimension(s):\n#        from to  offset  delta            refsys        values x/y\n# x         1 65  280741  10000 WGS 84 / UTM z...          NULL [x]\n# y         1 87 6101239 -10000 WGS 84 / UTM z...          NULL [y]\n# sample    1  6      NA     NA                NA sim1,...,sim6\n```\n:::\n\n\n`set.seed()`를 설정한 것은 시뮬레이션 결과가 달라지지 않도록 하기 위해서이다.\n\n`nmax` 아규먼트의 설정을 통해 크리깅 추정 시 포함할 최근접 이웃의 (최대) 개수를 제한하는 것이 필요하다. 왜냐하면 단계가 진해되면서 데이터셋이 계속 증가하기 때문에 계산 시간이 길어지고 메모리 요구량이 커지기 때문이다. 조건부 시뮬레이션의 결과가 그림 12.9에 나타나 있다.\n\n![NO2에 대한 6가지의 조건부 시뮬레이션 결과](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-plotkrigingvalues-1.png){#fig-12-9}\n\n`gstat` 패키지에는 최근 조건부 시뮬레이션의 대체 기법이 추가되었으며, 원형 임베딩(circular embedding) 기법을 구현한 `krigeSimCE`(Davies와 Bryant, 2013)와 터닝 밴드(turning band) 기법을 구현한 `krigeSTSimTB`(Schlather, 2011)가 있다. 이러한 기법들은 대규모 데이터셋이나 시공간 데이터셋의 조건부 시뮬레이션에 유용하다.\n\n## 경향면 모델\n\n이 장에서 사용된 크리깅과 조건부 시뮬레이션은 모든 공간 변동성이 공간 공분산 모델로 특징지어지는 무작위 과정이라고 가정한다. 만약 타깃 변수와 의미 있게 상관된 다른 변수가 있는 경우, 이러한 변수를 경향면을 위한 선형 회귀 모델에 사용할 수 있다.\n\n$$\nZ(s)=\\sum^p_{j=0} \\beta_jX_j(s)+e(s)\n$$\n\n여기서 $X_0(s)=1$, $\\beta_0$는 절편, $\\beta_j$는 변수에 대한 회귀계수이다. 변수를 추가하면 보통 잔차 $e(s)$의 공간적 자기상관과 분산이 모두 감소하여, 더 정확한 예측과 유사한 조건부 시뮬레이션 결과를 얻을 수 있다. NO$_2$의 변동에 대해 인구 밀도 변수를 사용하는 예를 살펴볼 것이다.\n\n### 인구 밀도 그리드\n\n대기의 NO$_2$에 대한 예측 변수로 인구 밀도를 사용한다. NO$_2$는 주로 교통에 의해 발생하며, 교통은 인구 밀도가 높은 지역에서 더 집중된다. 인구 밀도는 2011년 인구 조사에서 얻어진 데이터로, 100m × 100m 그리드 셀당 거주자 수가 CSV 파일에 포함되어 있다. 우리는 이 데이터를 타깃 그리드 셀에 맞춰 합산함으로써 새로운 집계 데이터를 생성할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- vroom::vroom(\"aq/pop/Zensus_Bevoelkerung_100m-Gitter.csv\")\nv |> filter(Einwohner > 0) |> \n    select(-Gitter_ID_100m) |>\n    st_as_sf(coords = c(\"x_mp_100m\", \"y_mp_100m\"), crs = 3035) |>\n    st_transform(st_crs(grd)) -> b\na <- aggregate(b, st_as_sf(grd, na.rm = FALSE), sum)\n```\n:::\n\n\n위의 코드를 통해 집계된 타깃 그리드 셀의 인구 수가 `a`에 저장된다. 인구 밀도를 구하기 위해서는 각 셀의 면적이 필요한데, 국경에 걸쳐 있는 그리드 셀의 경우 면적이 10km × 10km보다 작을 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrd$ID <- 1:prod(dim(grd)) # to identify grid cells\nii <- st_intersects(grd[\"ID\"],\n  st_cast(st_union(de), \"MULTILINESTRING\"), as_points = FALSE)\ngrd_sf <- st_as_sf(grd[\"ID\"], na.rm = FALSE)[lengths(ii) > 0,]\nst_agr(grd_sf) = \"identity\"\niii <- st_intersection(grd_sf, st_union(de))\ngrd$area <- st_area(grd)[[1]] + \n    units::set_units(grd$values, m^2)\ngrd$area[iii$ID] <- st_area(iii)\n```\n:::\n\n\n위의 두 단계 과정, 즉 먼저 국경에 걸쳐 있는 셀을 찾고 그 후에 면적을 계산하는 과정을 거치지 말고, 모든 셀에 바로 `st_intersection` 함수를 적용하는 방법도 있겠지만 이는 오퍼레이션 시간이 긴 단점이 있다. 인구 수와 면적을 통해 인구 밀도를 계산하고(그림 12.10), 총계가 맞는지 확인해 본다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrd$pop_dens <- a$Einwohner / grd$area\nsum(grd$pop_dens * grd$area, na.rm = TRUE) # verify\n# 80323301 [1]\nsum(b$Einwohner)\n# [1] 80324282\n```\n:::\n\n\n두 값의 일치도가 상당히 높다는 것을 알 수 있다. `st_interpolate_aw` 함수를 사용했다면 정확히 일치하는 결과를 얻었을 것이다.\n\n![100 m X 100 m 그리드 셀별 인구 밀도 값](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-popdens-1.png){#fig-12-10}\n\n인구 수를 인구 밀도로 전환하기 위해서는 해당 인구 수를 100m × 100m 격자 셀의 수로 나누어야 한다.\n\n모니터링 네트워크 스테이션에서 인구 밀도 값을 얻기 위해 `st_extract` 함수를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrd |>\n  select(\"pop_dens\") |>\n  st_extract(no2.sf) |>\n  pull(\"pop_dens\") |> \n  mutate(no2.sf, pop_dens = _) -> no2.sf\n```\n:::\n\n\n그런 다음 모니터링 스테이션 위치에서 NO$_2$와 인구 밀도 간의 선형 관계를 조사할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(lm(NO2~sqrt(pop_dens), no2.sf))\n# \n# Call:\n# lm(formula = NO2 ~ sqrt(pop_dens), data = no2.sf)\n# \n# Residuals:\n#    Min     1Q Median     3Q    Max \n# -7.990 -2.052 -0.505  1.610  8.095 \n# \n# Coefficients:\n#                Estimate Std. Error t value Pr(>|t|)    \n# (Intercept)       4.537      0.685    6.62  5.5e-09 ***\n# sqrt(pop_dens)  326.154     49.366    6.61  5.8e-09 ***\n# ---\n# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n# \n# Residual standard error: 3.13 on 72 degrees of freedom\n# Multiple R-squared:  0.377,   Adjusted R-squared:  0.369 \n# F-statistic: 43.7 on 1 and 72 DF,  p-value: 5.82e-09\n```\n:::\n\n\n해당 선형 관계는 그림 12.11의 산점도에 나타나 있다.\n\n![농촌 지역 대기질 관측소의 2017년 연평균 NO$_2$ 집중도와 인구 밀도의 산점도](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-no2scat-1.png){#fig-12-11}\n\n이 새로운 모델에서의 예측을 수행하기 위해서는 먼저 잔차 베리오그램을 모델링해야 한다(그림 12.12).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nno2.sf <- no2.sf[!is.na(no2.sf$pop_dens),]\nvr <- variogram(NO2~sqrt(pop_dens), no2.sf)\nvr.m <- fit.variogram(vr, vgm(1, \"Exp\", 50000, 1))\n```\n:::\n\n\n![인구 밀도 경향성을 제거하고 남은 잔차에 대한 베리오그램](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-predictusingpopulationdensity-1.png){#fig-12.12}\n\n그리고 나서 아래의 코드로 크리깅 예측이 이루어진다. 여기서, 중요한 것은 예측 위치에 대해서도 `pop_dens` 값이 계산되어 새로이 생성되는 객체인 `grd` 속에 포함되다는 점이다. 예측 결과는 12.13에 나타나 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkr <- krige(NO2 ~ sqrt(pop_dens), no2.sf, \n            grd[\"pop_dens\"], vr.m)\n# [using universal kriging]\n```\n:::\n\n\n![인구 밀도를 경향성 변수로 사용한 크리깅의 NO$_2$ 예측값](https://r-spatial.org/book/12-Interpolation_files/figure-html/fig-residualkriging-1.png){#fig-12-13}\n\n(오디네리) 크리깅과 비교할 때 몇 가지 뚜렷한 차이를 볼 수 있다. 인구 밀도를 경향면으로 사용한 크리깅의 결과 지도는 측정 스테이션의 극단적인 값이 아니라 인구 밀도의 극단적인 값을 따르는 경향이 있으며, 값의 범위도 오디네리 크리깅의 범위 보다 넓다. 그러나 \"농촌 배경\"의 범주에 속하는 측정 스테이션만 사용되어 인구 밀도가 전체적으로 낮은 특성이 있다는 점에서 해석에 신중을 기할 필요가 있다. 그림 12.11의 산점도의 x-축을 보면 측정 스테이션의 인구 밀도 값이 인구 밀도 지도에 나타나 있는 값의 범위에 비해 훨씬 제한적이라는 사실을 알 수 있으며, 따라서 오른쪽 지도는 그림 12.11에 나타난 관계를 강하게 인터폴레이션한 결과이다.\n\n## 연습문제\n\n1.  그림 12.13과 같은 플롯을 생성하되, 왼쪽에 그림 12.2의 역거리 인터폴레이션 맵을 추가하라.\n\n2.  IDW와 크리깅, 그리고 IDW와 잔차 크리깅 간의 관계를 나타내는 산점도를 생성하라.\n\n3.  그리드 셀을 중심으로 하는 블록 평균을 예측하기 위해 *블록 크리깅*을 수행하되, `krige()` 함수의 `block` 아규먼트를 통해 블록 크기가 10km(그리드 셀 크기), 50km, 200km인 블록 크리깅을 수행하라. 이 세 가지 블록 크기에 대한 추정치의 결과 맵을 포인트 크리깅으로 얻은 맵과 비교하고, 관련된 모든 크리깅 표준 오차에 대해서도 동일하게 수행하라.\n\n4.  위에서 얻은 잔차 크리깅 결과를 기반으로, 크리깅 오차가 정규 분포를 따른다고 가정할 때 95% 신뢰 구간의 하한선과 상한선 맵을 계산하고, 이를 단일(결합) 범례가 있는 플롯에 표시하라.\n\n5.  크리깅 오차에 대한 정규 분포 가정 하에서, NO$_2$의 포인트 값이 15 ppm을 초과할 확률 값을 계산하고 그것을 지도로 표현하라.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}