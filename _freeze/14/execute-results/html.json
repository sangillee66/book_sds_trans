{
  "hash": "b186651ee74e0018e9d2d8351b7eaa78",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n# 근접성과 에어리어 데이터 {#sec-area}\n\n관측 단위가 에어리어 객체인 경우는 매우 흔하다. 이는 연구 대상 전체에서 관측이 동시에 이루어지고, 그 관측값이 비중첩 구역 단위로 집계되는 경우를 말한다. 이러한 구역 단위는 행정구역인 경우가 많다. 물론 통근 흐름처럼 기저 공간 프로세스를 직접적으로 반영하는 경우도 있지만, 대체로 공간 프로세스와 무관하게 임의로 설정된다. 구역 단위와 기저 공간 프로세스 간의 불일치는 동일한 공간 프로세스가 인접한 구역 단위 사이에서 부분적으로 공유됨을 의미하며, 이러한 불일치가 데이터셋의 단 하나의 변수에서라도 발생하면 전반적으로 공간적 자기상관의 문제가 발생할 수 있다. 여기서 근접성(proximity)이란 데이터 생성 프로세스의 관점에서의 *가까움*(closeness)을 의미한다. 포인트 스포트를 사용하는 횡단 지구통계학 분석에서는 측정된 거리가 전형적인 데이터 생성 프로세스에 적합하다. 그러나 에어리어 데이터의 경우, 공유 경계를 사용하는 것이 더 타당할 수 있다. 이는 우리가 확실히 알고 있는 정보이며, 에어리어 간 거리를 이보다 타당하게 측정할 방법은 없기 때문이다.(역자주: 여기서 '타당하다'는 의미는, 공유 경계가 데이터 생성 프로세스에서 근접성을 판단하는 데 있어 가장 신뢰할 수 있는 근거라는 뜻이다. 에어리어 간 거리를 정의하고 계산하는 방법은 여럿 있으나, 모두 어느 정도 임의성이 개입되기 때문에, 공유 경계보다 더 설득력 있고 일관된 방법은 없다.)\n\n데이터의 스포트란 개별 관측 단위(관측 개체)의 물리적 크기(길이, 면적, 부피)를 의미한다(5장 참조). 에어리어 데이터는 기본적으로 폴리곤 스포트를 가지지만, 포인트 서포트를 가지는 것으로 재현할 수도 있다. 예를 들어, 개별 폴리곤의 경우에는 센트로이드를, 멀리폴리곤의 경우에는 가장 큰 폴리곤의 센트로이드를 대표 지점으로 사용할 수 있다. 반대로, 포인트 스포트를 가지는 데이터를 에어리어 데이터로 취급할 수도 있다. 이 경우 포인트를 비중첩 테셀레이션으로 변환해야 하는데, 들로네 삼각망을 통해 보로노이 다이어그램(디리클레 테셀레이션 혹은 티센 폴리곤)을 생성한다. 다른 메트릭을 선택할 수도 있고, 평면이 아닌 네트워크 상의 거리를 사용할 수도 있다. 국지적 공간분석에서는 가중 보로노이 다이어그램이 활용되기도 한다(Boots and Okabe 2007; Okabe et al. 2008; She et al. 2015 참조).\n\n데이터의 원래 스포트가 포인트이지만, 기저 공간 프로세스가 관측 개체 간 거리보다 인접성에 의거해 발생하는 경우, 데이터는 총빈도나 총계(예: 투표소 수, 총매출액)일 수 있으며, 또는 관측 개체의 직접적인 속성(예: 투표소의 개방 시간)일 수도 있다. 이러한 모든 경우에는 기저 공간 프로세스를 잘못 재현할 위험이 항상 존재한다. 특히, 연구 지역 전체를 하나의 테셀레이션 체계로 재현하는 경우, 관측값이 기저 공간 프로세스를 온전히 포착했다고 가정하게 되므로 그 위험은 더욱 커진다. 이러한 측면에서 에어리어 데이터는 지구통계학적 데이터와 다르다. 지구통계학적 데이터는 전체 지역에 대해 일정한 방식의 표본추출이 적용되었다는 것을 전제로 하지만, 에어리어 데이터는 그렇지 않다. 또한, 생태 및 환경 분석에서 사용되는 에어리어 표본추출과도 다르다. 후자의 경우는 지역 전체가 아니라 일부 영역을 대상으로 선택적으로 표본추출이 이루어진다.(역자주: 에어리어 데이터는 기본적으로 연구 지역 전체를 상호 배타적(mutually exclusive)이고 완전 포괄적(collectively exhaustive)인 구역으로 분할한 것이다. 즉, 각 구역은 서로 겹치지 않으며, 모든 구역을 합하면 연구 지역 전체를 완전히 덮는다. 이러한 특성 때문에 에어리어 데이터는 지구통계학적 데이터나 부분 표본추출 데이터와는 다른 분석적 전제를 가진다.)\n\n15\\~17장에서는 에어리어 데이터를 탐색하고 분석하기 위한 기법들을 다룬다. 이를 위해서는 관측 개체 간 근접성을 나타내는 특정한 방식이 필요하다. 이 장에서는 근접성을 연접성(contiguity)에 의거해 규정하는 방식에 집중한다. 여기서 연접성은 이웃으로 정의된 관측 개체들을 서로 연결한 그래프를 통해 표현된다. 이 그래프는 일반적으로 방향성과 가중치가 없지만, 특정 설정에서는 방향과 가중치가 부여될 수 있으며, 이 경우 대칭성에 관한 추가적인 문제가 발생할 수 있다. 원칙적으로 근접성은 공간상에서 대칭적으로 작동하는 것으로 간주한다. 즉, $i$가 $j$에 미치는 영향과 $j$가 $i$에 미치는 영향은 동일하다고 본다. 일반적으로 에지 효과(edge effect)는 고려하지 않는다.(역자주: '에지 효과'란 분석 대상 영역의 경계 부분에서 발생하는 통계적 및 공간적 왜곡 현상을 말한다. 예를 들어, 공간가중치행렬을 만들 때 연구 범위의 가장자리(에지)에 위치한 관측 단위는 경계 밖에 실제로 존재하는 인접 객체나 정보가 포함되지 않기 때문에, 중심부에 위치한 관측 단위와 비교해 이웃 수나 가중치가 과소평가될 수 있다. 이러한 경계로 인한 데이터 구조의 불균형은 공간통계 분석 결과에 영향을 미칠 수 있으며, 이를 완화하기 위해 경계 외부를 가상으로 확장하거나, 표준화 방법을 조정하는 등의 보정 기법이 사용된다.)\n\n## 근접성의 재현: spdep 패키지의 경우\n\n공간적 자기상관을 그래프상의 이웃 관계를 통해 다루는 접근에서는, 해당 그래프가 주어진 것이며 연구자가 이를 선택한 것으로 간주한다. 이는 지구통계학적 접근과는 다른데, 지구통계학에서는 연구자는 경험적 베리오그램에서 거리를 어떻게 구간화할지, 어떤 함수를 적용할지, 그리고 베리오그램 적합을 어떻게 수행할지를 모두 선택한다. 두 접근법 모두 사전 선택을 포함하지만, 기저 상관성을 재현하는 방식에서는 서로 다르다(Wall 2004). 또한, 그래프 기반 이웃 규정 방식을 보다 넓은 맥락에서 설명하는 시도도 있다(Bavaud, 1998).\n\n이웃 관계 객체를 생성할 때, 이웃이 없는 구역 단위의 존재는 문제를 야기할 수 있다(Bivand and Portnov 2004). 섬이나 강으로 분리된 구역 단위가 이러한 무이웃 구역 단위에 해당하며, 이는 구역 단위에 에어리어 스포트가 적용되고 공유 경계와 같은 위상 관계가 사용되는 경우에 발생한다. 예를 들어, `mgcv::gam`과 같은 모형 적합 함수에서 `mrf`(마르코프 랜덤 필드) 항을 사용할 때, 방향은 필요하지 않지만 그래프가 분리된 하위 그래프들로 구성되는 있으면 에러가 발생한다.\n\n이러한 무이웃 문제는 포인트 간 거리를 기준으로 이웃을 규정하는 경우에도 발생할 수 있다. 예를 들어, 거리 임계값이 최근린 이웃 거리보다 작은 경우가 이에 해당한다. 공유 경계 기반의 연접성 규정은 좌표계의 종류(투영 좌표계이든 비투영 경위도 좌표이든)에 영향을 받지 않지만, 모든 포인트 기반 접근법은 결국 거리를 사용하므로, 적용하는 투영법의 선택이 결과에 영향을 미칠 수 있다.\n\n**spdep** 패키지는 이웃을 규정하는 `nb` 클래스를 제공한다. `nb` 클래스는 관측 개체 수를 길이로 하는 리스트이며, 각 구성 요소는 정수 벡터로 이루어진다. 이웃이 없는 경우는 `0L`이 단일 요소로 포함된 정수 벡터로 인코딩된다. 이웃이 있는 경우는 `1L:n` 범위 내의 값이 포함된 정수 벡터로 인코딩되며, 해당 값들은 이웃으로 정의된 관측 개체의 인덱스 값이다. 이러한 구조는 소위 '행 기반 희소 표현(row-oriented sparse representation)' 방식이다.(역자주: '행 기반 희소 표현'은 희소 행렬(전체 원소 중 대부분이 0인 행렬)을 행 단위로 저장하면서, 각 행에서 0이 아닌 원소의 위치와 값을 함께 기록하는 방식이다. 공간가중치행렬처럼 대부분의 원소가 0인 행렬을 메모리 효율적으로 저장하고, 관측 단위별 이웃 정보와 가중치를 빠르게 조회할 수 있다.) **spdep** 패키지는 `nb` 객체를 생성하는 다양한 방법을 제공하며, 이 표현과 생성 함수는 다른 패키지에서도 널리 사용된다.\n\n**spdep** 패키지는 `nb` 클래스(무방향 혹은 유방향 그래프)를 기반으로 `listw` 객체를 구성한다. `listw` 객체는 세 가지 구성 요소를 갖는 리스트로, `nb` 객체, 가중치 리스트, 그리고 가중치 계산 방식을 나타내는 단일 요소 문자 벡터가 포함된다. 사회과학 연구에서 가장 흔히 사용되는 방식은 '행표준화가중치(row-standardized weights)'를 계산하는 것이며, 이 때 개별 관측 개체의 한 이웃 가중치는 해당 관측 개체의 이웃 수(즉, 카디널리티)의 역수, 즉, `1/card(nb)[i]`)로 변환된다.\n\n이 장에서는 2015년 폴란드 대통령 선거 데이터를 사용한다. 연구 지역은 총 2,495개의 지방자치단체와 바르샤바 구역으로 구성되어 있다(그림 14.1 참조). 이 지도는 **tmap** 패키지(8.5절)를 활용해 작성되었으며, 지방자치단체 유형이 표시되어 있다. 구역 단위는 **sf** 패키지의 `sf` 객체이며, 투표소 단위의 결과를 구역 단위로 집계한 데이터이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(pol_pres15, package = \"spDataLarge\")\npol_pres15 |>\n    subset(select = c(TERYT, name, types)) |>\n    head()\n# Simple feature collection with 6 features and 3 fields\n# Geometry type: MULTIPOLYGON\n# Dimension:     XY\n# Bounding box:  xmin: 235000 ymin: 367000 xmax: 281000 ymax: 413000\n# Projected CRS: ETRS89 / Poland CS92\n#    TERYT                name       types\n# 1 020101         BOLESŁAWIEC       Urban\n# 2 020102         BOLESŁAWIEC       Rural\n# 3 020103            GROMADKA       Rural\n# 4 020104        NOWOGRODZIEC Urban/rural\n# 5 020105          OSIECZNICA       Rural\n# 6 020106 WARTA BOLESŁAWIECKA       Rural\n#                         geometry\n# 1 MULTIPOLYGON (((261089 3855...\n# 2 MULTIPOLYGON (((254150 3837...\n# 3 MULTIPOLYGON (((275346 3846...\n# 4 MULTIPOLYGON (((251770 3770...\n# 5 MULTIPOLYGON (((263424 4060...\n# 6 MULTIPOLYGON (((267031 3870...\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap, warn.conflicts = FALSE)\n# Breaking News: tmap 3.x is retiring. Please test v4, e.g. with\n# remotes::install_github('r-tmap/tmap')\ntm_shape(pol_pres15) + tm_fill(\"types\")\n```\n:::\n\n\n![2015년 폴란드 구역 단위 유형](https://r-spatial.org/book/14-Areal_files/figure-html/fig-plotpolpres15-1.png){#fig-14-1}\n\n`sf` 객체의 위상 구조가 밸리드한지 확인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!all(st_is_valid(pol_pres15)))\n        pol_pres15 <- st_make_valid(pol_pres15)\n```\n:::\n\n\n2002년 초부터 2019년 4월까지 **spdep** 패키지에는 이웃 및 공간가중치 객체를 생성하고 처리하는 함수, 공간적 자기상관을 검정하는 함수, 그리고 모형 적합과 관련된 함수 등이 포함되어 있었다. 이 중 모형 적합과 관련 함수는 **spatialreg** 패키지로 분리되었으며, 이에 대해서는 이후 장에서 다룰 예정이다. 현재 **spdep** 패키지(Bivand 2022)는 `sf` 클래스와 `sp` 클래스 객체 모두를 지원한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spdep) |> suppressPackageStartupMessages()\n```\n:::\n\n\n## 연접성에 기반한 이웃의 규정\n\n**spdep** 패키지의 `poly2nb()` 함수는 `pl` 인수를 통해 입력된 객체에서 폴리곤 경계를 구성하는 경계 포인트들을 이용한다. 입력 객체는 일반적으로 `POLYGON` 또는 `MULTIPOLYGON` 지오메트리를 가진 `sf` 또는 `sfc` 객체이다. 각 관측 개체에 대해, 최소 하나의 포인트(기본값인 퀸 방식, `queen = TRUE`) 또는 최소 두 개의 포인트(루크 방식, `queen = FALSE`)가 `snap` 거리 내에 다른 폴리곤의 경계 포인트에 위치하는 지를 확인한다. 거리 계산은 투영법에 관계없이 원 길이 단위에 기반한 평면 거리로 수행된다. 필요한 수의 충분히 가까운 점을 찾으면 검색이 중단된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(poly2nb)\n```\n:::\n\n\n```         \n#  function (pl, row.names = NULL, snap = sqrt(.Machine$double.eps),\n#    queen = TRUE, useC = TRUE, foundInBox = NULL)\n```\n\n**spdep** 패키지 1.1-7부터 `poly2nb()` 함수는 후보 이웃을 찾고 `foundInBox`를 내부적으로 채우기 위해 **sf** 패키지의 GEOS 인터페이스를 사용한다. 이 경우, **sf** 패키지를 통한 GEOS의 공간 인덱싱(STRtree 쿼리 사용)이 기본값으로 설정된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15 |> poly2nb(queen = TRUE) -> nb_q\n```\n:::\n\n\n`print` 메서드는 이웃 객체의 요약 구조를 출력한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14242 \n# Percentage nonzero weights: 0.229 \n# Average number of links: 5.71\n```\n:::\n\n\n**sf** 패키지 버전 1.0-0부터는 구체 지오메트리에 대해 기본적으로 **s2** 패키지(Dunnington, Pebesma, and Rubak 2023)가 사용된다. 이는 `poly2nb()` 함수에서 사용하는 `st_intersects()` 함수가 계산을 `s2::s2_intersects_matrix()` 함수로 전달하기 때문이다(4장 참조). **spdep** 패키지 버전 1.1-9부터는 `sf_use_s2()`가 `TRUE`일 경우 구체 인터섹션을 사용하여 후보 이웃을 찾는다. GEOS와 마찬가지로 `s2` 라이브러리도 빠른 공간 인덱싱을 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold_use_s2 <- sf_use_s2()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_use_s2(TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(pol_pres15 |> st_transform(\"OGC:CRS84\") -> pol_pres15_ll) |> \n    poly2nb(queen = TRUE) -> nb_q_s2\n```\n:::\n\n\n이 예시에서는 구면 인터섹션과 평면 인터섹션이 동일한 인접 이웃을 생성한다. 두 경우 모두 입력 지오메트리가 밸리드해야 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(nb_q, nb_q_s2, check.attributes=FALSE)\n# [1] TRUE\n```\n:::\n\n\n`nb` 객체는 대칭적인 이웃 관계인 `i`에서 `j`, `j`에서 `i`를 모두 기록한다. 이는 `nb` 객체가 비대칭적인 관계도 허용하기 때문이다. 그러나 객체 생성 단계에서 이러한 중복은 큰 의미가 없다.\n\n대부분의 **spdep** 패키지 함수는 이웃 객체를 생성할 때 `row.names` 인수를 사용하며, 이 값은 `region.id` 속성으로 저장된다. `row.names` 인수가 지정되지 않으면, 첫 번째 인수의 `row.names`에서 값을 가져온다. `region.id` 속성은 `nb` 객체가 원 데이터와 동일한 순서로 정리되어 있는지를 확인하는 데 사용된다. `nb` 객체의 일부만 추출할 경우, 인덱스는 `1:length(subsetted_nb)` 범위 내 값으로 재설정되지만, `region.id` 속성을 통해 원본 객체와의 정확한 연결 정보를 확인할 수 있다. 이는 17.4절에서 간략히 논의할 공간적 회귀 모형의 표본 외 예측에서 사용된다.\n\n또는 `n.comp.nb()` 함수를 사용해 이 무방향 그래프의 연결성을 확인할 수도 있다. 일부 모형 추정 기법은 비연결 그래프를 지원하지 않지만, 비연결 그래프가 초래할 문제를 인지하는 것은 중요하다(Freni-Sterrantino, Ventrucci, and Rue 2018).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> n.comp.nb())$nc\n# [1] 1\n```\n:::\n\n\n이 접근법은 이웃 객체를 그래프로 취급한 뒤, 해당 그래프에 대해 그래프 분석을 수행하는 것과 동일하다(Csardi and Nepusz 2006; Nepusz 2022). 먼저 이웃 객체를 이진 희소 행렬로 변환한 후, 그래프 분석을 수행한다(Bates, Maechler, and Jagan 2022).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Matrix, warn.conflicts = FALSE)\nlibrary(spatialreg, warn.conflicts = FALSE)\nnb_q |> \n    nb2listw(style = \"B\") |> \n    as(\"CsparseMatrix\") -> smat\nlibrary(igraph, warn.conflicts = FALSE)\n(smat |> graph.adjacency() -> g1) |> \n    count_components()\n# [1] 1\n```\n:::\n\n\n다른 소프트웨어와의 호환성을 위해 이웃 객체를 GAL 형식으로 내보내거나 가져올 수 있다. 이를 위해 `write.nb.gal()`함수와 `read.gal()` 함수를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntf <- tempfile(fileext = \".gal\")\nwrite.nb.gal(nb_q, tf)\n```\n:::\n\n\n## 그래프에 기반한 이웃의 규정\n\n구역 단위가 적합한 재현이지만 평면상의 포인트로 관찰된 경우, 연접성은 그래프 기반 이웃을 사용해 근사할 수 있다. 이때 평면은 폴리곤 테셀레이션으로 분할되며, 각 폴리곤 내 모든 지점은 해당 포인트를 가장 가까운 포인트로 갖는다. 가장 간단한 형태는 삼각망(triangulation)을 사용하는 것이며, 여기서는 **deldir** 패키지의 `deldir()` 함수를 사용한다.(역자주: 주어진 포인트를 이용해 들로네 삼각망을 형성하고, 그것을 바탕으로 티센 폴리곤을 생성한 후 연접성에 기반하여 포인트 간 이웃 관계를 규정한다.) 이 함수는 $i$와 $j$ 식별자를 반환하므로, 세로(긴) 형식으로 `listw` 객체를 구성하기가 용이하다. 이는 과거 S-Plus SpatialStats 모듈에서 사용된 방식이며, `nb` 객체(가로 형식)를 생성하기 위해 내부적으로 `sn2listw()` 함수에서 사용되는 방식이기도 하다. 한편 GEOS와 같은 다른 대안은 이웃을 식별하기 위한 충분한 정보를 반환하지 못한다.\n\n이러한 함수들이 반환한 결과는 `graph2nb()` 함수를 통해 `nb` 객체로 변환된다. 이때 `sym` 인수를 사용해 이웃 관계의 대칭성을 지정할 수 있다. 그래프 기반 방식을 적용하기 위해 폴리곤의 센트로이드(다중 폴리곤의 경우 가장 큰 폴리곤의 센트로이드)를 포인트 재현으로 활용한다. 물론 인구 가중 센트로이드를 구할 수 있다면 더 바람직하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15 |> \n    st_geometry() |> \n    st_centroid(of_largest_polygon = TRUE) -> coords \n(coords |> tri2nb() -> nb_tri)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14930 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 5.98\n```\n:::\n\n\n평균 이웃 수의 측면에서 보면 퀸 방식의 경계 연접성과 유사한 결과가 나타났다. 그러나 `nbdists()` 함수를 사용해 엣지 길이의 분포를 살펴보면, 상위 4분위수는 약 15 km이지만 최대값은 거의 300 km에 달한다. 이는 전체 지역을 포괄하는 컨벡스헐(convex hull)의 한쪽 변 길이에 버금가는 수준이다.(역자주: 컨벡스헐은 평면 또는 다차원 공간에 분포한 점 집합을 완전히 포함하는 가장 작은 볼록 다각형(또는 볼록 다면체)을 말한다. 쉽게 말해, 모든 점을 고무줄로 감싼 뒤 고무줄이 팽팽하게 당겨져 형성된 경계선이 컨벡스헐에 해당한다. 공간분석에서는 관측 지점의 외곽 경계를 정의하거나, 데이터 범위를 시각화하고 공간적 패턴을 파악하는 데 자주 활용된다. 컨벡스헐은 볼록다각형(convex polygon)의 성질을 가지므로, 내부의 임의의 두 점을 연결한 선분은 항상 헐 내부에 존재한다.) 최소 거리 역시 중요한데, 많은 도시 구역의 센트로이드가 주변 농촌 구역의 센트로이드와 매우 근접해 있기 때문이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_tri |> \n    nbdists(coords) |> \n    unlist() |> \n    summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    9847   12151   13485   14994  296974\n```\n:::\n\n\n삼각망에 의거한 이웃 규정도 연결 그래프를 생성한다.(역자주: 여기서 '연결 그래프'란 그래프상의 모든 지점이 직ㆍ간접적으로 연결되어 있는 그래프를 말한다.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_tri |> n.comp.nb())$nc\n# [1] 1\n```\n:::\n\n\n그래프 기반 접근법에는 `soi.graph()`, `relativeneigh()`, `gabrielneigh()` 등의 메서드가 있으며, 여기서는 `soi.graph()` 함수만 살펴본다.\n\n`soi.graph()` 함수에서 SOI는 영향권(sphere of influence)의 약자이다. 이 함수는 삼각망 이웃에서 비정상적으로 긴 엣지로 표현된 이웃 관계를 제거하여, 실질적인 의미를 갖는 이웃 관계만 남긴다. 이러한 비정상적으로 긴 엣지는 컨벡스헐의 가장자리에서 흔히 나타난다(Avis and Horton, 1985).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_tri |> \n        soi.graph(coords) |> \n        graph2nb() -> nb_soi)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 12792 \n# Percentage nonzero weights: 0.205 \n# Average number of links: 5.13\n```\n:::\n\n\n그러나 삼각망 기반 이웃 관계의 일부를 해체하면, 연결 그래프로서의 전체 특성은 사라지게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_soi |> n.comp.nb() -> n_comp)$nc\n# [1] 16\n```\n:::\n\n\n이 알고리즘은 비정상적으로 긴 엣지를 제거하도록 설계되었지만, 농촌 구역이 하나의 도시 구역을 완전히 둘러싸고 있는 경우, 매우 가까운 도시-농촌 쌍의 엣지도 잘못 삭제될 수 있다. 이로 인해 15개의 도시-농촌 쌍이 메인 그래프로부터 분리되는 결과가 발생하였다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(n_comp$comp.id)\n# \n#    1    2    3    4    5    6    7    8    9   10   11   12   13 \n# 2465    2    2    2    2    2    2    2    2    2    2    2    2 \n#   14   15   16 \n#    2    2    2\n```\n:::\n\n\n컨벡스헐에서 가장 긴 엣지들이 제거되었지만, 연결되지 않은 이웃 쌍이 발생하면서 '구멍'이 형성되었다. `nb_tri`와 `nb_soi`의 차이는 그림 14.2에서 주황색으로 표시되어 있다.\n\n![삼각망 이웃(오렌지색과 검은색)과 영향권 이웃(검은색)의 비교. 곳곳에 형성된 구멍은 모두 도시 구역이 농촌 구역으로 완전히 둘러싸여 있는 경우에 해당한다(그림 14.1 참조).](https://r-spatial.org/book/14-Areal_files/figure-html/fig-plotnbdiff-1.png){#fig-14-2}\n\n## 거리에 기반한 이웃의 규정\n\n거리 기반 이웃은 `dnearneigh()` 함수를 사용해 생성할 수 있다. `bounds` 인수를 통해 거리 구간을 설정할 수 있으며, `d1`과 `d2`는 각각 거리의 하한값과 상한값이다. 경위도 좌표계를 사용하고 좌표 객체 `x`가 주어지며 `longlat = TRUE`로 설정된 경우, WGS84 기준 타원체를 가정해 킬로미터 단위의 대권 거리를 계산한다. `use_s2 = TRUE`(기본값)로 설정하면 구체를 가정한 거리 계산을 수행한다(4장 참조). `dwithin`이 `FALSE`이고 **s2** 패키지 버전이 1.0.7보다 크면 `s2_closest_edges()` 함수가 사용되며, `dwithin`이 `TRUE`이고 `use_s2 = TRUE`이면 `s2_dwithin_matrix()` 함수가 사용된다. 두 방법 모두 빠른 구형 공간 인덱싱을 사용하지만, `s2_closest_edges()` 함수의 경우 최소 및 최대 경계를 지정하므로 `dnearneigh()` 함수의 R 코드에서 한 번의 실행만으로 충분하다.\n\n**dbscan** 패키지(Hahsler and Piekenbrock 2022)에 새로운 인수가 추가되어, 2차원 또는 3차원에서 평면 공간 인덱싱을 사용해 이웃을 찾는 기능이 보강되었으며, 대칭성을 확인하는 절차가 필요 없어졌다. 또한, 구면 기하학적 거리 측정을 위한 세 가지 인수도 추가되었다.\n\n$k$-최근린 이웃을 위한 `knearneigh()` 함수는 `knn` 객체를 반환하며, 이를 `knn2nb()` 함수를 사용해 `nb` 객체로 변환된다. 이 함수는 구면 거리 계산도 지원하는데, 이는 평면 거리와는 다른 최근린 이웃을 산출할 수 있기 때문이다. `k` 값은 작은 숫자로 설정하는 것이 일반적이다. 투영 좌표계에서는 **dbscan** 패키지를 사용해 최근린 이웃을 더 효율적으로 계산할 수 있다. 이렇게 생성된 `nb` 객체는 대개 대칭적이지 않으므로, `knn2nb()` 함수는 대칭성을 강제할 수 있는 `sym` 인수를 제공한다. 대칭성을 강제하면 모든 단위가 최소 `k`개의 이웃을 갖게 되지만, 모든 단위가 정확히 `k`개의 이웃을 갖는 것은 아니다. `sf_use_s2()` 함수가 `TRUE`인 경우, 입력 객체가 `sf` 또는 `sfc` 클래스일 때 `knearneigh()` 함수는 빠른 구형 공간 인덱싱을 사용한다.\n\n`nbdists()` 함수는 투영 좌표를 사용할 경우 좌표 단위로, 그렇지 않으면 킬로미터 단위로 이웃 관계 엣지의 길이를 반환한다. 거리 밴드의 상한을 설정하려면 먼저 첫 번째 최근린 이웃 거리의 최대값을 찾아야 하며, 이때 반환된 객체의 리스트 구조를 제거하기 위해 `unlist()` 함수를 사용할 수 있다. `sf_use_s2()` 함수가 `TRUE`이면, 입력 객체가 `sf` 또는 `sfc` 클래스일 때 `nbdists()` 함수는 빠른 구형 거리 계산을 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords |> \n    knearneigh(k = 1) |> \n    knn2nb() |> \n    nbdists(coords) |> \n    unlist() |> \n    summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    6663    8538    8275   10124   17979\n```\n:::\n\n\n여기서 첫 번째 최근린 이웃 거리의 최대값은 약 18 km이며, 이를 거리 상한으로 설정하면 모든 단위가 최소 하나 이상의 이웃을 갖게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords |> dnearneigh(0, 18000) -> nb_d18\n```\n:::\n\n\n이 사례에서 보듯, 관측 개체의 수가 많지 않으면 공간 인덱싱을 사용하더라도 실행 시간에서 큰 이점을 얻지 어렵다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords |> dnearneigh(0, 18000, use_kd_tree = FALSE) -> nb_d18a\n```\n:::\n\n\n그리고 산출되는 객체 역시 동일하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(nb_d18, nb_d18a, check.attributes = FALSE)\n# [1] TRUE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_d18\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 20358 \n# Percentage nonzero weights: 0.327 \n# Average number of links: 8.16\n```\n:::\n\n\n이웃이 없는 관측값은 없지만(이는 `nb` 객체의 `print` 메소드에서 확인할 수 있음), 그래프는 완전 연결 상태가 아니다. 한 쌍의 관측 개체가 서로의 유일한 이웃인 경우가 있기 때문이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_d18 |> n.comp.nb() -> n_comp)$nc\n# [1] 2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(n_comp$comp.id)\n# \n#    1    2 \n# 2493    2\n```\n:::\n\n\n임계값에 300m를 추가하면, 비이웃 관측 단위가 없는 이웃 객체가 생성되며 모든 관측 단위가 그래프를 통해 서로 도달 가능해진다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords |> dnearneigh(0, 18300) -> nb_d183)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21086 \n# Percentage nonzero weights: 0.339 \n# Average number of links: 8.45\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_d183 |> n.comp.nb())$nc\n# [1] 1\n```\n:::\n\n\n거리 기반 이웃의 특징 중 하나는, 면적이 작은 단위가 밀집된 지역일수록 이웃 수가 많아진다는 점이다. 예를 들어, 바르샤바 구역은 평균 면적이 훨씬 작지만 이 거리 기준으로 약 30개의 이웃을 가진다. 이웃 수가 많아지면, 개별 이웃의 영향이 더 많은 이웃에게 분산되어 관계가 완화된다.(역자주: 여기서 ‘관계가 완화된다’는 것은 공간 가중 행렬에서 특정 관측 단위의 영향이 소수의 이웃에 집중되는 대신, 더 많은 이웃에 분산되어 각 이웃이 받는 영향이 상대적으로 약해지는 것을 의미한다.)\n\n나중에 사용하기 위해, 16 km의 임계값을 사용하여 비이웃 단위가 포함된 이웃 객체도 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords |> dnearneigh(0, 16000) -> nb_d16)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 15850 \n# Percentage nonzero weights: 0.255 \n# Average number of links: 6.35 \n# 7 regions with no links:\n# 569 1371 1522 2374 2385 2473 2474\n```\n:::\n\n\n$k$-최근린 이웃을 사용하면 이웃의 수를 직접적으로 제어할 수 있으며, 비대칭 이웃을 허용하는 것도 가능하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n((coords |> knearneigh(k = 6) -> knn_k6) |> knn2nb() -> nb_k6)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14970 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 6 \n# Non-symmetric neighbours list\n```\n:::\n\n\n또는 대칭성을 부여할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(knn_k6 |> knn2nb(sym = TRUE) -> nb_k6s)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 16810 \n# Percentage nonzero weights: 0.27 \n# Average number of links: 6.74\n```\n:::\n\n\n여기서 `k` 값은 완전 연결성을 보장할 만큼 크지만, 그래프가 반드시 평면성을 가지는 것은 아니다. 이는 엣지가 노드가 아닌 지점에서 교차하기 때문이며, 이러한 현상은 연접성 기반 이웃이나 그래프 기반 이웃에서는 발생하지 않는다.(역자주: 여기서 ‘평면성을 가지지 않는다’는 것은, 네트워크를 2차원 평면 위에 배치했을 때 엣지가 서로 교차하는 경우가 발생함을 의미한다. 평면 그래프에서는 엣지가 반드시 노드에서만 교차해야 하지만, $k$-최근린 이웃 그래프는 거리 기준으로 연결되기 때문에 노드가 아닌 위치에서 엣지가 교차하는 비평면 구조가 나타날 수 있다.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_k6s |> n.comp.nb())$nc\n# [1] 1\n```\n:::\n\n\n구체 상의 포인트인 경우(4장 참조), `st_centroid()` 함수의 출력이 달라질 수 있으므로, 포인트를 직접 역투영하기 보다는 역투영된 폴리곤 지오메트리에서 경위도 좌표를 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold_use_s2 <- sf_use_s2()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_use_s2(TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15_ll |> \n    st_geometry() |> \n    st_centroid(of_largest_polygon = TRUE) -> coords_ll\n```\n:::\n\n\n구면 좌표의 경우, 이웃 판정을 위한 거리 구간의 경계값은 킬로미터 단위로 지정된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords_ll |> dnearneigh(0, 18.3, use_s2 = TRUE, \n                         dwithin = TRUE) -> nb_d183_ll)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21140 \n# Percentage nonzero weights: 0.34 \n# Average number of links: 8.47\n```\n:::\n\n\n이 이웃들은 예상한 바와 같이 구면 거리 18.3 km 기준의 이웃들과는 다르다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisTRUE(all.equal(nb_d183, nb_d183_ll, check.attributes = FALSE))\n# [1] FALSE\n```\n:::\n\n\n**s2** 패키지가 더 빠른 거리 기반 이웃 인덱싱을 제공하는 경우, 경위도 좌표에서는 기본적으로 `s2_closest_edges()` 함수가 사용된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords_ll |> dnearneigh(0, 18.3) -> nb_d183_llce)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21140 \n# Percentage nonzero weights: 0.34 \n# Average number of links: 8.47\n```\n:::\n\n\n이 경우, 두 **s2** 기반 이웃 객체는 동일하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisTRUE(all.equal(nb_d183_llce, nb_d183_ll,\n                 check.attributes = FALSE))\n# [1] TRUE\n```\n:::\n\n\n**s2** 패키지를 사용해 빠른 구형 공간 인덱싱으로 $k$-최근린 이웃을 찾는다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords_ll |> knearneigh(k = 6) |> knn2nb() -> nb_k6_ll)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14970 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 6 \n# Non-symmetric neighbours list\n```\n:::\n\n\n이 이웃들은 예상대로 평면 기준 `k = 6` 최근린 이웃과는 다르며, 전통적인 브루트포스(brute-force) 방식의 타원체 거리 계산 결과와도 약간 차이가 날 것이다.(역자주: 브루트포스 방식의 타원체 거리 계산은 지구를 타원체로 가정했을 때 두 지점 간 거리를 구하는 공식을 최적화 없이 모든 점 쌍에 대해 직접 적용하는 전수검사식 방법이다. 계산량이 많아 속도가 느리지만, 알고리즘이 단순하고 결과가 정확하다는 장점이 있다.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisTRUE(all.equal(nb_k6, nb_k6_ll, check.attributes = FALSE))\n# [1] FALSE\n```\n:::\n\n\n`nbdists()` 함수도 `sf` 또는 `sfc` 클래스의 투입 객체가 경위도 좌표값을 가질 경우, **s2** 패키지를 사용해 구면 거리를 계산하며, 반환 거리는 킬로미터 단위로 표시된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q |> nbdists(coords_ll) |> unlist() |> summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     0.2     9.8    12.2    12.6    15.1    33.0\n```\n:::\n\n\n동일한 가중치 객체라도 평면 좌표를 사용할 경우와 구형 또는 타원체 지오메트리를 사용할 경우에는 계산된 거리 값이 약간 다르다(평면 지오메트리의 경우 거리는 투영 좌표계의 단위(보통 미터)로 반환되며, 타원체와 구형 지오메트리의 경우 거리는 킬로미터 단위로 반환된다).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q |> nbdists(coords) |> unlist() |> summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    9822   12173   12651   15117   33102\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_use_s2(old_use_s2)\n```\n:::\n\n\n## 가중치 지정\n\n이웃 객체를 기반으로 가중치 객체를 지정한다. 이 과정에서 몇 가지 선택을 해야 한다. `nb2listw()` 함수는 `nb` 객체를 바탕으로 `listw` 가중치 객체를 생성한다. 가중치 객체는 가중치 벡터 리스트와 가중치 스타일을 나타내는 선택값으로 구성된다. 이 때 중요한 사안 중 하나는 비이웃 관측 개체의 처리 방식이며, 이를 `zero.policy` 인수가 제어한다. 기본값은 `FALSE`로, 비이웃 관측 개체가 조재하면 오류를 발생시킨다. 이는 관측 개체가 이웃을 갖지 않으면 공간래그값(spatially lagged values)을 계산할 수 없기 때문이다.(역자주: 'spatially lagged values'는 국내에서 ‘공간지연값’, '공간시차값', ‘공간지체값’, ‘공간래그값’ 등 다양한 번역어가 사용된다. 본 역서에서는 ‘공간래그값’을 표준 표기로 사용한다. 그 이유는 'lag'가 시계열 분석에서 시간적 지연을 뜻하는 용어이지만, 공간통계에서의 시간과 무관하게 주변 공간 단위의 값을 공간가중치행렬을 이용해 가중 평균한 값을 의미한다. 따라서 ‘지연’이나 ‘지체’처럼 시간적 어감이 강한 번역어는 공간적 개념을 설명하는 데 부적절하므로, 학계에서 널리 쓰이는 음역어 ‘래그’를 채택하였다.) 일반적으로 비이웃 관측 개체에 대해 공간래그값을 0으로 부여하는데, 이는 제로 값의 가중치 벡터와 데이터 벡터의 교차곱과 동일하기 때문에 `zero.policy`라는 이름이 붙여졌다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(nb2listw)\n```\n:::\n\n\n```         \n#  function (neighbours, glist = NULL, style = \"W\", zero.policy =\n#    NULL)\n```\n\n스타일 선택을 변경했을 때의 결과를 보여주기 위해, 아래에서 도우미 함수 `spweights.constants`를 사용한다. 이 함수는 `listw` 객체에 대한 여러 상수 값을 반환한다. 여기서 $n$은 관측 개체의 수이며, `n1`부터 `n3`은 $n-1,...,$ `nn`은 $n^2$을 의미한다. $S_0$, $S_1$, $S_2$는 상수로, $S_0$는 가중치의 합을 나타낸다. 이러한 상수들에 대한 자세한 논의는 Bivand와 Wong(2018)를 참고하면 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(spweights.constants)\n```\n:::\n\n\n```         \n#  function (listw, zero.policy = NULL, adjust.n = TRUE)\n```\n\n`\"B\"` 바이너리 스타일은 각 이웃 관계에 단위 값(1)을 부여한다. 이 방식은 이웃을 규정하는 경계가 존재하는 가장자리 구역 단위에 비해, 더 많은 이웃을 가질 수 있는 내부 구역 단위에 상대적으로 더 높은 가중치를 부여하게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> \n    nb2listw(style = \"B\") -> lw_q_B) |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select = c(n, S0, S1, S2))\n#      n    S0    S1     S2\n# 1 2495 14242 28484 357280\n```\n:::\n\n\n`\"W\"` 행 표준화 스타일은 연구 지역의 가장자리에 위치하여 필연적으로 더 적은 수의 이웃을 가질 수 밖에 없는 구역 단위에 더 높은 가중치를 부여한다. 이 방식은 먼저 각 이웃 관계에 단위 값을 가중치로 부여한 뒤, 이를 해당 구역 단의의 가중치 합으로 나누어 표준화한다. 비이웃 구역 단위의 경우 0을 0으로 나누게 되어 '부정(not-a-number)' 값이 발생하지만, `zero.policy`를 `TRUE`로 설정하면 문제가 없다. 행 표준화 스타일에서는 $S_0$는 $n$과 같아진다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> \n        nb2listw(style = \"W\") -> lw_q_W) |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select = c(n, S0, S1, S2))\n#      n   S0  S1    S2\n# 1 2495 2495 958 10406\n```\n:::\n\n\n역거리 가중치는 여러 과학 분야에서 사용된다. 일부에서는 밀집된 역거리 행렬을 사용하지만, 이 경우 많은 역거리 값이 거의 0에 가까워 실제적으로 기여하는 바가 적으며, 특히 공간 프로세스 행렬 자체가 밀집된 경우 그 영향은 더욱 제한적이다. 역거리 가중치는 보통 다음과 같은 절차로 구성된다. 먼저 엣지 길이를 계산하고, 대부분의 가중치 값이 지나치게 크거나 작지 않도록 단위를 변환하며(예: 미터를 킬로미터로 변환), 이를 역수로 변환한 뒤, `nb2listw()` 함수의 `glist` 인수로 전달한다.(역자주: “밀집된 역거리 행렬에서 많은 값이 0에 가깝다”는 것은, 거리의 역수를 취했을 때 멀리 떨어진 단위들 간의 가중치가 극도로 작아져, 공간분석에서 거의 영향력을 행사하지 못한다는 의미이다. 특히 공간 프로세스 행렬 자체가 이미 대부분의 단위들 간 연결을 포함하고 있다면, 이러한 미소 가중치는 분석 결과에 실질적인 변화를 주지 않는다.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_d183 |> \n    nbdists(coords) |> \n    lapply(function(x) 1/(x/1000)) -> gwts\n(nb_d183 |> nb2listw(glist=gwts, style=\"B\") -> lw_d183_idw_B) |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select=c(n, S0, S1, S2))\n#      n   S0  S1   S2\n# 1 2495 1841 534 7265\n```\n:::\n\n\n비이웃 단위의 경우, 기본 설정은 가중치 객체의 생성을 막아 두어, 이후 절차를 어떻게 진행할지에 대해 분석가가 입장을 정하도록 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(nb_d16 |> nb2listw(style=\"B\") -> lw_d16_B)\n# Error in nb2listw(nb_d16, style = \"B\") : Empty neighbour sets found\n```\n:::\n\n\n`nb`와 `listw` 객체와 관련된 많은 함수에서 `zero.policy` 인수를 사용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_d16 |> \n    nb2listw(style=\"B\", zero.policy=TRUE) |> \n    spweights.constants(zero.policy=TRUE) |> \n    data.frame() |> \n    subset(select=c(n, S0, S1, S2))\n#      n    S0    S1     S2\n# 1 2488 15850 31700 506480\n```\n:::\n\n\n`spweights.constants()` 함수의 `adjust.n` 인수는 기본적으로 `TRUE`로 설정되어 있어, 비이웃 관측 개체 수를 제외하므로 $n$ 값이 작아지고 통계적 추론에 영향을 줄 수 있다. 원래의 $n$ 값은 인수를 다르게 지정하면 확인할 수 있다.\n\n## 고차 이웃의 정의\n\n앞서 살펴본 퀸 인접성 기반 이웃 객체의 특성은 다음과 같다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14242 \n# Percentage nonzero weights: 0.229 \n# Average number of links: 5.71\n```\n:::\n\n\n$i$가 $j$의 이웃이고, $j$가 $k$의 이웃인 경우, 즉 이웃 그래프에서 두 단계를 거쳐 $i$에서 $k$로 이어지는 이웃 관계를 나타내는 객체를 만들고자 한다면, `nblag()` 함수를 사용할 수 있다. 이 함수는 자동으로 $i$ 에서 $i$로 가는 자기 이웃 관계를 제거한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> nblag(2) -> nb_q2)[[2]]\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 32930 \n# Percentage nonzero weights: 0.529 \n# Average number of links: 13.2\n```\n:::\n\n\n`nblag_cumul()` 함수는 지정된 모든 차수의 이웃 목록을 누적하여 반환한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnblag_cumul(nb_q2)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 47172 \n# Percentage nonzero weights: 0.758 \n# Average number of links: 18.9\n```\n:::\n\n\n`union.nb()` 함수의 집합 연산은 두 개의 객체를 입력받아 처리하며, 이 예시에서는 동일한 결과를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunion.nb(nb_q2[[2]], nb_q2[[1]])\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 47172 \n# Percentage nonzero weights: 0.758 \n# Average number of links: 18.9\n```\n:::\n\n\n앞에서 이웃 객체를 그래프 형태로 변환하였는데, 이렇게 생성된 그래프 객체를 이용하면 그래프 탐색에 필요한 단계 수에 관한 정보를 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiameter(g1)\n# [1] 52\n```\n:::\n\n\n각 관측 개체에서 그래프를 통해 최단 경로로 도달하는 데 필요한 단계 수를 계산하여 $n \\times n$ 크기의 `sps` 행렬을 생성한다. 이를 통해 동일한 최대값을 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng1 |> shortest.paths() -> sps\n(sps |> apply(2, max) -> spmax) |> max()\n# [1] 52\n```\n:::\n\n\n최대값을 가진 지방자치단체는 Lutowiska(루토비스카)로, 남동부의 끝에 위치해 있으며 우크라이나와 국경을 접하고 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmr <- which.max(spmax)\npol_pres15$name0[mr]\n# [1] \"Lutowiska\"\n```\n:::\n\n\n그림 14.3은 연접성 기반 이웃이 거리 기반 이웃과 마찬가지로 다른 관측값들과 동일한 유형의 관계를 나타낸다는 점을 보여준다. 일부 접근법에서는 거리 기반 이웃을 선호하는데, 예를 들어 역거리 가중 이웃은 모든 관측값이 서로 어떻게 연결되어 있는지를 명확히 드러내기 때문이다. 그러나 공간적 자기상관 검정이나 공간 회귀 모형 개발 과정에서는 공간 프로세스 모형의 역행렬을 사용하게 된다.(역자주: ‘공간 프로세스 모형의 역행렬’이란, 공간적 자기상관이나 공간 회귀 모형을 계산할 때 수행되는 수학적 역연산을 의미한다. 이 연산 과정에는 공간가중치행렬을 반복적으로 곱하고 더하는 절차가 포함되며, 그 결과 모든 관측값이 서로 영향을 주고받는 관계가 모형에 자동으로 반영된다.) 이 역은 계수와 공간가중치행렬의 곱을 거듭제곱하여 더한 급수로 표현될 수 있으며, 이는 본질적으로 모든 관측값이 다른 모든 관측값과 관계를 맺고 있음을 전제로 한다. 희소 연접성 기반 이웃 객체는 이러한 의존성 구조를 명시적으로 기술하지 않더라도 풍부한 종속 관계를 포괄할 수 있다.\n\n![Lutowiska까지의 최단 경로 수와 거리의 관계. 왼쪽 지도는 Lutowiska까지의 최단 경로 수를, 오른쪽 그래프는 최단 경로 수와 거리의 관계를 보여준다.](https://r-spatial.org/book/14-Areal_files/figure-html/fig-shortestpath-1.png){#fig-14-3}\n\n## 연습문제\n\n1.  어떤 유형의 지오메트리 스포트가 이웃 객체를 생성하는 함수에 적합하지 설명하시오.\n\n2.  이웃 객체를 생성하는 함수 중, 평면 재현에만 사용할 수 있는 것은 무엇인지 설명하시오.\n\n3.  체스판에서 `queen` 연접성 대신 `rook` 연접성을 선택하면 어떤 차이가 발생하는지 설명하시오.\n\n4.  이웃 집합의 카디널리티(이웃 수)와 행표준화가중치 사이에는 어떤 관계가 있으며, 이러한 관계가 어떻게 엣지 효과(edge effect) 분석을 가능하게 하는지 설명하시오. 3번 문제에서 만든 체스판을 사용하여 `rook` 이웃과 `queen` 이웃 각각에 대해 설명하시오.\n",
    "supporting": [
      "14_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}