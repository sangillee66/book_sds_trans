{
  "hash": "d174db36bfc270a4996a6a3627807406",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n# 근접성과 에어리어 데이터 {#sec-area}\n\n관측개체가 에어리어 객체인 경우는 매우 흔하다. 연구대상 전체에서 관측이 동시적으로 이루어지고 그러한 관측값이 비중첩 구역단위로 합산되는 경우가 여기에 해당한다. 이러한 구역단위는 행정구역인 경우가 많다. 물론 통근 플로와 같이 기저 공간 프로세스를 직접적으로 반영한 경우도 있지만, 보통은 프로세스와 관계없이 임의적으로 주어진다. 이러한 구역단위와 기저 공간 프로세스 간의 불일치는 동일한 공간적 프로세스가 인접한 구역단위 사이에서 부분적으로 공유된다는 것을 의미하며, 이러한 불일치가 해당 데이터셋 내의 단 하나의 변수에서라도 발생한다면, 전체적으로 공간적 자기상관의 문제가 야기된다고 할 수 있다. 여기서 근접성(proximity)이란 데이터 생성 프로세스라는 의미에서의 *가까움*(closeness)을 의미한다. 포인트 스포트를 사용하는 횡단 지구통계학 분석에서는 포인트 간 거리가 전형적인 데이터 생성 프로세스에 적합하다. 그런데, 에어리어 데이터의 경우는 거리보다는 공유 경계가 더 적합할 수 있다. 공유 경계는 우리가 확실히 측정할 수 있는 것이지만, 동일한 확실성 하에서 에어리어간 거리를 측정할 수 있는 방법은 없기 때문이다.\n\n데이터의 스포트란 개별 관찰단위(관측개체)의 물리적 크기(길이, 면적, 부피)를 의미한다(5장 참조). 에어리어 데이터는 기본적으로 폴리곤 스포트를 가지지만 포인트 서포트를 가지는 것으로 재현할 수도 있다. 개별 폴리곤의 센트로이드 혹은 멀티폴리곤의 경우는 최대 폴리곤의 센트로이드를 대표 지점으로 삼을 수 있다. 반대로, 포인트 스포트를 가지는 데이터를 에어리어 데이터로 취급할 수도 있다. 이 경우 포인트를 비중첩 테셀레이션으로 전환해야 하는데, 들로네 삼각망을 통해 보로노이 다이어그램(디리클레 테셀레이션 혹은 티센 폴리곤)을 생성한다. 다른 메트릭이 선택될 수 있으며, 평면이 아닌 네트워크 상의 거리를 측정할 수도 있다. 국지적 공간 분석에서는 가중 보로노이 다이어그램이 사용되기도 한다(Boots and Okabe 2007; Okabe et al. 2008; She et al. 2015 참조).\n\n데이터의 원 스포트가 포인트이지만, 기저의 공간 프로세스가 관측개체간의 거리가 아니라 오로지 인접성에 의거해 발생하는 경우라면, 데이터는 총빈도 혹은 총계(투표소의 개수, 총매출액)이거나 관측개체의 직접적 속성(예: 투표소의 개방 시간)일 수 있다. 이러한 모든 경우에서 기저의 공간 프로세스를 잘못 재현할 위험성이 상존함은 분명한 사실이다. 특히, 연구지역 전체를 하나의 테셀레이션 체계로 재현하는 경우, 관측값이 기저의 공간적 프로세스를 모두 포착해 낸 것으로 상정되기 때문에 더욱 그러하다. 이러한 측면에서 에어리어 데이터는 지구통계학적 데이터와는 다르다. 후자는 전체 지역에 대해 특정한 방식의 샘플링이 적용되었다는 것을 전제하지만 전자는 그렇지 않다. 또한 생태 및 환경 분석에서 사용되는 에어리어 샘플링과도 다른데, 그러한 샘플링은 지역 전체가 아니라 일부 영역에 대해 선택적으로 이루어진다.\n\n15\\~17장에 걸쳐 에어리어 데이터를 탐색 및 분석하기 위한 기법들이 다루어진다. 이를 위해서는 관측개체 간의 근접성을 나타내는 특정한 방식이 요구된다. 이 장에서는 근접성을 연접성(contiguity)에 의거해 규정하는 방식에 집중한다. 여기서 연접성은 이웃으로 정의된 관측개체들을 서로 연결한 그래프를 통해 규정된다. 이 그래프는 보통 방향성과 가중치가 없지만, 특정 설정에서는 방향과 가중치가 부여될 수도 있으며, 이 경우 대칭성에 대한 추가적인 이슈가 야기될 수 있다. 원칙적으로, 근접성은 공간 상에서 대칭적으로 작동하는 것으로 간주한다. 즉, $i$가 $j$에 미치는 영향과 $j$가 $i$에 미치는 영향은 동일한 것으로 간주한다. 일반적으로 에지 효과(edge effect)는 고려하지 않는다.\n\n## 근접성의 재현: spdep 패키지의 경우\n\n공간적 자기상관을 그래프 상의 이웃들의 관계를 통해 다루는 접근의 경우, 해당 그래프는 주어진 것이고, 그 그래프를 연구자가 선택한 것으로 간주한다. 이것은 지구통계학적 접근과는 다른 것인데, 연구자는 경험적 베리오그램의 거리를 어떻게 나눌 것인지, 어떤 함수를 적용할 것인지, 베리오그램 적합을 어떻게 수행할 것인지를 모두 선택한다. 두 접근법 모두 사전 선택을 포함하지만, 기저의 상관성을 재현하는 방식에서는 서로 다른 것이다(Wall 2004). 그래프에 기반한 이웃 규정 방식을 보다 넓은 맥락에서 설명하는 시도도 존재한다(Bavaud, 1998).\n\n이웃 관계를 나타내는 객체를 생성할 때 이웃이 없는 구역단위의 존재는 문제를 야기한다(Bivand and Portnov 2004). 섬이나 강으로 분리된 구역단위가 이러한 비이웃 구역단위일 수 있는데, 구역단위에 에어리어 스포터가 적용되어 있고 공유 경계와 같은 위상 관계가 사용되는 경우이다. 예를 들어, `mgcv::gam`과 같은 모델 적합 함수에서 `mrf`(마르코프 랜덤 필드) 항을 사용할 때, 방향이 없는 필요하지만, 그래프가 분리된 하위 그래프들로 구성되는 경우 에러가 발생한다.\n\n이러한 무이웃 문제는 포인트 간의 거리로 이웃을 규정하는 경우에도 발생할 수 있는데, 거리 임계값이 최근린 이웃 거리보다 작은 경우가 여기에 해당된다. 공유 경계에 기반한 연접성 규정은 비투영 경위도 좌표를 사용하더라도 영향을 받지 않지만, 모든 포인트 기반 접근법은 어쨌든 거리를 사용하며, 적절한 방식으로 거리를 계산할 필요가 있다.\n\n**spdep** 패키지는 이웃을 규정하는 `nb` 클래스를 제공한다. `nb` 클래스는 관측개체의 수를 길이로 갖는 리스트로 정수 벡터를 구성 요소로 갖는다. 이웃이 없는 경우는 `0L`이 단일 요소로 포함된 정수 벡터로 인코딩된다. 이웃이 있는 경우는 `1L:n` 범위 내의 값이 포함된 정수 벡터로 인코딩되는데, 그 값들은 이웃으로 규정된 관측개체의 인덱스값이다. 이것은 소위 행-기반 희소 재현(row-oriented sparse representation) 방식이다. **spdep** 패키지는 `nb` 객체를 생성하는 다양한 방법을 제공하며, 이 표현과 생성 함수는 다른 패키지에서도 널리 사용된다.\n\n**spdep** 패키지는 `nb` 클래스(무방향 혹은 유방향 그래프)를 통해 `listw` 객체를 구성한다. `listw` 객체는 세 가지 구성 요소를 갖는 리스트로, `nb` 객체, 가중치 리스트, 그리고 가중치 계산 방식을 나타내는 단일 요소 문자 벡터가 포함된다. 사회과학에서 가장 흔히 사용되는 방법은 행 표준화를 통해 가중치를 계산하는 것인데, 개별 관측개체의 한 이웃의 가중치는 해당 관측개체의 이웃의 수(즉 카드널리티)의 역수(즉, `1/card(nb)[i]`)로 변환된다.\n\n이 장에서는 2015년 폴란드 대통령 선거 데이터를 사용하는데, 지역 전체가 2,495개의 지방자치단체와 바르샤바 구역으로 구성되어 있다(그림 14.1 참조). 이 지도는 **tmap** 패키지(8.5절)를 활용해 그려진 것으로 지방자치단체 유형이 표시되어 있다. 구역단위는 `sf` 객체이며, 투표소 단위의 결과를 구역단위로 집계한 데이터이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(pol_pres15, package = \"spDataLarge\")\npol_pres15 |>\n    subset(select = c(TERYT, name, types)) |>\n    head()\n# Simple feature collection with 6 features and 3 fields\n# Geometry type: MULTIPOLYGON\n# Dimension:     XY\n# Bounding box:  xmin: 235000 ymin: 367000 xmax: 281000 ymax: 413000\n# Projected CRS: ETRS89 / Poland CS92\n#    TERYT                name       types\n# 1 020101         BOLESŁAWIEC       Urban\n# 2 020102         BOLESŁAWIEC       Rural\n# 3 020103            GROMADKA       Rural\n# 4 020104        NOWOGRODZIEC Urban/rural\n# 5 020105          OSIECZNICA       Rural\n# 6 020106 WARTA BOLESŁAWIECKA       Rural\n#                         geometry\n# 1 MULTIPOLYGON (((261089 3855...\n# 2 MULTIPOLYGON (((254150 3837...\n# 3 MULTIPOLYGON (((275346 3846...\n# 4 MULTIPOLYGON (((251770 3770...\n# 5 MULTIPOLYGON (((263424 4060...\n# 6 MULTIPOLYGON (((267031 3870...\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap, warn.conflicts = FALSE)\n# Breaking News: tmap 3.x is retiring. Please test v4, e.g. with\n# remotes::install_github('r-tmap/tmap')\ntm_shape(pol_pres15) + tm_fill(\"types\")\n```\n:::\n\n\n![폴란드 구역단위 유형(2015년)](https://r-spatial.org/book/14-Areal_files/figure-html/fig-plotpolpres15-1.png){#fig-14-1}\n\n`sf` 객체의 위상 구조의 유효성을 검토한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!all(st_is_valid(pol_pres15)))\n        pol_pres15 <- st_make_valid(pol_pres15)\n```\n:::\n\n\n2002년 초부터 2019년 4월까지, `spdep`는 이웃 및 공간 가중치 객체를 생성하고 처리하는 함수, 공간적 자기상관을 검정하는 함수, 모델 적합과 관련된 함수 등을 포함하고 있었다. 모델 적합과 관련된 함수는 `spatialreg`로 분리되었으며, 이후 장에서 다룰 예정이다. 현재 `spdep`(Bivand 2022)는 `sf` 클래스와 `sp` 클래스 객체 모두를 지원한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spdep) |> suppressPackageStartupMessages()\n```\n:::\n\n\n## 이웃의 규정: 연접성 기반\n\n**spdep** 패키지의 `poly2nb` 함수는 `pl` 아규먼트를 통해 투입된 객체에서 폴리곤 경계를 구성하고 있는 경계 포인트들을 이용한다. 투입 객체는 일반적으로 `\"POLYGON\"` 또는 `\"MULTIPOLYGON\"` 지오메트리를 가진 `\"sf\"` 또는 `\"sfc\"` 객체이다. 각 관측개체에 대해, 최소한 하나의 포인트(디폴트 퀸 방식, `queen=TRUE`) 또는 최소 두 개의 포인트(루크 방식, `queen=FALSE`)가 `snap` 거리 내에 또 다른 포인트(역자주: 연접 폴리곤의 경계 포인트)를 가지는지를 확인한다. 거리 계산은 투영법에 관계없이 원 길이 단위에 기반한 평면 거리로 이루어진다. 필요한 수의 충분히 가까운 점을 찾으면, 검색이 중단된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(poly2nb)\n```\n:::\n\n\n``` r\n#  function (pl, row.names = NULL, snap = sqrt(.Machine$double.eps),\n#    queen = TRUE, useC = TRUE, foundInBox = NULL)\n```\n\n**spdep** 패키지 1.1-7부터, `poly2nb` 함수는 후보 이웃을 찾고 `foundInBox`를 내부적으로 채우기 위해 **sf** 패키지의 GEOS 인터페이스를 사용한다. 이 경우, **sf** 패키지를 통한 GEOS의 공간 인덱싱(STRtree 쿼리 사용)이 기본값으로 설정된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15 |> poly2nb(queen = TRUE) -> nb_q\n```\n:::\n\n\n`print` 메서드는 이웃 객체의 요약 구조를 표시한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14242 \n# Percentage nonzero weights: 0.229 \n# Average number of links: 5.71\n```\n:::\n\n\n**sf** 패키지 버전 1.0-0부터는 구체 지오메트리를 위해 기본적으로 **s2** 패키지(Dunnington, Pebesma, and Rubak 2023)가 사용된다. 이는 `poly2nb` 함수에서 사용되는 `st_intersects` 함수가 계산을 `s2::s2_intersects_matrix`로 전달하기 때문이다(4장 참조). **spdep** 패키지 버전 1.1-9부터는 `sf_use_s2()`가 `TRUE`일 경우 구체 인터섹션을 사용하여 후보 이웃을 찾는다. GEOS와 마찬가지로, `s2` 라이브러리는 빠른 공간 인덱싱을 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold_use_s2 <- sf_use_s2()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_use_s2(TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(pol_pres15 |> st_transform(\"OGC:CRS84\") -> pol_pres15_ll) |> \n    poly2nb(queen = TRUE) -> nb_q_s2\n```\n:::\n\n\n예시의 경우, 구면 교차와 평면 교차가 동일한 인접 이웃을 생성한다. 두 경우 모두 투입 지오메트리의 유효성이 담보되어야 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(nb_q, nb_q_s2, check.attributes=FALSE)\n# [1] TRUE\n```\n:::\n\n\n`nb` 객체는 대칭적인 이웃 관계인 $i$에서 $j$, $j$에서$i$를 모두 기록하는데, 이는 `nb` 객체가 비대칭적인 관계도 허용하기 때문이다. 그러나 객체 생성에는 이러한 중복이 큰 의미는 없다.\n\n대부분의 **spdep** 패키지 함수는 이웃 객체를 생성할 때 `row.names` 아규먼트를 사용하며, 이 값은 `region.id` 속성으로 저장된다. 만약 `row.names` 아규먼트가 지정되지 않으면, 첫 번째 아규먼트의 `row.names()`에서 가져온다. `region.id` 속성은 `nb` 객체가 원 데이터와 동일한 순서로 정리되어 있는지를 확인하는 데 사용된다. `nb` 객체의 일부만 추출할 경우 인덱스는 `1:length(subsetted_nb)` 범위 내의 값으로 재설정되지만, `region.id` 속성 값을 통해 원본 객체와 정확한 연결 정보를 확인할 수 있다. 이는 17.4절에서 간략하게 논의될 공간적 회귀 모델의 샘플 외 예측에서 사용된다.\n\n`n.comp.nb` 함수를 사용하여 이 비방향 그래프의 연결성을 확인할 수도 있다. 일부 모델 추정 기법은 비연결 그래프를 지원하지 않지만, 비연결 그래프가 야기할 가능한 문제를 인지하고 있는 것은 중요하다(Freni-Sterrantino, Ventrucci, and Rue 2018).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> n.comp.nb())$nc\n# [1] 1\n```\n:::\n\n\n이 접근법은 이웃 객체를 그래프처럼 취급하고 해당 그래프에 대해 그래프 분석을 수행하는 것과 동일하다(Csardi and Nepusz 2006; Nepusz 2022). 먼저 이웃 객체를 이진 희소 행렬로 변환한 후 그래프 분석을 수행한다(Bates, Maechler, and Jagan 2022).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Matrix, warn.conflicts = FALSE)\nlibrary(spatialreg, warn.conflicts = FALSE)\nnb_q |> \n    nb2listw(style = \"B\") |> \n    as(\"CsparseMatrix\") -> smat\nlibrary(igraph, warn.conflicts = FALSE)\n(smat |> graph.adjacency() -> g1) |> \n    count_components()\n# [1] 1\n```\n:::\n\n\n다른 소프트웨어와의 호환성을 위해 이웃 객체를 GAL 형식으로 내보내고 가져올 수 있다. 이를 위해 `write.nb.gal`함수와 `read.gal` 함수가 사용된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntf <- tempfile(fileext = \".gal\")\nwrite.nb.gal(nb_q, tf)\n```\n:::\n\n\n## 이웃의 규정: 그래프 기반\n\n구역단위가 적합한 재현이지만 평면 상의 포인트로 관찰된 경우, 연접성은 그래프 기반 이웃을 사용하여 근사할 수 있다. 이 경우, 평면은 폴리곤 테셀레이션(역자주: 티센폴리곤과 같은 것)으로 분할되는데, 각 폴리곤 내의 모든 지점은 해당 포인트를 가장 가까운 포인트로 갖는다. 가장 간단한 형태는 삼각망 형성(triangulation)을 사용하는 것인데, 여기서는 **deldir** 패키지의 `deldir` 함수를 사용한다. 이 함수는 $i$와 $j$ 식별자를 반환하므로, 세로(긴) 형식으로 `listw` 객체를 구성하는 것이 용이하다. 이는 S-Plus SpatialStats 모듈에서 사용되었던 방식이고, `nb` 객체(가로 형식)를 구성하기 위해 내부적으로 `sn2listw` 함수에서 사용되는 방식이기도 하다. GEOS와 같은 다른 대안들은 이웃의 식별을 위한 충분한 정보를 반환하지 못한다.\n\n이러한 함수들이 리턴한 결과는 `graph2nb` 함수를 통해 `nb` 객체로 전환된다. 이 때 `sym` 아규먼트를 사용하여 이웃 관계의 대칭성을 규정할 수 있다. 그래프 기반 방식을 적용하기 위해 폴리곤의 센트로이드(다중폴리곤의 경우 가장 큰 폴리곤의 센트로이드)를 포인트 재현으로 활용한다. 물론 인구 가중 센트로이드를 구할 수 있다면 더 좋다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15 |> \n    st_geometry() |> \n    st_centroid(of_largest_polygon = TRUE) -> coords \n(coords |> tri2nb() -> nb_tri)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14930 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 5.98\n```\n:::\n\n\n평균 이웃수의 측면에서 보면 퀸 방식의 경계 연접성과 유사한 결과가 나왔다. 그러나 `nbdists()` 함수를 사용하여 엣지 길이의 분포를 살펴보면, 상위 4분위 수는 약 15km 정도이지만 최대값은 거의 300km에 달한다는 것을 알 수 있다. 이는 전체 지역을 포괄하는 컨벡스 헐의 한쪽 면의 길이에 버금가는 것이다. 최소 거리 역시 중요하다. 왜냐하면 많은 도시 구역의 센트로이드가 주변 농촌 구역의 센트로이드와 매우 근접해 있기 때문이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_tri |> \n    nbdists(coords) |> \n    unlist() |> \n    summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    9847   12151   13485   14994  296974\n```\n:::\n\n\n삼각망에 의거한 이웃 규정도 연결 그래프(역자주: 그래프 상의 모든 지점이 직간접적으로 연결되어 있는 그래프)를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_tri |> n.comp.nb())$nc\n# [1] 1\n```\n:::\n\n\n그래프 기반 접근법에는 `soi.graph`, `relativeneigh`, `gabrielneigh`와 같은 것들이 있다. 여기서는 `soi.graph`만 살펴본다.\n\n`soi.graph` 함수에서 soi는 영향권(sphere of influence)의 약자이다. 이 함수는 삼각망 이웃에서 비정상적으로 긴 엣지로 표현된 이웃 관계는 제거함으로써 실질적인 의미를 가진 이웃 관계만 남긴다. 이러한 비정상적으로 긴 엣지는 컨벡트 헐의 가장 자리에서 흔히 나타나는 것이다(Avis and Horton, 1985).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_tri |> \n        soi.graph(coords) |> \n        graph2nb() -> nb_soi)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 12792 \n# Percentage nonzero weights: 0.205 \n# Average number of links: 5.13\n```\n:::\n\n\n그러나 삼각망에 의거한 이웃 관계의 일부를 해체하면, 연결 그래프로서의 전체적인 성격은 사라지게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_soi |> n.comp.nb() -> n_comp)$nc\n# [1] 16\n```\n:::\n\n\n이 알고리즘은 비정상적으로 긴 엣지를 제거하도록 설계되었지만, 농촌 구역들이 하나의 도시 구역을 완전히 둘러싸고 있는 경우 매우 가까운 도시-농촌 쌍의 엣지도 잘못 삭제될 수 있다. 이러한 결과로 15개의 도시-농촌 쌍이 메인 그래프로부터 분리되는 결과가 초래된 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(n_comp$comp.id)\n# \n#    1    2    3    4    5    6    7    8    9   10   11   12   13 \n# 2465    2    2    2    2    2    2    2    2    2    2    2    2 \n#   14   15   16 \n#    2    2    2\n```\n:::\n\n\n컨벡스 헐에서 가장 긴 엣지들이 제거되었지만, 연결되지 않은 이웃 쌍들이 나타나면서 \"구멍\"이 생겼다. `nb_tri`와 `nb_soi`의 차이는 그림 14.2에서 주황색으로 표시되었다.\n\n![삼각망 이웃(오렌지색과 검은색)과 영향권 이웃(검은색)의 비교. 군데군데 구멍이 형성되어 있는데, 모두 도시 구역이 농촌 구역으로 완전히 둘러싸여 있는 경우(그림 14.1 참조)에 해당한다.](https://r-spatial.org/book/14-Areal_files/figure-html/fig-plotnbdiff-1.png)\n\n## 이웃의 규정: 거리 기반\n\n거리 기반 이웃은 `dnearneigh`를 사용하여 생성할 수 있다. `bounds` 아규먼트를 통해 거리 구간을 설정할 수 있는데, `d1`과 `d2`는 각각 거리의 하한값과 상한값이다. 경위도 좌표계가 사용되고, 좌표 객체 `x`가 주어지고, `longlat=TRUE`로 설정된 경우, WGS84 기준 타원체를 가정하여 킬로미터 단위의 대권 거리를 계산한다. `use_s2=TRUE`(기본값)로 설정되면 구체를 상정한 거리 계산을 한다(4장 참조). `dwithin`이 `FALSE`이고 **s2** 버전이 1.0.7보다 크면 `s2_closest_edges`가 사용될 수 있으며, `dwithin`이 `TRUE`이고 `use_s2=TRUE`이면 `s2_dwithin_matrix`가 사용된다. 이 두 방법 모두 빠른 구형 공간 인덱싱을 사용하긴 하지만, `s2_closest_edges`의 경우는 최소 및 최대 경계를 지정하기 때문에 `dnearneigh`의 R 코드에서 한 번의 실행만으로 충분하다.\n\n**dbscan** 패키지(Hahsler and Piekenbrock 2022)에 새로운 아규먼트를 추가함으로써 2차원 또는 3차원에서 평면 공간 인덱싱을 사용하여 이웃을 찾는 기능이 보강되었고 대칭성 을 확인하는 절차가 필요없게 되었다. 또한, 구면 기하학적 거리 측정을 사용하는 세 가지 아규먼트도 추가되었다.\n\n$k$-최근린 이웃을 위한 `knearneigh` 함수는 `knn` 객체를 반환하며, `knn2nb`를 사용해 `nb` 객체로 전환된다. 이 함수는 구면 거리도 사용할 수 있는데, 평면 거리와는 다른 최근린 이웃이 산출될 수 있기 때문이다. $k$는 작은 숫자여야 한다. 투영 좌표의 경우 `dbscan` 패키지를 사용하여 최근접 이웃을 더 효율적으로 계산한다. 이렇게 생성된 `nb` 객체는 대개 대칭적이지 않으므로, `knn2nb`는 대칭성을 강제할 수 있는 `sym` 아규먼트를 제공한다. 대칭성을 강제하면 모든 단위가 최소 $k$개의 이웃을 가지게 되지만, 모든 단위가 정확히 $k$개의 이웃을 갖는 것은 아니다. `sf_use_s2()`가 `TRUE`인 경우, 입력 객체가 `\"sf\"` 또는 `\"sfc\"` 클래스일 때 `knearneigh`는 빠른 구형 공간 인덱싱을 사용한다.\n\n`nbdists` 함수는 투영 좌표의 경우 좌표 단위로 이웃 관계 엣지의 길이를 반환하고, 그렇지 않으면 킬로미터 단위로 반환한다. 거리 밴드의 상한을 설정하려면 먼저 첫 번째 최근린 이웃 거리의 최대값을 찾아야 하며, 이때 반환된 객체의 리스트 구조를 제거하기 위해 `unlist`를 사용할 수 있다. `sf_use_s2()`가 `TRUE`인 경우, `nbdists`는 입력 객체가 `\"sf\"` 또는 `\"sfc\"` 클래스일 때 빠른 구형 거리 계산을 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords |> \n    knearneigh(k = 1) |> \n    knn2nb() |> \n    nbdists(coords) |> \n    unlist() |> \n    summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    6663    8538    8275   10124   17979\n```\n:::\n\n\n여기서 첫 번째 최근린 이웃 거리의 최대값은 약 18km로, 이를 상한선으로 사용하면 모든 단위가 최소한 하나의 이웃을 가지게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords |> dnearneigh(0, 18000) -> nb_d18\n```\n:::\n\n\n사례에서 보는 것처럼 관측개체의 수가 그리 많지 않은 경우에는 공간 인덱싱을 사용해도 실행 시간에서 큰 이점을 얻지 못한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords |> dnearneigh(0, 18000, use_kd_tree = FALSE) -> nb_d18a\n```\n:::\n\n\n그리고 산출 객체도 동일하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(nb_d18, nb_d18a, check.attributes = FALSE)\n# [1] TRUE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_d18\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 20358 \n# Percentage nonzero weights: 0.327 \n# Average number of links: 8.16\n```\n:::\n\n\n그런데 이웃이 없는 관측값은 없지만(이들은 `nb` 객체의 print 메소드에서 보고됨), 그래프는 완전 연결 상태가 아니다. 왜냐하면 한 쌍의 관측개체가 서로의 유일한 이웃이기 때문이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_d18 |> n.comp.nb() -> n_comp)$nc\n# [1] 2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(n_comp$comp.id)\n# \n#    1    2 \n# 2493    2\n```\n:::\n\n\n임계값에 300m를 추가하면 비이웃 관측단위가 없는 이웃 객체가 생성되고, 모든 관측단위는 그래프를 통해 다른 모든 관측단위에 도달할 수 있게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords |> dnearneigh(0, 18300) -> nb_d183)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21086 \n# Percentage nonzero weights: 0.339 \n# Average number of links: 8.45\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_d183 |> n.comp.nb())$nc\n# [1] 1\n```\n:::\n\n\n거리 기반 이웃의 한 특징은 면적이 작은 단위들이 밀집된 지역일수록 더 많은 이웃을 갖는다는 것이다(예를 들어, 바르샤바 구역은 평균적으로 훨씬 작지만, 이 거리 기준으로 약 30개의 이웃을 가진다). 많은 이웃을 갖는 것은 이웃 관계를 더 많은 이웃을 통해 부드럽게 만든다.\n\n나중에 사용할 수 있도록, 16km의 임계값을 사용하여 비이웃 단위가 포함된 이웃 객체도 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords |> dnearneigh(0, 16000) -> nb_d16)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 15850 \n# Percentage nonzero weights: 0.255 \n# Average number of links: 6.35 \n# 7 regions with no links:\n# 569 1371 1522 2374 2385 2473 2474\n```\n:::\n\n\n$k$-최근린 이웃을 사용하여 이웃의 수를 직접적으로 제어할 수 있으며, 이때 비대칭 이웃을 허용할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n((coords |> knearneigh(k = 6) -> knn_k6) |> knn2nb() -> nb_k6)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14970 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 6 \n# Non-symmetric neighbours list\n```\n:::\n\n\n또는 대칭성을 강제할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(knn_k6 |> knn2nb(sym = TRUE) -> nb_k6s)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 16810 \n# Percentage nonzero weights: 0.27 \n# Average number of links: 6.74\n```\n:::\n\n\n여기서 $k$의 크기는 완전 연결성을 보장하기에 충분하지만, 그래프가 반드시 평면성을 가지는 것은 아니다. 엣지가 노드가 아닌 다른 위치에서 교차하기 때문이다. 이는 연접성 기반 이웃이나 그래프 기반 이웃에서는 발생하지 않는 상황이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_k6s |> n.comp.nb())$nc\n# [1] 1\n```\n:::\n\n\n구체 상의 포인트들인 경우(4장에서 참조), `st_centroid`의 출력은 달라지므로, 포인트들을 역 투영하는 대신 역 투영된 폴리곤 지오메트리에서 경위도 좌표로 포인트들을 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold_use_s2 <- sf_use_s2()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_use_s2(TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15_ll |> \n    st_geometry() |> \n    st_centroid(of_largest_polygon = TRUE) -> coords_ll\n```\n:::\n\n\n구면 좌표의 경우, 거리 경계는 킬로미터 단위로 표시된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords_ll |> dnearneigh(0, 18.3, use_s2 = TRUE, \n                         dwithin = TRUE) -> nb_d183_ll)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21140 \n# Percentage nonzero weights: 0.34 \n# Average number of links: 8.47\n```\n:::\n\n\n이 이웃들은 예상대로 구면 18.3 km 이웃들과 다르다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisTRUE(all.equal(nb_d183, nb_d183_ll, check.attributes = FALSE))\n# [1] FALSE\n```\n:::\n\n\n**s2**가 더 빠른 거리 이웃 인덱싱을 제공할 수 있다면, 디폴트로 `s2_closest_edges`가 경위도 좌표에 대해 사용된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords_ll |> dnearneigh(0, 18.3) -> nb_d183_llce)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 21140 \n# Percentage nonzero weights: 0.34 \n# Average number of links: 8.47\n```\n:::\n\n\n이 경우에는 두 **s2** 기반 이웃 객체가 동일하다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisTRUE(all.equal(nb_d183_llce, nb_d183_ll,\n                 check.attributes = FALSE))\n# [1] TRUE\n```\n:::\n\n\n**s2**에서 빠른 구형 공간 인덱싱을 사용하여 $k$개의 최근린 이웃을 찾는다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(coords_ll |> knearneigh(k = 6) |> knn2nb() -> nb_k6_ll)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14970 \n# Percentage nonzero weights: 0.24 \n# Average number of links: 6 \n# Non-symmetric neighbours list\n```\n:::\n\n\n이 이웃들은 예상대로 평면 `k=6` 최근접 이웃과 다르지만, 전통적인 브루트포스(brute-force) 타원체 거리와도 약간 다를 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisTRUE(all.equal(nb_k6, nb_k6_ll, check.attributes = FALSE))\n# [1] FALSE\n```\n:::\n\n\n`nbdists` 함수 역시 구면 상의 거리를 계산하기 위해 **s2**를 사용하는데, `\"sf\"` 또는 `\"sfc\"` 투입 객체가 경위도 좌표값을 가지는 경우에 그러하다(반환된 거리는 킬로미터 단위로 표시).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q |> nbdists(coords_ll) |> unlist() |> summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     0.2     9.8    12.2    12.6    15.1    33.0\n```\n:::\n\n\n평면 좌표가 사용될 때와 구형 혹은 타원체 지오메트리가 사용할 때, 동일한 가중치 객체인 경우에도 계산되는 거리 값이 약간 다르다(평면 지오메트리의 경우 포인트의 단위로 거리가 반환되고, 타원체 및 구형 지오메트리의 경우 킬로미터 단위로 거리가 반환된다).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q |> nbdists(coords) |> unlist() |> summary()\n#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#     247    9822   12173   12651   15117   33102\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_use_s2(old_use_s2)\n```\n:::\n\n\n## 가중치 부여\n\n이웃 객체를 기반으로 가중치 객체를 지정한다. 여기에 몇 가지 선택이 이루어져야 한다. `nb2listw` 함수는 `nb` 객체에 기반하여 `listw` 가중치 객체를 생성한다. 가중치 객체는 가중치 벡터 리스트와 스타일 선택값으로 구성된다. 비이웃 관측개체의 처리가 중요한 사안인데 `zero.policy` 아규먼트가 이를 담당한다. 디폴트는 FALSE로 설정되어 있으며, 이는 비이웃 관측개체의 존재가 오류를 발생시킨다는 것을 의미한다. 관측개체가 이웃을 가지지 않으면 공간지체값(spatially lagged values)을 사용할 수 없기 때문이다. 보통 비관측개체의 경우 공간지체값으로 제로가 부여되는데, 이는 제로 값의 가중치 벡터와 데이터 벡터의 교차곱과 같기 때문에 `zero.policy`라는 이름이 붙여졌다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(nb2listw)\n```\n:::\n\n\n``` r\n#  function (neighbours, glist = NULL, style = \"W\", zero.policy =\n#    NULL)\n```\n\n우리는 스타일 선택을 변경했을 때의 결과를 보여주기 위해 아래에서 도우미 함수 `spweights.constants`를 사용할 것이다. 이 함수는 `listw` 객체에 대한 상수 값들을 반환한다. 여기서 $n$은 관측개체의 수이고, `n1`부터 `n3`은 $n-1,...,$ `nn`은 $n^2$이며, $S_0$, $S_1$, $S_2$는 상수이다. $S_0$는 가중치의 합이다. 상수에 대한 자세한 논의는 Bivand와 Wong (2018)를 참고하면 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(spweights.constants)\n```\n:::\n\n\n``` r\n#  function (listw, zero.policy = NULL, adjust.n = TRUE)\n```\n\n`\"B\"` 바이너리 스타일은 이웃 관계에 대해 단위 값(1)을 부여하며, 이웃의 규정을 위한 경계가 존재하는 가장자리 구역단위에 비해 더 많은 이웃을 가질 수 있는 내부 구역에 더 높은 가중치를 부여한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> \n    nb2listw(style = \"B\") -> lw_q_B) |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select = c(n, S0, S1, S2))\n#      n    S0    S1     S2\n# 1 2495 14242 28484 357280\n```\n:::\n\n\n`\"W\"` 행표준화 스타일은 연구 지역의 가장자리에 위치하여 반드시 더 적은 수의 이웃을 가질 수 밖에 없는 구역단위에 더 높은 가중치를 부여한다. 행표준화 스타일은 먼저 각 이웃 관계에 대해 단위 값을 가중치로 부여한 후, 이 가중치를 각 구역단위의 가중치 합으로 나눈다. 비이웃 구역단위에서는 0을 0으로 나누게 되므로 \"부정(not-a-number)\"의 결과가 발생하게 된다. 물론 `zero.policy`를 `TRUE`로 설정한 경우에는 문제가 없다. 행표준화 스타일에서는 $S_0$는 $n$과 같아진다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> \n        nb2listw(style = \"W\") -> lw_q_W) |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select = c(n, S0, S1, S2))\n#      n   S0  S1    S2\n# 1 2495 2495 958 10406\n```\n:::\n\n\n역거리 가중치는 많은 애플리케이션에서 사용된다. 밀집된 역거리 행렬이 사용되는 경우 많은 역거리가 거의 0에 가깝고, 특히 공간 프로세스 행렬 자체가 밀집되어 있는 경우 실제적인 의미는 미약하다. 역거리 가중치는 보통의 다음의 절차를 통해 생성된다. 우선 엣지의 길이를 산출하고, 단위를 바꾸고(예시의 경우 미터에서 킬로미터로 변환)어 가중치가 너무 크거나 작지 않도록 하고, 그 값을 역수로 바꾼 후, `nb2listw`의 `glist` 인자를 통해 전달한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_d183 |> \n    nbdists(coords) |> \n    lapply(function(x) 1/(x/1000)) -> gwts\n(nb_d183 |> nb2listw(glist=gwts, style=\"B\") -> lw_d183_idw_B) |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select=c(n, S0, S1, S2))\n#      n   S0  S1   S2\n# 1 2495 1841 534 7265\n```\n:::\n\n\n비이웃 단위의 경우 디폴트로 가중치 객체가 생성되지 않는다. 이를 통해 분석가가 이후 과정을 결정할 수 있게 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(nb_d16 |> nb2listw(style=\"B\") -> lw_d16_B)\n# Error in nb2listw(nb_d16, style = \"B\") : Empty neighbour sets found\n```\n:::\n\n\n`nb`와 `listw` 객체와 관련된 많은 함수에서는 `zero.policy` 아규먼트를 활용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_d16 |> \n    nb2listw(style=\"B\", zero.policy=TRUE) |> \n    spweights.constants(zero.policy=TRUE) |> \n    data.frame() |> \n    subset(select=c(n, S0, S1, S2))\n#      n    S0    S1     S2\n# 1 2488 15850 31700 506480\n```\n:::\n\n\n`spweights.constants` 함수의 `adjust.n` 아규먼트는 디폴트로 TRUE로 설정되어 있어, 비이웃 관측개체 수를 차감하기 때문에 $n$이 작아지며, 통계적 추론에 영향을 미칠 수 있다. 원래 $n$은 아규먼트를 다르게 지정하면 알 수 있다.\n\n## 고차 이웃의 규정\n\n앞에서 살펴본 것처럼 퀸 인접성 기반 이웃 객체의 특성은 다음과 같다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 14242 \n# Percentage nonzero weights: 0.229 \n# Average number of links: 5.71\n```\n:::\n\n\n$i$가 $j$의 이웃이고, $j$가 $k$의 이웃인 경우, 즉 이웃 그래프에서 두 단계를 거쳐 $i$에서 $k$까지의 이웃을 나타내는 객체를 만들고자 한다면, `nblag`를 사용할 수 있다. 이 함수는 자동으로 $i$ 에서 $i$로 가는 자기 이웃을 제거한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> nblag(2) -> nb_q2)[[2]]\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 32930 \n# Percentage nonzero weights: 0.529 \n# Average number of links: 13.2\n```\n:::\n\n\n`nblag_cumul` 함수는 주어진 모든 차원의 이웃 목록을 누적한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnblag_cumul(nb_q2)\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 47172 \n# Percentage nonzero weights: 0.758 \n# Average number of links: 18.9\n```\n:::\n\n\n`union.nb` 집합 연산은 두 개의 객체를 받아들이며, 여기서는 동일한 결과를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunion.nb(nb_q2[[2]], nb_q2[[1]])\n# Neighbour list object:\n# Number of regions: 2495 \n# Number of nonzero links: 47172 \n# Percentage nonzero weights: 0.758 \n# Average number of links: 18.9\n```\n:::\n\n\n앞에서 이웃 객체를 그래프 재현으로 전환하였는데, 해당 그래프 객체를 이용하면 그래프를 탐색하는 데 몇 단계가 필요한지에 대한 정보를 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiameter(g1)\n# [1] 52\n```\n:::\n\n\n각 관측개체에서 그래프를 통해 가장 짧은 경로로 도달하는 데 필요한 단계 수를 계산하여 $n \\times n$ 크기의 `sps` 행렬을 생성한다. 이를 통해 동일한 최대 값을 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng1 |> shortest.paths() -> sps\n(sps |> apply(2, max) -> spmax) |> max()\n# [1] 52\n```\n:::\n\n\n최대 값을 가진 지방자치단체는 Lutowiska로, 남동부의 말단부에 위치해 우크라이나와 국경을 맞대고 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmr <- which.max(spmax)\npol_pres15$name0[mr]\n# [1] \"Lutowiska\"\n```\n:::\n\n\n그림 14.3은 연접성 기반 이웃과 거리 기반 이웃이 매우 유사하다는 점을 잘 보여준다. 어떤 경우에는 거리 기반 이웃 방법이 선호된다. 왜냐하면 모든 관측개체가 다른 모든 관측개체와 관련된다는 점을 명확히 보여주기 때문이다. 그러나 공간적 자기상관 및 공간 회귀 모델을 위한 검정은 공간적 프로세스 모델의 역(inverse)을 사용하고, 이것은 회귀계수의 벡터와 공간가중행렬의 곱을 여러번 더한 합이므로, 결국 모든 관측개체와 다른 모든 관측개체 간의 관계가 이러한 과정 속에 포함될 수 밖에 없다. 희소 연접 이웃 객체를 사용하면 이러한 복잡한 관계를 명시적으로 만들 필요 없이 풍부한 의존성 구조를 표현할 수 있다.\n\n![Lutowiska에 이르는 최단 경로 수와 Lutowiska까지의 거리의 관련성. 왼쪽은 Lutowiska에 이르는 최단 경로 수를 나타낸 지도이고, 오른쪽은 Lutowiska에 이르는 최단 경로 수와 Lutowiska까지의 거리의 관계를 나타낸 그래프이다.](https://r-spatial.org/book/14-Areal_files/figure-html/fig-shortestpath-1.png){#fig-14-3}\n\n## 연습문제\n\n1.  어떤 종류의 지오메트리 스포트가 이웃 객체를 생성하는 함수에 적합한가?\n\n2.  이웃 객체를 생성하는 함수 중 어떤 것이 평면 재현에만 적합한가?\n\n3.  체스판에서 `queen` 연접성 대신 `rook` 연접성을 선택하면 어떤 차이가 발생하는가?\n\n4.  이웃 집합의 카디널리티(이웃 수)와 행표준화 가중치 사이에는 어떤 관계가 있으며, 이것이 어떻게 엣지 효과(edge effect) 분석을 가능하게 하는가? 연습문제 3에서 만든 체스판을 사용하고, `rook`와 `queen` 이웃 각각에 대해 설명하라.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}