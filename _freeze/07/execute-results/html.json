{
  "hash": "c084c75bc1b7935f66b0a3b6cf7259a2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n# sf와 stars {#sec-sf-stars}\n\n이 장에서는 R 패키지인 **sf**와 **stars**를 소개한다. **sf**는 피처의 기하 정보를 리스트-컬럼에 저장하는 단순 피처의 테이블 포맷을 제공한다. **stars** 패키지는 래스터와 벡터 데이터 큐브(6장에서 다룸)를 지원하기 위해 작성되었으며, 래스터 레이어, 래스터 스택 및 피처 시계열 또한 지원한다. **sf**는 2016년에 CRAN에 처음 등장했고, **stars**는 2018년에 등장했다. 두 패키지의 개발은 R 컨소시엄의 지원과 강력한 커뮤니티 참여로 이루어졌다. 이 패키지들은 함께 작동하도록 설계되었다. **sf**나 **stars** 객체를 대상으로 하는 함수 또는 메서드는 `st_`로 시작하는데, 쉽게 관련 함수를 인식할 수 있을 뿐만 아니라 명령어 완성 기능을 사용할 때 검색의 용이함이 있다.\n\n## sf 패키지 {#sec-sf}\n\nR 패키지 **sf**(Pebesma 2018)는 기존의 R 패키지인 **sp**, r**geos** 및 **rgdal**의 벡터 부분을 대체하고 성공적으로 이어받기 위해 개발되었으며, 산업계 및 오픈 소스 프로젝트에서 볼 수 있는 표준 기반 접근법에 더 가까이 다가가고, 최신 버전의 오픈소스 지리공간 소프트웨어 스택(그림 1.7)을 기반으로 하며, 필요 시 R 공간 소프트웨어와 타이디버스(Wickham et al. 2019)의 통합을 가능하게 한다.\n\n이를 위해 **sf**는 R에 네이티브로 심플 피처 접근(Herring et al. 2011)을 제공한다. 이 패키지는 여러 타이디버스 패키지, 특히 **ggplot2**, **dplyr**, **tidyr**와의 인터페이스를 제공하며, GDAL을 통해 데이터를 읽고 쓰고, GEOS(투영 좌표의 경우) 또는 s2geometry(타원체 좌표의 경우)를 사용하여 기하학적 연산을 수행하며, PROJ를 이용해 좌표 변환 또는 좌표 전환 작업을 수행할 수 있다. 외부 C++ 라이브러리와의 인터페이싱(연결)은 **Rcpp** 패키지(Eddelbuettel 2013)를 통해 이루어진다.\n\n**sf**는 `sf` 객체로 심플 피처를 나타내며, 이는 `data.frame` 또는 티블(tibble)의 하위 클래스이다. `sf` 객체는 최소 하나 이상의 `sfc` 클래스의 지오메트리 *리스트 열*(list-column)을 포함하는데, 각 요소는 `sfg` 클래스의 R 객체로서 지오메트리 정보를 담고 있다. 지오메트리 리스트 열은 `data.frame` 또는 티블 내에서 변수처럼 작동하지만, 숫자나 문자형 변수와 같은 기본 벡터보다 더 복잡한 구조를 가지고 있다(부록 B.3 참조).\n\n`sf` 객체는 다음과 같은 메타데이터를 가진다.\n\n-   (활성화된) 지오메트리 열의 이름: `sf_column` 속성에 저장되어 있음.\n\n-   각 비기하 변수의 속성-지오메트리 관계 (5.1절 참조): `agr` 속성에 저장되어 있음.\n\n`sfc` 지오메트리 리스트 열은 `st_geometry`함수를 통해 `sf` 객체에서 추출되며, 다음과 같은 메타데이터를 가진다\n\n-   좌표참조계: `crs` 속성에 저장되어 있음.\n\n-   바운딩 박스: `bbox` 속성에 저장되어 있음.\n\n-   정밀도: `precision` 속성에 저장되어 있음.\n\n-   지오메트리 수: `n_empty` 속성에 저장되어 있음.\n\n이러한 속성들의 값을 확인하거나 수정하기 위해 `st_bbox`, `st_crs`, `st_set_crs`, `st_agr`, `st_set_agr`, `st_precision`, `st_set_precision` 같은 함수를 사용할 수 있다.\n\n### 생성\n\n다음과 같은 방식으로 `sf` 객체를 생성할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\np1 <- st_point(c(7.35, 52.42))\np2 <- st_point(c(7.22, 52.18))\np3 <- st_point(c(7.44, 52.19))\nsfc <- st_sfc(list(p1, p2, p3), crs = 'OGC:CRS84')\nst_sf(elev = c(33.2, 52.1, 81.2), \n      marker = c(\"Id01\", \"Id02\", \"Id03\"), geom = sfc)\n# Simple feature collection with 3 features and 2 fields\n# Geometry type: POINT\n# Dimension:     XY\n# Bounding box:  xmin: 7.22 ymin: 52.2 xmax: 7.44 ymax: 52.4\n# Geodetic CRS:  WGS 84\n#   elev marker              geom\n# 1 33.2   Id01 POINT (7.35 52.4)\n# 2 52.1   Id02 POINT (7.22 52.2)\n# 3 81.2   Id03 POINT (7.44 52.2)\n```\n:::\n\n\n![sf 객체의 구조](https://r-spatial.org/book/images/sf_obj.png){#fig-7-1}\n\n그림 7.1은 출력된 구성 요소에 대한 설명을 제공한다. 객체를 처음부터 생성하는 대신, R에서의 공간데이터는 보통 외부 소스에서 읽어오며, 그 외부 소스에는 다음과 같은 것이 있다.\n\n-   외부 파일\n\n-   데이터베이스 내의 테이블(또는 테이블 집합)\n\n-   웹서비스에서 호출을 통해 획득된 데이터셋\n\n-   R 패키지에 포함되어 있는 데이터셋\n\n### 읽기와 쓰기\n\n외부 \"데이터 소스\"(파일, 웹서비스 또는 문자열)로부터 데이터셋을 읽어오는 것은 `st_read()` 함수를 사용하여 수행된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n(file <- system.file(\"gpkg/nc.gpkg\", package = \"sf\"))\n# [1] \"/home/edzer/R/x86_64-pc-linux-gnu-library/4.3/sf/gpkg/nc.gpkg\"\nnc <- st_read(file)\n# Reading layer `nc.gpkg' from data source \n#   `/home/edzer/R/x86_64-pc-linux-gnu-library/4.3/sf/gpkg/nc.gpkg' \n#   using driver `GPKG'\n# Simple feature collection with 100 features and 14 fields\n# Geometry type: MULTIPOLYGON\n# Dimension:     XY\n# Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6\n# Geodetic CRS:  NAD27\n```\n:::\n\n\n여기서 파일 이름과 경로는 sf 패키지에서 읽어오는 것인데, sf 패키지를 설치하는 과정에서 설정된 것이므로 어떤 컴퓨터에서건 예외없이 읽어들여진다.\n\n`st_read()` 명령어는 두 개의 아규먼트(*데이터 소스 이름*(dsn)과 *레이어*(layer))를 가진다. 위의 예에서 *geopackage*(GPKG) 파일은 단일 레이어만 포함하고 있으며, 해당 레이어가 불러들여진 것이다. 만약 여러 레이어가 포함되어 있었다면, 첫 번째 레이어가 읽히고 경고 메시지가 표출되었을 것이다. 데이터셋의 사용 가능한 레이어는 다음과 같이 조회할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_layers(file)\n# Driver: GPKG \n# Available layers:\n#   layer_name geometry_type features fields crs_name\n# 1    nc.gpkg Multi Polygon      100     14    NAD27\n```\n:::\n\n\n심플 피처 객체는 `st_write` 함수를 사용하여 저장할수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(file = tempfile(fileext = \".gpkg\"))\n# [1] \"/tmp/Rtmpm9lGRF/file361e653fae4a9.gpkg\"\nst_write(nc, file, layer = \"layer_nc\")\n# Writing layer `layer_nc' to data source \n#   `/tmp/Rtmpm9lGRF/file361e653fae4a9.gpkg' using driver `GPKG'\n# Writing 100 features with 14 fields and geometry type Multi Polygon.\n```\n:::\n\n\n여기서 파일 형식(GPKG)은 파일 이름 익스텐션에서 파생된다. `st_write()` 함수의 `append` 아규먼트 설정을 통해 기존 레이어에 레코드를 추가하거나 아예 레이어를 교체할 수 있는데, `append` 아규먼트 설정되지 않으면 레이어가 이미 존재할 경우 오류가 발생한다. 타이디버스 스타일의 `write_sf()` 함수는 `append`가 설정되지 않은 경우 오류 표출 없이 레이어를 교체한다. 또한, `st_delete()` 함수를 사용하여 레이어를 삭제할 수 있으며, 이는 특히 데이터베이스의 테이블과 연결되어 있는 레이어를 다룰 때 편리하다.\n\nWKT-2 좌표참조계를 지원하는 파일 형식의 경우, `st_read()`와 `st_write()`는 이를 읽고 쓸 수 있다. 그러나 `csv`와 같은 간단한 포맷에서는 이 기능이 작동하지 않는다. 또한, 셰이프파일(shapefile) 형식은 CRS에 대해 매우 제한된 인코딩만 지원한다.\n\n### 부분을 골라내기\n\n매우 일반적인 작업 중 하나는 객체의 일부분을 골라내기(subset)하는 것이며, 베이스 R에서는 이를 위해 대괄호 기호(\\[) 를 사용한다. `data.frame` 객체에 적용되는 규칙을 sf 객체에 그대로 적용할 수 있다. 예를 들어, 다음과 같은 코드를 통해 레코드 2에서 5와 열 3에서 7을 선택할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc[2:5, 3:7]\n```\n:::\n\n\n여기에 몇몇 옵션을 부가적으로 적용할 수 있다.\n\n-   `drop` 아규먼트가 디폴트로 FALSE로 설정되어 있는데, 지오메트리 열이 *항상* 선택되며 `sf` 객체가 반환된다. TRUE로 설정되면, 지오메트리열이 선택되지 않으면 해당 열이 제거된 `data.frame`이 반환된다.\n\n-   공간(`sf`, `sfc` 또는 `sfg`) 객체를 첫 번째 아규먼트로 사용한 선택은 해당 객체와 공간적으로 *교차*하는 피처를 선택하는 결과를 가져온다(다음 절 참조). 다른 프레디케이트를 선택하고자 할 경우, **op** 아규먼트를 설정하여 `st_covers`와 같은 함수 또는 3.2.2절에 나열된 다른 이항 프레디케이트 함수로 지정할 수 있다.\n\n### 바이너리 프레디케이트\n\n`st_intersects`, `st_covers`와 같은 이항 프레디케이트 함수(3.2.2절 참조)는 두 개의 피처 집합 또는 피처 지오메트리를 입력받아 모든 쌍에 대해 조건이 TRUE인지 FALSE인지를 반환한다. 대규모 집합의 경우, 이는 일반적으로 대부분 FALSE 값으로 채워진 거대한 행렬을 생성할 수 있으며, 이러한 이유로 기본적으로 희소 표현(sparse representation)이 반환된다(역자주: 희소 표현은 메모리 사용을 최적화하고, 데이터 처리를 더욱 효율적으로 만들어 준다. 희소 표현을 일반적으로 TRUE 값만을 저장하고, FALSE 값은 저장하지 않는다.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc5 <- nc[1:5, ]\nnc7 <- nc[1:7, ]\n(i <- st_intersects(nc5, nc7))\n# Sparse geometry binary predicate list of length 5, where the\n# predicate was `intersects'\n#  1: 1, 2\n#  2: 1, 2, 3\n#  3: 2, 3\n#  4: 4, 7\n#  5: 5, 6\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n![노스케롤라이나의 첫 7개의 카운티](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-fig57-1.png){#fig-7-2}\n\n그림 7.2는 첫 다섯 개 카운티와 첫 일곱 개 카운티의 교차를 이해하는 방법을 보여준다. 다음과 같은 방식으로 희소 논리 행렬을 조밀한 행렬(dense matrix)로 변환할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.matrix(i)\n#       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]\n# [1,]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n# [2,]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n# [3,] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n# [4,] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE\n# [5,] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n```\n:::\n\n\n`nc5`의 개별 카운티가 교차하는 `nc7` 카운티의 수는 다음과 같이 계산할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlengths(i)\n# [1] 2 3 2 2 2\n```\n:::\n\n\n역으로 `nc7`의 개별 카운티가 교차하는 `nc5`의 카운티의 수는 다음과 같이 계산할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlengths(t(i))\n# [1] 2 3 2 1 1 1 1\n```\n:::\n\n\n객체 `i` 가 `sgbp`(sparse geometrical binary predicate) 클래스의 한 객체라고 했을 때, 객체 `i`는 정수 벡터의 리스트로 주어지는데, 리스트의 각 요소는 논리 프레디케이트 행렬의 한 행을 나타내고, 논리 프레디케이트 행렬은 해당 행에 대해 TRUE 값을 갖는 열의 인덱스를 보유하고 있다. 이 객체는 사용된 프레디케이트 및 총 열 수와 같은 메타데이터도 포함하고 있다. sgbp 객체에 적용할 수 있는 메소드에 다음과 같은 것들이 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = \"sgbp\")\n#  [1] as.data.frame as.matrix     coerce        dim          \n#  [5] initialize    Ops           print         show         \n#  [9] slotsFromS3   t            \n# see '?methods' for accessing help and source code\n```\n:::\n\n\n`sgbp` 클래스의 객체에서 사용 가능한 유일한 `Ops` 메서드는 `!`(부정 연산자)이다.\n\n### 타이디버스\n\n**tidyverse** 패키지는 다양한 데이터사이언스 패키지를 함께 로드한다(Wickham and Grolemund 2017; Wickham et al. 2019). **sf** 패키지는 **tidyverse** 스타일의 읽기 및 쓰기 함수인 read_sf()와 write_sf()를 제공하며, 이 함수들은 다음과 같은 특징이 있다.\n\n-   `data.frame` 대신 `tibble`을 반환한다.\n\n-   출력 내용을 인쇄하지 않는다.\n\n-   기본적으로 기본 데이터를 덮어쓴다.\n\n`sf` 객체에 사용될 수 있는 **tidyverse** 로 `filter`, `select`, `group_by`, `ungroup`, `mutate`, `transmute`, `rowwise`, `rename`, `slice`, `summarise`, `distinct`, `gather`, `pivot_longer`, `spread`, `nest`, `unnest`, `unite`, `separate`, `separate_rows`, `sample_n`, 및 `sample_frac`등과 같은 것이 있다. 대부분의 함수는 `sf` 객체의 메타데이터를 관리하기만 할 뿐 지오메트리 정보를 건드리지 않는다. 사용자가 지오메트리를 제거하고자 할 경우, `st_drop_geometry`를 사용하거나 선택하기 전에 간단히 `tibble` 또는 `data.frame`으로 강제 변환(coerce)할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) |> suppressPackageStartupMessages()\nnc |> as_tibble() |> select(BIR74) |> head(3)\n# # A tibble: 3 × 1\n#   BIR74\n#   <dbl>\n# 1  1091\n# 2   487\n# 3  3188\n```\n:::\n\n\n`sf` 객체에 대한 `summarise` 함수는 두 가지 특별한 아규먼트를 가지고 있다\n\n-   `do_union` (기본값: TRUE): 그룹화된 지오메트리가 반환 시 유니언(합집합)되는지 여부를 결정하여, 유효한 지오메트리가 형성하도록 한다.\n\n-   `is_coverage` (기본값: FALSE): 그룹화된 지오메트리가 커버리지(겹침이 없는 경우)를 형성하는 경우, 이를 TRUE로 설정하면 유니언 과정이 빨라진다.\n\n`distinct` 함수는 고유한 레코드를 선택하며, `st_equals` 함수는 지오메트리의 고유성을 평가한다.\n\n`filter` 함수는 일반적인 프레디케이트와 함께 사용할 수 있으며, 공간적 프레디케이트를 사용하고자 할 경우, 예를 들어 오렌지 카운티에서 50km 이내에 있는 모든 카운티를 선택하려면 다음과 같이 사용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norange <- nc |> dplyr::filter(NAME == \"Orange\")\nwd <- st_is_within_distance(nc, orange, \n                            units::set_units(50, km))\no50 <- nc |> dplyr::filter(lengths(wd) > 0)\nnrow(o50)\n# [1] 17\n```\n:::\n\n\n(여기서 `dplyr::filter`를 사용하는 것은 베이스 R의 `filter` 함수와의 혼동을 피하기 위함이다.)\n\n그림 7.3은 이 분석의 결과를 보여주며, 카운티 경계 주위에 버퍼도 추가되어 있다. 이 버퍼는 설명을 위한 것이며, 카운티를 선택하는 데 사용되지는 않았음을 주의하라.\n\n\n::: {.cell}\n\n:::\n\n\n![오렌지 카운티(오렌지색), 반경 50km 내의 카운티(검은색), 오랜지 카운티 주변의 버퍼(갈색), 나머지 카운티(회색)](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-orangebuffer-1.png){#fig-7-3}\n\n## 공간적 조인\n\n일반적인 조인(왼쪽, 오른쪽 또는 내부 조인)에서는 두 테이블 사이에서 하나 이상의 속성이 일치할 때 조인이 이루어진다. 공간적 조인도 이와 유사하지만, 레코드를 조인하는 기준은 속성의 일치가 아니라 공간적 프레디케이트이다. 이로 인해 공간적으로 일치하는 레코드를 정의하는 다양한 선택지가 있으며, 이는 3.2.2절에 나열된 바이너리 프레디케이트를 사용하여 결정할 수 있다. \"왼쪽,\" \"오른쪽,\" \"내부,\" 또는 \"전체\" 조인의 개념은 비공간 조인과 동일하게 유지되는데, 이 경우는 공간적 일치를 상정하지 않은 상태에서 레코드의 조인을 처리할 때이다.\n\n공간적 조인을 실행할 때, 각 레코드에 여러 일치하는 레코드가 있을 수 있어 결과 테이블이 매우 커질 수 있다. 이 복잡성을 줄이는 방법으로, 일치하는 레코드 중에서 타깃 지오메트리와 가장 넓은 면적이 겹치는 레코드 하나를 선택하는 방식이 있다. 이 방법의 시각적 예시는 그림 7.4에 나타나 있으며, `st_join` 함수에서 `largest = TRUE` 아규먼트를 사용하여 이를 수행할 수 있다.\n\n\n::: {.cell}\n\n:::\n\n\n![largest = TRUE 아규먼트를 적용한 st_join 함수의 예: 아래쪽 그림의 폴리곤과 가장 넓은 면적이 겹치는 위쪽 그림의 폴리곤 라벨이 아래쪽 폴리곤에 할당되어 있다.](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-largest-1.png){#fig-7-4}\n\n결과의 복잡성을 줄이는 또 다른 방법은 조인 후에 `aggregate` 함수를 사용하여 모든 일치하는 레코드를 결합함과 동시에 지오메트리도 병합하는 것이다. 이에 대한 자세한 내용은 5.4절을 참고하라.\n\n### 샘플링, 그리딩, 인터폴레이팅\n\n`sf` 패키지가 제공하는 유용한 함수 몇 가지를 소개하고자 한다. `st_sample` 함수는 타깃 지오메트리로부터 임의의 샘플링 포인트를 생성해 주는데, 타깃 지오메트리는 점, 선, 또는 폴리곤 등 다양할 수 있다. 샘플링 방식으로 완전 무작위 방식, 규칙적 방식, 또는 폴리곤의 경우 삼각형 방식이 선택될 수 있다. 11장에서 `spatstat` 패키지에서 제공하는 공간적 샘플링(또는 포인트 패턴 시뮬레이션) 방법들이 어떻게 `st_sample` 함수를 통해 이루어지는지 설명한다.\n\n`st_make_grid` 함수는 특정 영역 위에 정사각형, 직사각형, 또는 육각형의 그리드를 생성해준다. 옵션을 다르게 적용하면 그리드 자체가 아니라 그리드의 중심점 혹은 구석점을 생성해준다. 이 함수는 그림 7.4에서 직사각형 그리드를 생성하는 데 사용되었다.\n\n함수 `st_interpolate_aw`는 5.3절에서 설명된 대로 공간적으로 내포적인 변수와 공간적으로 외연적인 변수를 새로운 영역으로 \"인터폴레이션\"하는 기능을 제공한다.\n\n## 타원 좌표\n\n비투영 데이터는 경위도로 표현된 타원체 좌표를 가진다. 4.1절에서 설명된 대로, 포인트간 \"직선\"은 최단 곡선 경로(\"측지선\")이다. 기본적으로 **sf** 패키지는 `s2geometry` 라이브러리의 기하학적 연산을 사용하며, 이는 **s2** 패키지를 통해 이루어진다(Dunnington, Pebesma, and Rubak 2023). 예를 들어, 아래의 지점은 특정 폴리곤 *내부*에 존재한다(그림 7.5의 왼쪽 그림: 정사 도법).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"POINT(50 50.1)\" |> st_as_sfc(crs = \"OGC:CRS84\") -> pt\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\"POLYGON((40 40, 60 40, 60 50, 40 50, 40 40))\" |>\n  st_as_sfc(crs = \"OGC:CRS84\") -> pol\nst_intersects(pt, pol)\n# Sparse geometry binary predicate list of length 1, where the\n# predicate was `intersects'\n#  1: 1\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n![인터섹션의 결과는 측지선 혹은 대권호를 사용하느냐(왼쪽) 데카르트 좌표계를 사용하느냐에 따라 달라진다.](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-figs2-1.png){#fig-7-5}\n\n**sf** 패키지가 타원체 좌표를 마치 데카르트 좌표처럼 사용하도록 하려면, **s2** 사용을 비활성화하면 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold <- sf_use_s2(FALSE)\n# Spherical geometry (s2) switched off\nst_intersects(pol, pt)\n# although coordinates are longitude/latitude, st_intersects assumes\n# that they are planar\n# Sparse geometry binary predicate list of length 1, where the\n# predicate was `intersects'\n#  1: (empty)\nsf_use_s2(old) # restore\n# Spherical geometry (s2) switched on\n```\n:::\n\n\n이렇게 하면, 그림 7.5의 오른쪽 그림(정거원통 도법)처럼, 엠프티 인터섹션이 리턴된다. 타원체 좌표를 평면 좌표로 취급한다는 점이 경고 메시지에 명시되어 있다.\n\n성능이나 레거시 구현과의 호환성 이유로 **s2** 사용을 비활성화할 수 있다. 데카르트 기하학을 위한 **GEOS** 라이브러리와 구체 기하학을 위한 **s2geometry** 라이브러리(그림 1.7)는 서로 다른 동기로 개발되었으며, **sf**를 통해 사용될 때 그 방식에서 몇 가지 차이가 있다.\n\n-   특정 오퍼레이션에서 속도차가 크게 날 수 있다.\n\n-   특정 함수는 오로지 특정 라이브러리에만 존재한다(예를 들어 `st_relate` 함수는 **GEOS** 라이브러리에만 존재)\n\n-   변환자(transformer)를 사용할 때, **GEOS**는 외부 폴리곤 링을 시계 방향으로 노드로 반환하며, 이를 반시계 방향으로 되돌리기 위해 `st_sfc(..., check_ring_dir = TRUE)`를 사용한다. 반면, `s2geometry`는 외부 폴리곤 링을 반시계 방향으로 반환한다.\n\n## stars 패키지\n\n`sp` 패키지가 래스터 데이터에 대한 지원이라는 측면에서 정체되어 있는 동안, `raster` 패키지(Hijmans 2023a)가 지난 10여년 동안 래스터 분석을 위한 강력하고 유연하며 확장 가능한 패키지로서 지배적인 위치를 공고히 하였다. `raster` 패키지(및 그 후속인 `terra` 패키지(Hijmans 2023b))는 2D 규칙 래스터 또는 래스터 레이어 집합(“래스터 스택”)이라는 래스터 데이터 모델에 기반하고 있다. 이는 세상이 수많은 레이어로 구성되어 있고 개별 레이어는 특정한 주제를 반영하고 있다는 고전적인 정적 “GIS 뷰”와 일치한다. 그러나 오늘날의 많은 데이터는 동적이며, 시계열 래스터 또는 시계열 래스터 스택으로 제공된다. 기존의 래스터 스택은 이러한 동적 특성을 제대로 반영하지 못하며, 사용자늘 어떤 레이어가 무엇을 나타내는지를 기록하고 있어야만 한다.\n\n또한, `raster` 패키지와 그 후속인 `terra` 패키지는 데이터 크기가 로컬 저장소(컴퓨터의 하드 드라이브)보다 크지 않을 때에만 훌륭한 전산 처리 능력을 발휘한다. 그러나 최근 데이터셋, 예를 들어 위성 이미지, 기후 모델 또는 기상 예보 데이터는 로컬 저장소의 용량으로는 더 이상 감당하기 어려운 수준에 도달했다(9장 참조). `spacetime` 패키지(Pebesma 2012, 2022)는 벡터 지오메트리 또는 래스터 그리드 셀의 시계열 분석을 어느 정도 다룰 수 있다. 하지만 더 높은 차원의 어레이나 메모리가 감당하기 어려운 정도의 크기를 가진 데이터셋은 여전히 다루기 어렵다.\n\n여기서 우리는 래스터 및 벡터 데이터 큐브 분석을 위한 패키지로 `stars`를 소개한다. 이 패키지는 다음과 같은 기능을 제공한다.\n\n-   동적(시간 변화) 래스터 스택을 재현할 수 있다.\n\n-   로컬 디스크의 크기에 한정되지 않는 확장 가능성을 목표로 한다.\n\n-   GDAL 라이브러리의 래스터 기능과 강력한 통합을 제공한다.\n\n-   규칙 그리드 외에도 회전, 전단, 직선, 곡선 래스터를 처리할 수 있다(그림 1.6 참조).\n\n-   sf 패키지와의 긴밀한 통합을 제공한다.\n\n-   비래스터(non-raster) 공간 차원을 가진 어레이 데이터(벡터 데이터 큐브)를 처리할 수 있다.\n\n-   타이디버스 디자인 원리를 따른다.\n\n벡터 데이터 큐브에는 심플 피처의 시계열이나 출발지-목적지 매트릭스(그것의 시계열 포함)와 같은 공간 그래프 데이터가 포함된다. 공간적 벡터 및 래스터 데이터 큐브의 개념은 6장에서 설명되었다. 불규칙 시공간 관측치는 `sftime` 패키지(Teickner, Pebesma, and Graeler 2022)에서 제공하는 `sftime` 객체로 재현될 수 있으며, 이는 시간 열을 추가하는 방식으로 `sf` 객체를 확장한 것이다(13.3절 참조).\n\n### 래스터 데이터의 읽기와 쓰기\n\n래스터 데이터는 일반적으로 파일을 불러온다. 우리는 브라질의 올린다 시에 대한 30m 해상도의 Landsat 7 데이터셋(밴드 1-5 및 7)을 사용한다. 패키지 **stars**에서 규칙 비회전 그리드에 대한 예제 GeoTIFF 파일을 읽을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntif <- system.file(\"tif/L7_ETMs.tif\", package = \"stars\")\nlibrary(stars)\n# Loading required package: abind\n(r <- read_stars(tif))\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      54     69 68.9      86  255\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n```\n:::\n\n\n여기서 우리는 오프셋, 셀 크기, 좌표참조계, 및 차원을 확인할 수 있다. 차원 테이블은 각 차원에 대해 다음과 같은 필드를 포함한다.\n\n-   `from`: 시작 인덱스 값\n\n-   `to`: 종료 인덱스 값\n\n-   `offset`: 첫 번째 픽셀의 시작(모서리)에서의 차원 값\n\n-   `delta`: 셀 크기로 음의 delta 값은 디멘션 값이 감소할수록 필셀 인덱스 값이 증가한다는 것을 의미\n\n-   `refsys`: 참조계\n\n-   `point`: 셀 값이 포인트 서포트인지, 셀 서포트인지를 명시하는 논리 값\n\n-   `x/y`: 디멘션이 래스터의 x- 축과 관련되는지 y-축과 관련되는지를 나타내는 값\n\n여기에는 사용되지 않기 때문에 숨겨진 또 다른 필드인 `values`가 있다. 정규, 회전, 또는 전단 그리드와 같은 규칙적으로 이산화된 차원(예: 시간)의 경우, 오프셋과 델타는 NA가 아니다. 반면 불규칙한 경우에는 오프셋과 델타가 NA이며, `values` 속성은 다음 중 하나를 포함한다.\n\n-   값 또는 구간의 시퀀스: 직선 공간 래스터 또는 불규칙 시간 차원의 경우\n\n-   공간 차원과 연결된 지오메트리: 벡터 데이트 큐브의 경우\n\n-   각 래스터 셀에 대한 좌표값이 포함된 매트릭스: 곡선 래스터의 경우\n\n-   차원 값과 연결된 밴드 이름 또는 레이블: 이산 디멘션의 경우\n\n`stars` 클래스의 객체 `r`은 길이가 1인 간단한 리스트로 구성되어 있으며, 3차원 어레이를 포함한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(r)\n# [1] 1\nclass(r[[1]])\n# [1] \"array\"\ndim(r[[1]])\n#    x    y band \n#  349  352    6\n```\n:::\n\n\n또한, 이 객체는 어레이 차원이 무엇을 나타내는지 알기 위해 필요한 모든 메타데이터를 포함한 디멘션 테이블을 속성으로 가지고 있다. 이는 다음을 통해 얻어진다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_dimensions(r)\n```\n:::\n\n\n어레이의 공간적 범위에 대한 정보를 다음과 같이 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_bbox(r)\n#    xmin    ymin    xmax    ymax \n#  288776 9110729  298723 9120761\n```\n:::\n\n\n`write_stars` 함수를 통해 래스터 데이터를 로컬 디스크에 저장할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntf <- tempfile(fileext = \".tif\")\nwrite_stars(r, tf)\n```\n:::\n\n\n파일 확장자를 통해 데이터 형식(이 경우, GeoTIFF)이 지정된다. 단순 피처와 마찬가지로 읽기 및 쓰기 작업은 GDAL 라이브러리를 사용하며, 래스터 데이터에 사용할 수 있는 드라이버 목록은 다음을 통해 확인할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_drivers(\"raster\")\n```\n:::\n\n\n### `stars` 데이터 큐브로부터 일부분 골라내기\n\n데이터 큐브는 `[` 연산자를 사용하거나 타이디버스 동사를 사용하여 부분 집합을 만들 수 있다. 첫 번째 옵션인 `[`를 사용하는 방식은 다음의 아규먼트를 쉼표의 구분과 함께 순서대로 지정하는 것이다.\n\n-   속성(이름, 인덱스, 또는 논리 벡터)\n\n-   차원\n\n예를 들어, `r[1:2, 101:200,, 5:10]`는 `r`에서 속성 1-2를 선택하고, 디멘션 1에 대해 인덱스 101-200, 차원 3에 대해 인덱스 5-10을 선택함을 의미한다. 차원 2를 통한 선택은 이루어지지 않는다. 속성의 경우, 속성 이름, 인덱스 또는 논리 벡터를 사용할 수 있다. 차원의 경우에는 논리 벡터가 지원되지 않는다. 불연속 범위 선택은 규칙 시퀀스일 때만 지원된다. 기본적으로 `drop`은 `FALSE`로 설정되어 있으며, `TRUE`로 설정하면 단일 값을 가진 차원은 모두 제거된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr[,1:100, seq(1, 250, 5), 4] |> dim()\n#    x    y band \n#  100   50    1\nr[,1:100, seq(1, 250, 5), 4, drop = TRUE] |> dim()\n#   x   y \n# 100  50\n```\n:::\n\n\n특정 범위의 차원 *값*을 선택하기 위해 `filter` 함수를 사용할 수 있는데, 이는 `dplyr` 패키지를 우선적으로 로드해야 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr, warn.conflicts = FALSE)\nfilter(r, x > 289000, x < 290000)\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     5      51     63 64.3      75  242\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1  35  289004  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6       1     1                NA    NA\n```\n:::\n\n\n이는 차원의 오프셋을 변경한다. 특정 큐브 슬라이스는 `slice` 함수를 사용하여 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice(r, band, 3)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    21      49     63 64.4      77  255\n# dimension(s):\n#   from  to  offset delta            refsys point x/y\n# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n```\n:::\n\n\n이는 단일 차원 `band`를 제거한다. `mutate` 함수는 `stars` 객체에서 기존 어레이를 기반으로 새로운 어레이를 추가하는 데 사용되며, `transmute`는 여기에 덧붙여 기존 어레이를 제거한다.\n\n### 잘라내기\n\n부분 집합을 생성하는 또 다른 방법에 `sf`, `sfc` 또는 `bbox` 클래스의 공간 객체를 사용하는 방법이 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- st_bbox(r) |>\n    st_as_sfc() |>\n    st_centroid() |>\n    st_buffer(units::set_units(500, m))\nr[b]\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max. NA's\n# L7_ETMs.tif    22      54     66 67.7    78.2  174 2184\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x     157 193  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y     159 194 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n```\n:::\n\n\n예를 들어, 해당 지역에 대한 직경 500m의 원형 중심부를 추출할 수 있는데, 그림 7.6에는 첫 번째 밴드에 적용한 결과가 나타나 있다.\n\n\n::: {.cell}\n\n:::\n\n\n![Landsat 7 (band 1) 이미지의 원형 중심부](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-circr-1.png){#fig-7-6}\n\n원형 공간 객체의 외부에 존재하는 픽셀에는 NA 값이 할당되는 것을 볼 수 있다. 이 원형 객체는 여전히 `r`의 `offset`과 `delta` 값에 대한 차원 인덱스를 가지고 있다. 다음과 같은 방식으로 `offset` 값을 재설정할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr[b] |> st_normalize() |> st_dimensions()\n#      from to  offset delta            refsys point x/y\n# x       1 37  293222  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 36 9116258 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1  6      NA    NA                NA    NA\n```\n:::\n\n\n기본적으로, 결과 래스터는 선택 객체의 범위로 잘린다. 입력 객체와 동일한 차원을 가진 객체는 다음과 같은 방식으로 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr[b, crop = FALSE]\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.   NA's\n# L7_ETMs.tif    22      54     66 67.7    78.2  174 731280\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n```\n:::\n\n\n`stars` 객체의 잘라내기는 `st_crop` 함수를 사용하여 직접 수행할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crop(r, b)\n```\n:::\n\n\n### stars 객체의 차원재부여 및 결합\n\n`stars` 패키지는 다양한 어레이 조작을 수행하기 위해 패키지 `abind` (Plate and Heiberger 2016)를 사용한다. 한 예로 어레이를 순열하여 전치하는 `aperm` 함수이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naperm(r, c(3, 1, 2))\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      54     69 68.9      86  255\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# band    1   6      NA    NA                NA    NA    \n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n```\n:::\n\n\n`stars` 객체에 대한 메서드가 제공되며, 결과 객체의 차원 순서를 순열한다.\n\n속성과 차원을 교환할 수 있으며, 이는 `split`과 `merge`를 사용하여 수행된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(rs <- split(r))\n# stars object with 2 dimensions and 6 attributes\n# attribute(s):\n#     Min. 1st Qu. Median Mean 3rd Qu. Max.\n# X1    47      67     78 79.1      89  255\n# X2    32      55     66 67.6      79  255\n# X3    21      49     63 64.4      77  255\n# X4     9      52     63 59.2      75  255\n# X5     1      63     89 83.2     112  255\n# X6     1      32     60 60.0      88  255\n# dimension(s):\n#   from  to  offset delta            refsys point x/y\n# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\nmerge(rs, name = \"band\") |> setNames(\"L7_ETMs\")\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#          Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs     1      54     69 68.9      86  255\n# dimension(s):\n#      from  to  offset delta            refsys point    values x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE      NULL [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE      NULL [y]\n# band    1   6      NA    NA                NA    NA X1,...,X6\n```\n:::\n\n\n`split` 함수는 밴드 차원을 2차원 어레이의 여섯 개 속성에 분배하며, `merge` 함수는 거꾸로 수행한다. `st_redimension` 함수는 단일 어레이 차원을 두 개의 새로운 차원으로 분할하는 것과 같은 보다 일반적인 작업에 사용된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_redimension(r, c(x = 349, y = 352, b1 = 3, b2 = 2))\n# stars object with 4 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      54     69 68.9      86  255\n# dimension(s):\n#    from  to  offset delta            refsys point x/y\n# x     1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y     1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# b1    1   3      NA    NA                NA    NA    \n# b2    1   2      NA    NA                NA    NA\n```\n:::\n\n\n동일한 차원을 가진 여러 개의 `stars` 객체는 `c`를 사용하여 결합할 수 있다. 결합된 어레이는 추가적인 속성으로 취급하는 것이 디폴트 설정이지만, `along` 아규먼트를 지정하면 어레이를 새로운 차선을 따라 병합할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(r, r, along = \"new_dim\")\n# stars object with 4 dimensions and 1 attribute\n# attribute(s), summary of first 1e+05 cells:\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    47      65     76 77.3      87  255\n# dimension(s):\n#         from  to  offset delta            refsys point x/y\n# x          1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y          1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band       1   6      NA    NA                NA    NA    \n# new_dim    1   2      NA    NA                NA    NA\n```\n:::\n\n\n이의 사용 예시는 7.5.2절에서 설명된다.\n\n### 포인트 샘플 추출하기, 애그리게이팅하기\n\n래스터 데이터 큐브 분석의 매우 일반적인 사용 사례는 특정 위치에서 값을 추출하거나 특정 지오메트리에 대해 집계값을 계산하는 것이다. `st_extract` 함수는 포인트 값을 추출한다. 우리는 `r` 객체의 바운딩 박스 내의 몇 개의 무작위로 샘플링 포인트에 대해 이 오퍼레이션을 수행할 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(115517)\npts <- st_bbox(r) |> st_as_sfc() |> st_sample(20)\n(e <- st_extract(r, pts))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    12    41.8     63   61    80.5  145\n# dimension(s):\n#          from to            refsys point\n# geometry    1 20 SIRGAS 2000 / ...  TRUE\n# band        1  6                NA    NA\n#                                           values\n# geometry POINT (293002 ...,...,POINT (290941 ...\n# band                                        NULL\n```\n:::\n\n\n이것은 20개의 포인트와 6개의 밴드를 가진 벡터 데이터 큐브를 생성한다(시드를 설정하게 되면, 반복 실행에서 동일한 샘플의 사용이 보장된다. 따라서 포인트의 무작위 생성을 재실행하고자 하는 경우는 시드를 설정해서는 안된다).\n\n데이터 큐브에서 정보를 추출하는 또 다른 방법은 집계값을 산출하는 것이다. 이를 수행하는 한 가지 방법은 공간 폴리곤 또는 라인에 의거해 값을 공간적으로 집계하는 것이다(6.4절 참조). 예를 들어, 그림 1.4(d)에 표시된 세 개의 원 각각에 대해 여섯 개 밴드의 최대 픽셀 값을 계산할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircles <- st_sample(st_as_sfc(st_bbox(r)), 3) |>\n    st_buffer(500)\naggregate(r, circles, max)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    73    94.2    117  121     142  205\n# dimension(s):\n#          from to            refsys point\n# geometry    1  3 SIRGAS 2000 / ... FALSE\n# band        1  6                NA    NA\n#                                           values\n# geometry POLYGON ((2913...,...,POLYGON ((2921...\n# band                                        NULL\n```\n:::\n\n\n이는 세 개의 지오메트리와 여섯 개의 밴드를 가진 (벡터) 데이터 큐브를 생성한다. 시간 차원에 대한 집계값의 산출은 `aggregate` 함수의 두 번째 아규먼트로 시간 변수를 설정하여 수행된다. 시간 변수에 다음과 같은 것이 있을 수 있다.\n\n-   시간 간격의 시작을 나타내는 타임 스탬프의 집합\n\n-   `make_intervals` 함수로 정의된 시간 간격 집합\n\n-   \"주\", \"5일\" 또는 \"년\"과 같은 시간 기간\n\n### 예측 모델\n\nR에서의 일반적인 모델 예측 워크플로우는 다음과 같다.\n\n-   응답 변수와 예측 변수(공변량)가 포함된 `data.frame`의 사용\n\n-   `data.frame`을 기반으로 모델 객체를 생성\n\n-   모델 객체와 대상 예측 변수 값이 포함된 `data.frame`을 사용하여 `predict`를 호출\n\n`stars` 패키지는 `stars` 객체에 대한 `predict` 메서드를 제공하며, 이는 본질적으로 위의 마지막 단계를 수행하는데, data.frame을 생성하고, `predict` 메서드를 호출한 후, 예측 값으로 `stars` 객체를 재구성한다.\n\n이 과정을 설명하기 위해 Landsat 데이터셋에 위에서 추출한 샘플 포인트를 적용해 육지를 바다에서 분리하는 간단한 이진 클래스 예제를 사용할 것이다. 결과는 그림 7.7에 나타나 있다.\n\n\n::: {.cell}\n\n:::\n\n\n![트레이닝 데이터로 사용되는 무작위 샘플 포인트: 빨간색은 해양부이고 노란색을 육지부이다.](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-rsample-1.png){#fig-7-7}\n\n이 그림에서 포인트 8, 14, 15, 18 및 19는 수부에 위치하고 있으며, 나머지는 육지부에 있다는 것을 \"육안\"으로 확인할 수 있다. 선형 판별(\"최대 우도\") 분류기를 사용하여, 우리는 그림 7.8에 나타난 모델 예측 결과를 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrs <- split(r)\ntrn <- st_extract(rs, pts)\ntrn$cls <- rep(\"land\", 20)\ntrn$cls[c(8, 14, 15, 18, 19)] <- \"water\"\nmodel <- MASS::lda(cls ~ ., st_drop_geometry(trn))\npr <- predict(rs, model)\n```\n:::\n\n\n여기서 우리는 `MASS::` 접두사를 사용하여 **MASS** 패키지를 로드하지 않았으며, 이는 `dplyr`의 `select` 함수를 가리는 것을 방지하기 위함이다. `split` 단계는 밴드 차원을 속성으로 변환하여 예측 변수로 투입하기 위해 필요한 단계이다.\n\n\n::: {.cell}\n\n:::\n\n\n![육지부/수부 구분을 위한 선형 판별 분류기로 그림 7.7의 트레이닝 데이터에 기반한 결과임.](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-lda-1.png){#fig-7-8}\n\n우리는 또한 그림 7.8에 플로팅된 레이어가 클래스 레이블을 가진 범주형 변수임을 알 수 있다.\n\n### 래스터 데이터 플로팅\n\n\n::: {.cell}\n\n:::\n\n\n![30m 해상도의 Landsat 6개 밴드를 90m로 다운샘플한 결과, 브라질의 올린다](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-firststars-1.png)\n\n베이스 플롯 함수를 `stars` 객체에 적용할 수 있는데, `plot(r)`로 생성된 플롯은 그림 7.9에 나타나 있다. 기본 색상 스케일은 회색 톤을 사용하며, 모든 밴드의 데이터 분위수에 맞춰 명암 대비가 조정된다(“히스토그램 평활화”)(역자주: 히스토그램 평활화는 데이터의 분토를 재조정하여 시각적으로 더 유용하고 세부 사항을 더 잘 볼 수 있게 하는 기법을 말한다. 예를 들어, 어두운 이미지에서는 어두운 영역의 픽셀 값이 많이 몰려 있는데, 히스토그램 평활화를 적용하면 이 픽셀 값의 범위를 더 넓은 범위로 확장(stretch)시켜 이미지를 밝고 명확하게 보이도록 할 수 있다.) `breaks = \"equal\"`로 설정하면 급폭이 동일하게 설정되는 등간격 분류법이 적용되며, 계급 단절값을 임의로 지정할 수도 있다. 그런데 더 익숙한 플로팅 방식은 그림 7.10에 나타난 RGB 또는 폴스 컬러 합성일 것이다.\n\n\n::: {.cell}\n\n:::\n\n\n![컬러 합성의 두 가지 예](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-starsrgb-1.png){#fig-7-10}\n\n보다 자세한 사항은 8장에서 다루어진다.\n\n### 래스터 데이터 분석하기\n\n`stars` 객체의 개별 엘리먼트에 대해서는, 수리 함수의 적용이 어레이에 직접적으로 이루어진다. 이는 사용자가 함수를 호출하여 표현식(expression)을 생성하는 것이 가능하다는 것을 의미한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(r)\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     0    3.99   4.23 4.12    4.45 5.54\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\nr + 2 * log(r)\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      62   77.5 77.1    94.9  266\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n```\n:::\n\n\n혹은 특정 값들을 마스킹 처리할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2 <- r\nr2[r < 50] <- NA\nr2\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.   NA's\n# L7_ETMs.tif    50      64     75   79      90  255 149170\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n```\n:::\n\n\n혹은 마스킹을 해제할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2[is.na(r2)] <- 0\nr2\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     0      54     69   63      86  255\n# dimension(s):\n#      from  to  offset delta            refsys point x/y\n# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n# band    1   6      NA    NA                NA    NA\n```\n:::\n\n\n`stars` 객체의 개별 차원에 대해서는, 선택된 어레이 차원에 함수를 적용하는 것이 가능하며, 이는 `apply` 함수가 어레이에 대해 수행하는 방식과 유사하다(6.3.3절). 예를 들어, 각 픽셀에 대해 6개 밴드 값의 평균을 계산할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(r, c(\"x\", \"y\"), mean)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#       Min. 1st Qu. Median Mean 3rd Qu. Max.\n# mean  25.5    53.3   68.3 68.9      82  255\n# dimension(s):\n#   from  to  offset delta            refsys point x/y\n# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n```\n:::\n\n\n더 유의미한 함수로는 예를 들어 NDVI(Normalized Difference Vegetation Index, 정규화 식생 지수 )를 계산하는 것이 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi <- function(b1, b2, b3, b4, b5, b6) (b4 - b3)/(b4 + b3)\nst_apply(r, c(\"x\", \"y\"), ndvi)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#         Min. 1st Qu.  Median    Mean 3rd Qu.  Max.\n# ndvi  -0.753  -0.203 -0.0687 -0.0643   0.187 0.587\n# dimension(s):\n#   from  to  offset delta            refsys point x/y\n# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]\n# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]\n```\n:::\n\n\n혹은, 다음과 같이 정의할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi2 <- function(x) (x[4]-x[3])/(x[4]+x[3])\n```\n:::\n\n\n밴드 수가 많을 경우 이러한 방식은 더 편리하지만, 각 픽셀에 대해 호출해야 하므로 위에서 정의한 `ndvi` 함수보다 훨씬 느리다. 반면 `ndvi` 함수는 모든 픽셀이나 큰 픽셀 덩어리에 대해 한 번 호출할 수 있다. 전체 이미지에 대해 각 밴드의 평균은 다음과 같이 계산된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(r, c(\"band\"), mean) |> as.data.frame()\n#   band mean\n# 1    1 79.1\n# 2    2 67.6\n# 3    3 64.4\n# 4    4 59.2\n# 5    5 83.2\n# 6    6 60.0\n```\n:::\n\n\n결과는 `data.frame`의 형태로 막바로 출력해 볼 수 있을 만큼 작다. 이 두 가지 예에서는 전체 디멘션이 사라진다. 그러나 그렇지 않은 경우도 종종 발생한다(6.3.2절). 예를 들어, 각 밴드에 대해 세 개의 사분위수를 계산할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(r, c(\"band\"), quantile, c(.25, .5, .75))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif    32    60.8   66.5 69.8    78.8  112\n# dimension(s):\n#          from to        values\n# quantile    1  3 25%, 50%, 75%\n# band        1  6          NULL\n```\n:::\n\n\n이렇게 하면 세 개의 값으로 이루어진 새로운 차원인 `quantile`이 *생성*된다. 또는 각 픽셀에 대해 여섯 개의 밴드 값에 대한 세 개의 사분위수를 다음과 같은 방식으로 얻을 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(r, c(\"x\", \"y\"), quantile, c(.25, .5, .75))\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     4      55   69.2 67.2    81.2  255\n# dimension(s):\n#          from  to  offset delta            refsys point\n# quantile    1   3      NA    NA                NA    NA\n# x           1 349  288776  28.5 SIRGAS 2000 / ... FALSE\n# y           1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE\n#                 values x/y\n# quantile 25%, 50%, 75%    \n# x                 NULL [x]\n# y                 NULL [y]\n```\n:::\n\n\n### 곡선 래스터\n\n비규칙 래스터가 발생하는 여러 가지 이유가 있다(그림 1.6). 우선, 데이터가 지구의 형태를 그대로 반영하고 있을 때, 규칙 래스터는 곡면인 지구의 표면에 맞지 않는다. 다른 이유에는 다음과 같은 것들이 있다.\n\n-   규칙 래스터 데이터를 다른 좌표참조계로 전환하거나 변환할 경우, 리샘플링, 즉 워핑(7.8절)을 하지 않으면 곡선 형태가 된다. 그런데 워핑은 항상 데이터 손실을 초래하며, 이는 가역적이지 않다.\n\n-   관측이 비규칙 래스터를 초래할 수 있다. 품질이 낮은 위성 영상의 경우, 위성의 진행 방향에서는 규칙 래스터가 되지만($x$ 또는 $y$와 정렬되지 않음), 그와 수직인 방향에서는 직각(rectilinear) 래스터가 된다(예: 센서가 시야*각*을 일정한 간격으로 분할하여 관측을 수행하는 경우).\n\n### GDAL 유틸리티\n\nGDAL 라이브러리는 일반적으로 데이터 변환 및 처리를 위한 여러 실행 가능한 바이너리, 즉 GDAL 명령줄 유틸리티와 함께 제공된다. 이러한 유틸리티 중 여러 개(파이썬으로 작성된 것을 제외한 모든 유틸리티)는 \"GDAL Algorithms C API\"를 통해 GDAL 라이브러리의 C 함수로도 사용 가능하다. GDAL 라이브러리와 연동되어 있는 `sf`와 같은 R 패키지가 이러한 C API 알고리즘을 사용한다면, 사용자는 R 패키지 외에 추가로 GDAL 바이너리 명령줄 유틸리티를 설치할 필요가 없다는 의미이다.\n\n`sf` 패키지는 `gdal_utils` 함수를 통해 이러한 C API 알고리즘을 호출할 수 있으며, 첫 번째 인수는 `gdal` 접두사를 제거한 해당 유틸리티의 이름이다.\n\n-   `info`: GDAL(래스터) 데이터셋에 대한 정보를 출력한다.\n\n-   `warp`: 래스터를 새로운 래스터로 변환한다(CRS의 전환 포함).\n\n-   `rasterize`: 벡터 데이터셋을 래스터화한다.\n\n-   `translate`: 래스터 파일을 다른 형식으로 변환한다.\n\n-   `vectortranslate`: 벡터 파일을 다른 형식으로 변환한다(ogr2ogr에 해당).\n\n-   `buildvrt`: 가상 래스터 타일(여러 파일의 결합을 통해 생성된 단일 래스터)을 생성한다.\n\n-   `demprocessing`: DEM(digital data model, 디지털고도모델)에 대한 다양한 프로세싱을 수행한다.\n\n-   `nearblack`: 거의 검정색/흰색 경계를 검정색으로 변환한다.\n\n-   `grid`: 흩어진 데이터로부터 규칙 그리드를 생성한다.\n\n-   `mdiminfo`: 다차원 어레이에 대한 정보를 출력한다.\n\n-   `mdimtranslate`: 다차원 어레이를 다른 형식으로 변환한다.\n\n이러한 유틸리티는 기본적으로 파일에서 작동하며, `sf` 또는 `stars` 객체에 직접적으로 작용하지는 않는다. 그러나 `stars_proxy` 객체는 본질적으로 파일에 대한 포인터이며, 다른 객체들도 파일로 기록될 수 있다. 이러한 유틸리티 중 몇몇은 (항상 혹은 선택적으로) `st_mosaic`, `st_warp`, 또는 `st_write`와 같은 함수를 통해 사용된다. R의 **gdalUtilities** (O’Brien 2022) 패키지는 `sf::gdal_utils`에 덧붙여 사용자 편의성을 위한 래퍼 함수를 제공하는데, 함수의 아규먼트 이름이 바이너리 유틸리티의 명령줄 아규먼트와 정확히 일치한다.\n\n## 벡터 데이터 큐브의 예제\n\n### 예제: 대기질 시계열 데이터에 대한 애그리게이션 실행\n\n유럽 대기질 데이터를 사례로 벡터 데이터 큐브에 대한 애그리게이션 작업을 설명한다. 동일한 데이터가 Gräler, Pebesma, Heuvelink (2016)에서 사용되었으며, 12장과 13장에서도 사용될 예정이다. 독일의 농촌 지역 관측소의 1998\\~2009년 데이터로부터 일평균 $\\text{PM}_{10}$ 값을 계산하였다.\n\n`air` 데이터 매트릭스, 날짜 벡터인 `date`s, 그리고 `SpatialPoints` 객체인 `stations`을 결합해 `stars` 객체를 생성할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"data/air.rda\") # this loads several datasets in .GlobalEnv\ndim(air)\n# space  time \n#    70  4383\nstations |>\n    st_as_sf(coords = c(\"longitude\", \"latitude\"), crs = 4326) |>\n    st_geometry() -> st\nd <- st_dimensions(station = st, time = dates)\n(aq <- st_as_stars(list(PM10 = air), dimensions = d))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#       Min. 1st Qu. Median Mean 3rd Qu. Max.   NA's\n# PM10     0    9.92   14.8 17.7      22  274 157659\n# dimension(s):\n#         from   to     offset  delta refsys point\n# station    1   70         NA     NA WGS 84  TRUE\n# time       1 4383 1998-01-01 1 days   Date FALSE\n#                                          values\n# station POINT (9.59 53.7),...,POINT (9.45 49.2)\n# time                                       NULL\n```\n:::\n\n\n그림 7.11에서 시간 시계열이 상당히 길지만, 큰 결측값 간격도 있다는 것을 알 수 있다. 그림 7.12는 평균 $\\text{PM}_{10}$ 값과 함께 측정소의 공간 분포를 보여준다.\n\n![시간과 스테이션별로 계산된 PM10 값에 대한 시공간 다이어그램](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-airst-1.png){#fig-7-11}\n\n![관측 스테이션별 PM10 평균값](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-airmap-1.png){#fig-7-12}\n\n간단한 실습 차원에서, 측정 스테이션별 시간 시계열 데이터를 지역 평균으로 집계할 수 있다. 이를 위해 `stars` 객체에 대한 `aggregate` 메소드를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(a <- aggregate(aq, de_nuts1, mean, na.rm = TRUE))\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#       Min. 1st Qu. Median Mean 3rd Qu. Max.  NA's\n# PM10  1.08    10.9   15.3 17.9    21.8  172 25679\n# dimension(s):\n#      from   to     offset  delta refsys point\n# geom    1   16         NA     NA WGS 84 FALSE\n# time    1 4383 1998-01-01 1 days   Date FALSE\n#                                       values\n# geom MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# time                                    NULL\n```\n:::\n\n\n그리고, 아래의 코드를 통해 임의로 선택한 여섯 개의 날짜에 대한 지도를 보여줄 수 있다(그림 7.13).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\na |> filter(time >= \"2008-01-01\", time < \"2008-01-07\") |> \n    plot(key.pos = 4)\n```\n:::\n\n\n![임의의 6일에 대한 지역 평균 PM10](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-airagg-1.png){#fig-7-13}\n\n또한 다음의 코드를 이용해 단일 주에 대한 평균 값의 시계열 플롯을 생성할 수 있다(그림 7.14).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xts) |> suppressPackageStartupMessages()\nplot(as.xts(a)[,4], main = de_nuts1$NAME_1[4])\n```\n:::\n\n\n![단일 스테이션에 대한 지역 평균 PM10의 시계열](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-airts-1.png){#fig-7-14}\n\n### 예제: 브리스톨 출발지-도착지 데이터 큐브\n\n이 예제에 사용된 데이터는 Lovelace, Nowosad, Muenchow (2019)에서 가져온 것으로, 출발지-목적지(OD) 매트릭스이다. 구체적으로 A 지역에서 B 지역으로 이동하는 사람의 수를 교통 수단별로 나타낸 것이다. 102개의 지역에 대한 피처 지오메트리는 `sf` 객체인 `bristol_zones`에 포함되어 있다.\n\n\n::: {.cell}\n\n:::\n\n\n![영국 브리스톨의 102개 구역 현황(33번 구역(E02003043)이 빨간색으로 표시되어 있음)](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-bristol1-1.png){#fig-7-15}\n\n`bristol_od` 테이블에 데이터가 저장되어 있는데, OD 쌍(이동량이 0인 경우는 제외)가 레코드로, 서로 다른 교통수단이 변수로 들어가 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(bristol_od)\n# # A tibble: 6 × 7\n#   o         d           all bicycle  foot car_driver train\n#   <chr>     <chr>     <dbl>   <dbl> <dbl>      <dbl> <dbl>\n# 1 E02002985 E02002985   209       5   127         59     0\n# 2 E02002985 E02002987   121       7    35         62     0\n# 3 E02002985 E02003036    32       2     1         10     1\n# 4 E02002985 E02003043   141       1     2         56    17\n# 5 E02002985 E02003049    56       2     4         36     0\n# 6 E02002985 E02003054    42       4     0         21     0\n```\n:::\n\n\n제외된 무이동 OD 쌍의 갯수는 모든 OD 조합의 수에서 데이터에 포함된 OD 쌍의 갯수를 빼면 구할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(bristol_zones)^2 - nrow(bristol_od) \n# [1] 7494\n```\n:::\n\n\n우리는 출발지, 목적지, 교통 수단을 차원으로 가지는 3차원 벡터 데이터 큐브를 형성할 것이다. 이를 위해 먼저 `pivot_longer`를 사용하여 `bristol_od` 테이블을 정리하여 출발지(o), 목적지(d), 교통 수단(mode), 및 수(count)라는 변수를 갖도록 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create O-D-mode array:\nbristol_tidy <- bristol_od |> \n    select(-all) |> \n    pivot_longer(3:6, names_to = \"mode\", values_to = \"n\")\nhead(bristol_tidy)\n# # A tibble: 6 × 4\n#   o         d         mode           n\n#   <chr>     <chr>     <chr>      <dbl>\n# 1 E02002985 E02002985 bicycle        5\n# 2 E02002985 E02002985 foot         127\n# 3 E02002985 E02002985 car_driver    59\n# 4 E02002985 E02002985 train          0\n# 5 E02002985 E02002987 bicycle        7\n# 6 E02002985 E02002987 foot          35\n```\n:::\n\n\n그리고 나서 0으로 채워진 3차원 어레이 `a`를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nod <- bristol_tidy |> pull(\"o\") |> unique()\nnod <- length(od)\nmode <- bristol_tidy |> pull(\"mode\") |> unique()\nnmode = length(mode)\na = array(0L,  c(nod, nod, nmode), \n    dimnames = list(o = od, d = od, mode = mode))\ndim(a)\n# [1] 102 102   4\n```\n:::\n\n\n해당 어레이의 세 차원에 구역 이름(o, d)과 교통 수단 이름(mode)이 부여된 것을 확인할 수 있다. 이렇게 함으로써 `bristol_tidy`의 각 행은 해당 어레이의 한 단위(엔트리)에 해당하게 된다. `bristol_tidy` 테이블에 있는 인덱스(`o`, `d` 및 `mode`)와 값(`n`)을 이용해 해당 어레이(`a`)의 비제로 부분을 채울 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na[as.matrix(bristol_tidy[c(\"o\", \"d\", \"mode\")])] <- \n        bristol_tidy$n\n```\n:::\n\n\n`bristol_zones`의 구역과 `bristol_tidy`의 구역 이름 간에 순서 불일치가 발생할 수 있기 때문에 다음의 조치를 취한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norder <- match(od, bristol_zones$geo_code)\nzones <- st_geometry(bristol_zones)[order]\n```\n:::\n\n\n순서가 이미 올바른 경우도 있지만, 이러한 가정을 배제한 채 위의 코드를 실행하는 것이 좋다. 다음으로 존과 교통수단을 이용해 `stars` 디멘션 객체를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stars)\n(d <- st_dimensions(o = zones, d = zones, mode = mode))\n#      from  to refsys point                                  values\n# o       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# d       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# mode    1   4     NA FALSE                       bicycle,...,train\n```\n:::\n\n\n`a`와 `d`로부터 최종적으로 `stars` 객체를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(odm <- st_as_stars(list(N = a), dimensions = d))\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#    Min. 1st Qu. Median Mean 3rd Qu. Max.\n# N     0       0      0  4.8       0 1296\n# dimension(s):\n#      from  to refsys point                                  values\n# o       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# d       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# mode    1   4     NA FALSE                       bicycle,...,train\n```\n:::\n\n\n이 3차원 어레이로부터 단일 슬라이스를 추출할 수 있다. 예를 들어 구역 33에 대한 데이터를 `odm[,,33]`을 통해 추출한 후 플롯을 그릴 수 있다(그림 7.16).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(adrop(odm[,,33]) + 1, logz = TRUE)\n```\n:::\n\n\n![33번 존에 대한 OD 데이터를 추출한 후 교통수단별로 지도화하였다.](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-odm33-1.png){#fig-7-16}\n\n이렇게 하여 서브셋을 생성하면, 첫 번째 아규먼트가 비어 있으므로 모든 속성(여기서는 하나만 존재함: N)을 선택하고, 두 번째 아규먼트가 비어 있어 모든 출발지를 선택하며, 세 번째 아규먼트로 목적지 구역 33을 선택하고, 네 번째 아규먼트는 비어 있어 모든 교통 수단을 선택하게 된다.\n\n우리가 이 특정 구역을 목적지로 선택한 이유는 해당 구역이 가장 많은 여행자를 가지고 있기 때문이다. 이는 목적지별로 모든 출발지와 여행 수단을 합산하여 확인할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- st_apply(odm, 2, sum)\nwhich.max(d[[1]])\n# [1] 33\n```\n:::\n\n\n다른 애그리게이션도 실행할 수 있다. 예를 들어 OD(102 x 102)의 총통행량을 다음과 같이 구할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(odm, 1:2, sum)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#      Min. 1st Qu. Median Mean 3rd Qu. Max.\n# sum     0       0      0 19.2      19 1434\n# dimension(s):\n#   from  to refsys point                                  values\n# o    1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# d    1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n```\n:::\n\n\n교통 수단별로 출발지 총계를 구할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(odm, c(1,3), sum)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#      Min. 1st Qu. Median Mean 3rd Qu. Max.\n# sum     1    57.5    214  490     771 2903\n# dimension(s):\n#      from  to refsys point                                  values\n# o       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# mode    1   4     NA FALSE                       bicycle,...,train\n```\n:::\n\n\n교통 수단별로 도착지 총계를 구할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(odm, c(2,3), sum)\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#      Min. 1st Qu. Median Mean 3rd Qu.  Max.\n# sum     0      13    104  490     408 12948\n# dimension(s):\n#      from  to refsys point                                  values\n# d       1 102 WGS 84 FALSE MULTIPOLYGON (...,...,MULTIPOLYGON (...\n# mode    1   4     NA FALSE                       bicycle,...,train\n```\n:::\n\n\n모드별로 합산된 출발지 총계를 구할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\no <- st_apply(odm, 1, sum)\n```\n:::\n\n\n모드별로 합산된 도착지 총계를 구할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- st_apply(odm, 2, sum)\n```\n:::\n\n\n`o`와 `d`를 결합한 후 함께 플롯할 수 있다(그림 7.17).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- (c(o, d, along = list(od = c(\"origin\", \"destination\"))))\nplot(x, logz = TRUE)\n```\n:::\n\n\n![출발지별 총 통근(왼쪽) 또는 목적지별 총 통근(오른쪽)](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-odjoined-1.png){#fig-7-17}\n\n이 지도가 현상의 본질을 호도할 수 있다는 우려가 있을 수 있다. 왜냐하면 실질적인 값의 크기(컬러) 뿐만 아니라 구역의 면적 역시 시각적으로 느끼는 양의 크기에 영향을 주기 때문이다. 이러한 점을 감안하여 밀도값(카운트/$\\text{km}^2$)을 계산하여 나타낼 수 있다(그림 7.18)(역자주: 지도학적 원칙으로 보자면, 카운트를 코로플레스 맵으로 나타내는 것은 적절하지 않다. 따라서 보다 좋은 방법은 카운트를 도형표현도로 나타내는 것이다).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(units)\na <- set_units(st_area(st_as_sf(o)), km^2)\no$sum_km <- o$sum / a\nd$sum_km <- d$sum / a\nod <- c(o[\"sum_km\"], d[\"sum_km\"], along = \n        list(od = c(\"origin\", \"destination\")))\nplot(od, logz = TRUE)\n```\n:::\n\n\n![출발지별 총 통근 밀도(왼쪽) 또는 목적지별 총 통근 밀도(오른쪽)](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-odbykm-1.png){#fig-7-18}\n\n카운트를 정규화하는 또 다른 방법은 값을 면적이 아닌 인구수로 나누는 것이다.\n\n### 타이디 어레이 데이터\n\nWickham(2014)의 타이디 데이터 논문은 3차원 데이터를 어레이 데이터 형식보다는 각 행이 (지역, 클래스, 연도, 값)으로 구성된 긴(비정규화된) 테이블 형식으로 처리되는 것이 더 좋다고 제안한다. 이는 가능하기만 하다면 늘 좋은 방법이다. 그러나 이 옵션이 불가능한 경우가 있는데, 기본 처리 및 저장의 목적에서 그러하다. 그 이유는 다음과 같다.\n\n-   많은 어레이 데이터는 처음부터 어레이 데이터로 수집되거나 생성된다. 예를 들어, 원격탐사를 통해 수집된 데이터 혹은 기후 모델을 통해 생성된 데이터\n\n-   어레이 형식을 긴 테이블 형태로 전환하는 것이 그 역보다 훨씬 쉽다.\n\n-   긴 테이블 형식의 데이터가 훨씬 더 많은 메모리를 요구한다. 왜냐하면 $n_i$가 디멘션 $i$의 기수(크기)일 때, 디멘션 값이 차지하는 메모리 공간은 $O(\\sum{n_i})$가 아니라 $O(\\prod{n_i})$로 주어지기 때문이다.\n\n-   결측값이 있는 셀이 삭제되면, 긴 테이블 형식은 어레이 형식에 내재된 인덱싱을 상실하게 된다.\n\n이 주장을 극단적으로 표현하자면, 모든 이미지, 비디오 및 음성 데이터가 어레이 형식으로 저장된다고 가정해 보자. 실제로 이를 긴 테이블 형식으로 저장해야 한다고 주장하는 사람은 거의 없을 것이다. 그럼에도 불구하고 `tsibble`(Wang et al. 2022)과 같은 R 패키지는 긴 테이블 형식을 취하고 있는데, 동일한 시간 스텝을 가진 다수의 공간적 피처에 대해 순서를 매기는 것은 매우 모호한 작업임에도 불구하고 어쨋던 인덱싱을 해야한다는 문제점이 있을 수 있다. 이러한 문제는 `stars`에서 제공하는 어레이 형식을 사용함으로써 *자동*으로 해결된다. 물론 조밀한 어레이를 사용해야한다는 대가를 치루는 것이기도 하다.\n\n`stars` 패키지는 어레이 집합을 처리하는 문제에 있어서는 타이디 데이터 원칙(tidy manifesto)을 따르려 하며, 특히 하나 이상의 차원이 공간 및/또는 시간을 참조하는 경우에 대해서는 특별히 더 그러하다.\n\n### 벡터 데이터 큐브를 위한 파일 포멧\n\n정규 테이블 형식(긴 테이블 형식을 포함)은 하나의 대안이지만 사용하기에는 불편하다. 위의 출발지-목적지 데이터 예제와 13장에서 다를 내용은 테이블 형식에서 벡터 데이터 큐브를 재구성하는 것이 매우 복잡하다는 점을 잘 보여준다. NetCDF나 Zarr와 같은 어레이 형식은 어레이 데이터를 저장하기 위해 설계되었다. 그러나 이러한 형식은 모든 데이터 구조에 사용할 수 있으며, 일단 작성된 파일은 재사용하기 어려운 위험이 있다. 포인트, (멀티)라인스트링 또는 (멀티)폴리곤으로 구성된 단일 지오메트리 디멘션을 가진 벡터 큐브의 경우, CF 규칙(Eaton et al. 2022)은 이러한 지오메트리를 인코딩하는 방법을 설명한다. `stars::read_mdim`과 `stars::write_mdim`은 이러한 규칙을 따르는 벡터 데이터 큐브를 읽고 쓸 수 있다.\n\n## 래스터-벡터 전환과 벡터-래스터 전환\n\n1.3절에서 래스터-벡터 변환과 벡터-래스터 변환에 대한 몇 가지 예제를 이미 다루었다. 이 절에서는 코드와 예제를 추가하고자 한다.\n\n### 벡터-래스터 전환\n\n`st_as_stars` 함수는 객체를 `stars` 객체로 변환하는 메소드로로 설계되었다. 그러나 모든 `stars` 객체가 래스터 객체인 것은 아니며, `sf` 객체에 이 메소들 적용하면 지오메트리를 공간적(벡터) 디멘션으로 하고 속성을 속성 디멘션으로 가지는 벡터 데이터 큐브가 생성된다. 피처 *지오메트리*(`sfc`) 객체가 주어지면, `st_as_stars` 함수는 이를 래스터한다(섹션 7.8과 그림 7.19).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile <- system.file(\"gpkg/nc.gpkg\", package=\"sf\")\nread_sf(file) |> \n    st_geometry() |>\n    st_as_stars() |>\n    plot(key.pos = 4)\n```\n:::\n\n\n![st_as_stars 함수를 활용한 백터 지오메트리의 래스터화](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-asstars-1.png){#fig-7-19}\n\n`st_as_stars` 함수는 셀 크기, 셀 수 및/또는 범위를 제어하는 파라미터를 설정할 수 있다. 반환되는 셀 값은 지오메트리 밖에 중심점이 있는 셀의 경우는 0이고, 지오메트리 내부 또는 경계에 중심점이 있는 셀의 경우는 1이다. 기존 피처를 래스터화하는 것은 `st_rasterize` 함수를 사용하여 수행되며, 이는 그림 1.5에서도 볼 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nread_sf(file) |>\n    mutate(name = as.factor(NAME)) |>\n    select(SID74, SID79, name) |>\n    st_rasterize()\n# stars object with 2 dimensions and 3 attributes\n# attribute(s):\n#      SID74           SID79            name       \n#  Min.   : 0      Min.   : 0      Sampson :  655  \n#  1st Qu.: 3      1st Qu.: 3      Columbus:  648  \n#  Median : 5      Median : 6      Robeson :  648  \n#  Mean   : 8      Mean   :10      Bladen  :  604  \n#  3rd Qu.:10      3rd Qu.:13      Wake    :  590  \n#  Max.   :44      Max.   :57      (Other) :30952  \n#  NA's   :30904   NA's   :30904   NA's    :30904  \n# dimension(s):\n#   from  to offset   delta refsys point x/y\n# x    1 461  -84.3  0.0192  NAD27 FALSE [x]\n# y    1 141   36.6 -0.0192  NAD27 FALSE [y]\n```\n:::\n\n\n라인과 포인트 지오메트리고 이와 유사하게 래스터화할 수 있다(그림 7.20).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_sf(file) |>\n    st_cast(\"MULTILINESTRING\") |>\n    select(CNTY_ID) |>\n    st_rasterize() |>\n    plot(key.pos = 4)\n```\n:::\n\n\n![노스캐롤라이나 카운티 경계를 래스터로 전환하기](https://r-spatial.org/book/07-Introsf_files/figure-html/fig-lineras-1.png){#fig-7-20}\n\n## 좌표변환 및 좌표전환\n\n### `st_crs` 함수\n\n`sf` 또는 `stars` 클래스의 공간 객체는 CRS(좌표참조계)를 포함하고 있다. `st_crs` 함수를 사용하여 해당 객체의 CRS를 확인하거나 다른 CRS로 교체할 수 있다. 또한, `st_set_crs`함수를 사용하여 CRS를 설정하거나 교체할 수 있다. CRS는 EPSG 코드로 설정할 수 있으며, 예를 들어 `st_crs(4326)`는 `st_crs('EPSG:4326')`로 변환된다. 또는 \"+proj=utm +zone=25 +south\"와 같은 PROJ.4 문자열, \"WGS84\"와 같은 이름, 또는 \"OGC\"와 같이 기관명이 앞에 붙은 이름으로 설정할 수 있다. 대안으로는 WKT, WKT-2(섹션 2.5) 또는 PROJJSON 형식의 CRS 정의가 있다. `st_crs` 함수에 의해 반환된 객체는 다음의 두 개의 필드를 포함한다.\n\n-   `wkt`: WKT-2 형식으로 표현된 CRS\n\n-   `input`: 사용자 입력(있는 경우), 또는 CRS에 대한 인간가독설명(가능한 경우)\n\nPROJ.4 문자열은 일부 CRS을 정의하는 데 사용할 수 있지만, CRS를 대표하는 데는 사용할 수 없다. 예를 들어, `crs` 객체의 WKT-2를 `$proj4string` 메서드를 사용하여 `proj4string`으로 전환하려면 다음과 같이 할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- st_crs(\"OGC:CRS84\")\nx$proj4string\n# [1] \"+proj=longlat +datum=WGS84 +no_defs\"\n```\n:::\n\n\n그런데, 이 과정이 성공적으로 이루어졌다 하더라도, 보통 정보의 손실이 수반되고 가역적으로 전환되지 않는다. PROJ.4 문자열을 CRS를 정의하기 위해 사용하는 경우(예를 들어 파라미터가 지정되어 있는 투영 CRS), 투영 CRS가 WGS84 데이텀과 관련되는 한은 문제가 없다.\n\n### `st_transform`함수와 `st_project` 함수\n\n`sf` 또는 `stars` 객체에 대한 좌표 변환이나 좌표 전환은 `st_transform`함수를 사용하여 수행된다. 이 함수의 첫 번째 아규먼트는 CRS가 설정된 `sf` 또는 `stars` 클래스의 공간 객체이고, 두 번째 아규먼트는 `crs` 객체(또는 `st_crs` 함수로 변환 가능한 값)이다. 소스 `crs`에서 타깃 `crs`로 변환 혹은 전환할 수 있는 방법이 여러 가지인 경우, PROJ는 가장 높은 명시(declared) 정확도를 가진 방법을 선택한다. 더 세밀한 옵션은 7.7.5에서 설명된다. 규칙 래스터 디멘션을 가진 `stars` 객체의 경우, `st_transform` 함수는 좌표만 변환하며 항상 곡선형 그리드를 생성한다. 새로운 CRS에서 규칙 래스터를 생성하려면 재그리딩(regridding)을 사용하는 `st_warp` 함수를 활용하면 된다(Section 7.8).\n\n`sf`나 `stars` 객체가 아닌 상황에서의 좌표 변환 혹은 좌표 전환은 저수준(lower-level) 함수인 `sf_project`를 통해 이루어진다. 이 함수는 좌표가 담긴 행렬과 소스 및 타깃 CRS(`crs`)를 입력으로 받아, 변환된 혹은 전환된 좌표를 반환한다.\n\n### `sf_proj_info` 함수\n\n`sf_proj_info` 함수는 PROJ 소프트웨어에서 사용 가능한 투영, 타원체, 단위 및 본초 자오선에 대한 정보를 조회하는 데 사용된다. 이 함수는 단일 매개변수 `type`을 받으며, 이 매개변수는 다음과 같은 값을 가질 수 있다.\n\n-   `type = \"proj\"`: 사용 가능한 투영법의 짧은 이름과 긴 이름을 나열한다. 짧은 이름은 “+proj=name” 문자열에서 사용할 수 있다.\n\n-   `type = \"ellps\"`: 사용 가능한 타원체를 나열하며, 이름, 긴 이름 및 타원체의 파라미터 정보를 포함한다.\n\n-   `type = \"units\"`: 사용 가능한 길이 단위를 나열하고, 미터로의 변환 상수 정보를 포함한다.\n\n-   `type = \"prime_meridians\"`: 본초 자오선을 나열하고, 그리니치 자오선과의 상대적 위치 정보를 포함한다.\n\n### 데이텀 그리드, proj.db, cdn.proj.org. 로컬 캐쉬\n\n데이텀 그리드(2.4절)는 로컬에 설치하거나 PROJ 측량 그리드 CDN(https://cdn.proj.org/)에서 불러 올 수 있다. 로컬에 설치된 경우, 데이텀 그리드는 PROJ 검색 경로를 통해 불러올 수 있는데, 이 경로는 다음과 같이 표시된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_proj_search_paths()\n# [1] \"/home/edzer/.local/share/proj\" \"/usr/share/proj\"\n```\n:::\n\n\n핵심 PROJ 데이터베이스는 `proj.db`로, 일반적으로 다음 위치에서 불러올 수 있는 sqlite3 데이터베이스이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste0(tail(sf_proj_search_paths(), 1), .Platform$file.sep, \n       \"proj.db\")\n# [1] \"/usr/share/proj/proj.db\"\n```\n:::\n\n\n각 PROJ 릴리스에 포함된 EPSG 데이터베이스 스냅샷의 버전은 `proj.db`의 `\"metadata\"` 테이블에 명시되어 있으며, **sf**에서 사용되는 PROJ 런타임의 버전은 다음과 같이 표시된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_extSoftVersion()[\"PROJ\"]\n#    PROJ \n# \"9.1.1\"\n```\n:::\n\n\n특정 좌표 변환에 필요한 데이텀 그리드가 로컬에 없을 경우, PROJ는 PROJ CDN의 온라인 데이텀 그리드를 검색하게 된다. 단 아래의 결과가 `TRUE`인 경우이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_proj_network()\n# [1] FALSE\n```\n:::\n\n\n디폴트는 FALSE로 설정되어 있지만, 이를 TRUE로 바꾸면 해당 네트워크 리소스의 URL을 반환한다. 이 리소스는 더 빠르거나 제한이 덜한 다른 리소스로 설정할 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_proj_network(TRUE)\n# [1] \"https://cdn.proj.org\"\n```\n:::\n\n\nCDN에서 데이텀 그리드를 조회한 후, PROJ는 조회된 그리드의 *일부분*(디폴트는 전체 그리드가 아님)을 로컬 캐시에 기록한다. 이 캐시는 사용자 디렉토리의 또 다른 sqlite3 데이터베이스로 다음과 같이 표시된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist.files(sf_proj_search_paths()[1], full.names = TRUE)\n# [1] \"/home/edzer/.local/share/proj/cache.db\"\n```\n:::\n\n\n차후의 데이텀 그리드 조회는 이 데이터베이스에 대해 우선적으로 이루어진다.\n\n### 변환 파이프라인\n\n내부적으로 PROJ는 소스 CRS에서 타겟 CRS로 가는 오퍼레이션 시퀀스를 나타내기 위해 이른바 *좌표 오퍼레이션 파이프라인*(coordinate operation pipeline)을 사용한다. 소스에서 타겟으로 가는 여러 옵션이 있을 경우, `st_transform` 함수는 가장 높은 정확도를 가진 옵션을 선택한다. 사용 가능한 옵션을 조회하려면 `sf_proj_pipelines` 함수를 사용하면 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(p <- sf_proj_pipelines(\"OGC:CRS84\", \"EPSG:22525\"))\n# Candidate coordinate operations found:  5 \n# Strict containment:     FALSE \n# Axis order auth compl:  FALSE \n# Source:  OGC:CRS84 \n# Target:  EPSG:22525 \n# Best instantiable operation has accuracy: 2 m\n# Description: axis order change (2D) + Inverse of Corrego Alegre\n#              1970-72 to WGS 84 (2) + UTM zone 25S\n# Definition:  +proj=pipeline +step +proj=unitconvert +xy_in=deg\n#              +xy_out=rad +step +inv +proj=hgridshift\n#              +grids=br_ibge_CA7072_003.tif +step\n#              +proj=utm +zone=25 +south +ellps=intl\n```\n:::\n\n\n해당 변환에서 가장 높은 정확도를 보이는 파이프라인이 요약되어 있고 특정한 데이텀 그리드의 사용이 지정되어 있음을 알 수 있다. 만약 네트워크 검색을 활성화하지 않았다면, 다른 결과를 얻었을 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf_proj_network(FALSE)\n# character(0)\nsf_proj_pipelines(\"OGC:CRS84\", \"EPSG:22525\")\n# Candidate coordinate operations found:  5 \n# Strict containment:     FALSE \n# Axis order auth compl:  FALSE \n# Source:  OGC:CRS84 \n# Target:  EPSG:22525 \n# Best instantiable operation has accuracy: 2 m\n# Description: axis order change (2D) + Inverse of Corrego Alegre\n#              1970-72 to WGS 84 (2) + UTM zone 25S\n# Definition:  +\n```\n:::\n\n\n이 경우에는 데이텀 그리드에 대한 사항이 누락되어 있음을 볼 수 있다. `sf_proj_pipelines`이 반환하는 객체는 서브클래스화된 데이터 프레임으로, 다음과 같은 열을 포함한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(p)\n# [1] \"id\"           \"description\"  \"definition\"   \"has_inverse\" \n# [5] \"accuracy\"     \"axis_order\"   \"grid_count\"   \"instantiable\"\n# [9] \"containment\"\n```\n:::\n\n\n예를 들어 다음과 같이 정확도를 나열할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np |> pull(accuracy)\n# [1]  2  5  5  8 NA\n```\n:::\n\n\n여기서 NA는 \"대략적인 정확도\"를 의미하며, 이는 30\\~120m 범위 내의 한 값을 가진다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np |> filter(is.na(accuracy))\n# Candidate coordinate operations found:  1 \n# Strict containment:     FALSE \n# Axis order auth compl:  FALSE \n# Source:  OGC:CRS84 \n# Target:  EPSG:22525 \n# Best instantiable operation has only ballpark accuracy \n# Description: Ballpark geographic offset from WGS 84 (CRS84) to\n#              Corrego Alegre 1970-72 + UTM zone 25S\n# Definition:  +proj=pipeline +step +proj=unitconvert +xy_in=deg\n#              +xy_out=rad +step +proj=utm +zone=25\n#              +south +ellps=intl\n```\n:::\n\n\n`st_transform` 함수가 선택한 가장 정확한 파이프라인이 디폴트이지만, `pipeline` 아규먼트를 지정하면 결과를 바꿀 수도 있다. 이 경우 `p$definition`에 있는 옵션 중 하나를 선택하면 된다.\n\n### 축 순서와 방향\n\n2.5절에서 언급한 것처럼, EPSG:4326은 첫 번째 축이 위도와 관련되고 두 번째 축이 경도와 관련되도록 정의한다. 이것은 수많은 다른 타원체 CRS에서도 마찬가지이다. 이러한 방식은 해당 기관(EPSG)이 규정한 것이지만, 현재 대부분의 데이터셋은 이러한 방식으로 저장되지 않는다. 대부분의 다른 소프트웨어와 마찬가지로, **sf** 패키지는 이를 무시하고 디폴트로 타원체 좌표 쌍을 (경도, 위도)로 해석한다. 하지만 해당 기관의 규정을 준수하는 데이터 원천(예를 들어 WFS 서비스)이 생산한 데이터를 읽어야 할 경우 다음과 같이 지정할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_axis_order(TRUE)\n```\n:::\n\n\n이렇게 하면 sf가 GDAL과 PROJ 루틴을 호출할 때 규정 준수(위도, 경도 순서)가 항상 전제되게 할 수 있다. 이러한 규정 준수에 많은 문제가 발생할 수 있다고 예상되며, 예를 들어 데이터를 플로팅할 때 문제가 드러난다. sf 객체를 위한 플롯 메소드는 축 순서 규정을 준수하며 플로팅 전에 변환 파이프라인 `\"+proj=pipeline +step +proj=axisswap +order=2,1\"`을 사용하여 위경도의 순서를 바꾸지만, `ggplot2` 패키지의 `geom_sf`는 이러한 수정 과정을 거치지 않는다. 앞서 언급한 바와 같이, `EPSG:4326`에서 발견되는 축 순서 상의 모호성은 `OGC:CRS84`로 교체하면 모두 해결된다.\n\n축의 순서와는 다른 문제로, 모든 CRS가 북쪽과 동쪽 방향을 양의 값으로 지정하지는 않는다는 점 또한 매우 중요하다. R의 대부분의 플로팅 함수는 위와는 반대로 정의된 축을 가진 데이터와는 제대로 작동하지 않는다. 축의 방향과 단위에 대한 정보는 다음과 같이 검색할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(4326)$axes\n#                 name orientation\n# 1  Geodetic latitude           1\n# 2 Geodetic longitude           3\nst_crs(4326)$ud_unit\n# 1 [°]\nst_crs(\"EPSG:2053\")$axes\n#       name orientation\n# 1  Westing           4\n# 2 Southing           2\nst_crs(\"EPSG:2053\")$ud_unit\n# 1 [m]\n```\n:::\n\n\n## 래스터 변환 및 워프\n\n래스터 데이터셋에 대해 `st_transform` 함수를 사용할 때는 다음과 같이 할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntif <- system.file(\"tif/L7_ETMs.tif\", package = \"stars\")\nread_stars(tif) |>\n    st_transform('OGC:CRS84')\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max.\n# L7_ETMs.tif     1      54     69 68.9      86  255\n# dimension(s):\n#      from  to refsys point                    values x/y\n# x       1 349 WGS 84 FALSE [349x352] -34.9,...,-34.8 [x]\n# y       1 352 WGS 84 FALSE [349x352] -8.04,...,-7.95 [y]\n# band    1   6     NA    NA                      NULL    \n# curvilinear grid\n```\n:::\n\n\n이제 곡선형 그리드가 생성되는 것을 볼 수 있으며, 이는 새로운 CRS에 의거해 모든 그리드 셀의 좌표가 재계산되므로 더 이상 규칙 그리드로 존재할 수 없음을 의미한다. 이러한 데이터를 플로팅하면 속도가 극단적으로 느린데, 각 그리드 셀에 대해 작은 폴리곤이 우선적으로 계산되고 그 후에 플로팅되기 때문이다. 이것의 이점은 정보가 손실되지 않는다는 것으로 투영 이후에도 그리드 셀의 값은 동일하게 유지된다.\n\n규칙 그리드를 투입하여 새로운 CRS에서도 규칙 그리드를 산출하려면 워프(warp) 오퍼레이션을 적용해야 한다. 즉, 새로운 위치에 그리드를 재생성하고 새로운 그리드 셀에 값을 할당하는 특정한 규칙을 사용해야 한다. 이러한 규칙에 가장 가까운 값을 사용하거나 어떤 형태의 보간법을 사용하는 것이 포함될 수 있다. 이 오퍼레이션은 정보의 손실이 발생하며 불가역적이다.\n\n워프를 수행하는 가장 좋은 방법은 타깃 그리드를 `stars` 객체로 지정하는 것이다. 타깃 CRS만 지정할 경우, 문제에 전혀 적합하지 않은 기본 옵션이 선택될 수 있다. 타깃 CRS만 사용하는 예시 워크플로우는 다음과 같다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_stars(tif) |>\n    st_warp(crs = st_crs('OGC:CRS84')) |>\n    st_dimensions()\n#      from  to offset     delta refsys x/y\n# x       1 350  -34.9  0.000259 WGS 84 [x]\n# y       1 352  -7.95 -0.000259 WGS 84 [y]\n# band    1   6     NA        NA     NA\n```\n:::\n\n\n이는 상당한 근사 래스터를 생성하지만, 변환도 상대적으로 작다. 소스 래스터와 정확히 동일한 행과 열을 갖는 타깃 래스터를 먼저 생성하려는 워크플로우의 경우 다음과 같이 하면 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- read_stars(tif)\ngrd <- st_bbox(r) |>\n        st_as_sfc() |>\n        st_transform('OGC:CRS84') |>\n        st_bbox() |>\n        st_as_stars(nx = dim(r)[\"x\"], ny = dim(r)[\"y\"])\nst_warp(r, grd)\n# stars object with 3 dimensions and 1 attribute\n# attribute(s):\n#              Min. 1st Qu. Median Mean 3rd Qu. Max. NA's\n# L7_ETMs.tif     1      54     69 68.9      86  255 6180\n# dimension(s):\n#      from  to offset     delta refsys x/y\n# x       1 349  -34.9   0.00026 WGS 84 [x]\n# y       1 352  -7.95 -0.000259 WGS 84 [y]\n# band    1   6     NA        NA     NA\n```\n:::\n\n\n여기서 $x$와 $y$의 방향의 그리드 해상도가 조금 달라진 점을 확인할 수 있다.\n\n## 연습문제\n\nR을 사용하여 다음 연습문제를 해결하시오.\n\n1.  `nc` 카운티 중 `LINESTRING(-84 35, -78 35)`와 교차하는 카운티의 이름을 찾아보라. 이를 위해 \\[를 사용하고, 대안으로 `st_join` 함수를 사용하라.\n\n2.  `sf_use_s2(FALSE)`를 설정한 후에 이 작업을 반복하고, 차이를 *계산*하라(힌트: `setdiff`를 사용). 차이가 나타나는 카운티는 색상 ‘#88000088’로 채색하라.\n\n3.  두 지점 사이의 직선과 대권을 하나의 플롯에 그려보라. 현재 사용 중인 투영법에서는 R은 직선을 항상 직선으로 그린다는 점을 명심하라. `st_segmentize` 함수를 사용하여 직선 상이나 타원 좌표의 대원(큰 원) 상에 포인트를 추가하라.\n\n4.  NDVI(정규화 차이 식생 지수)는 `(NIR-R)/(NIR+R)`로 계산되며, 여기서 NIR은 근적외선 밴드, R은 빨간색 밴드이다. `L7_ETMs.tif` 파일을 객체 `x`에 읽고, `split(x, \"band\")`를 사용하여 밴드 차원을 속성으로 분리하라. 그런 다음 NIR(밴드 4)과 R(밴드 3) 속성을 직접 사용하는 표현식을 사용하여 이 객체에 NDVI 속성을 추가하라.\n\n5.  `L7_ETMs.tif` 이미지에 대해 밴드 차원을 축소하여 NDVI를 계산하라. 이를 위해 `st_apply` 함수와 `ndvi = function(x) { (x[4]-x[3])/(x[4]+x[3]) }` 함수를 사용하라. 결과를 플로팅하고, 결과를 GeoTIFF 형식으로 저장하라.\n\n6.  `L7_ETMs.tif`에서 읽은 `stars` 객체를 `st_transform` 함수를 사용하여 `OGC:CRS84`로 변환하라. 객체를 출력하라. 이것이 규칙 그리드인가? 첫 번째 밴드를 `axes=TRUE` 및 `border=NA` 아규먼트를 사용하여 플로팅하고, 왜 이렇게 시간이 오래 걸리는지 설명하라.\n\n7.  `L7_ETMs.tif` 객체를 `st_warp` 함수를 사용하여 `OGC:CRS84`로 변환하고, 결과 객체를 `axes=TRUE`로 플로팅하라. 왜 `st_transform` 함수에 비해 플롯이 훨씬 더 빨리 생성되는지 설명하라.\n\n8.  래스터 `L7_ETMs`의 벡터 재현을 사용하여 `POINT(293716 9113692)`를 중심으로 반지름 75m인 원형 영역과의 인터센션을 플로팅하고, 이 원의 면적-가중 평균 픽셀 값을 계산하라. 벡터 데이터를 사용하여 애그리게이트한 값과 래스터 데이터를 사용하여 애그리게이트한 값을 (디폴트인 `exact=FALSE` 및 `exact=TRUE` 사용) 비교하라. 차이점을 설명하라.\n",
    "supporting": [
      "07_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}