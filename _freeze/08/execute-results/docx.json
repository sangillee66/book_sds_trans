{
  "hash": "7971afab05aa724242267be135acfe00",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# 공간데이터의 플로팅 {#sec-plotting}\n\n타임라인과 더불어 지도는 가장 강력한 그래프 유형 중 하나다. 이는 우리가 플롯의 공간 속에서 ‘현재 내가 있는 곳’이나 ‘한때 있었던 곳’을 즉각적으로 연관 지을 수 있기 때문일 것이다. 시각화를 다룬 최근의 두 권의 책(Healy, 2018; Wilke, 2019)에서도 지리공간 데이터와 지도의 시각화에 관한 장을 각각 포함하고 있다. 여기서는 어떤 지도가 좋은지 혹은 나쁜지를 평가하려는 것이 아니라, 지도를 만드는 다양한 방법과 그 과정에서 마주치는 여러 도전 과제, 그리고 이를 완화할 수 있는 방안을 살펴보고자 한다.\n\n## 모든 지도는 투영법을 가지고 있다. {#sec-every}\n\n지구는 둥글지만, 플로팅 장치는 평면이다. 2.2.2절에서 언급했듯이, 어떤 방식으로든 평면 장치에 지구를 플로팅하는 순간 우리는 특정한 투영법을 적용한 것이다. 즉, 타원체 좌표를 특정한 방식으로 데카르트 좌표로 전환하는 것이다. 이는 우리가 '아무것도 하지 않았다고' 생각하는 경우(역자주: 투영법을 적용하지 않았다고 생각하는 경우)(그림 8.1의 왼쪽)나, 우주에서 본 것처럼 세상을 '있는 그대로' 보여준다고 생각하는 경우(그림 8.1의 오른쪽)에도 마찬가지이다. 평면상의 모든 지도는 투영법을 갖는다.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![국가 경계: 왼쪽은 경위도를 x, y 좌표로 선형변환한 플라트 카레(Plate Carrée) 도법이며, 오른쪽은 무한히 먼 거리에서 지구를 바라본 것 처럼 표현한 정사 도법이다.](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-world-1.png){#fig-8-1}\n\n왼쪽 지도는 다음의 코드로 작성하였다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(rnaturalearth)\nw <- ne_countries(scale = \"medium\", returnclass = \"sf\")\nplot(st_geometry(w))\n```\n:::\n\n\n\n지구 전체를 타원체 좌표로 표현할 때, 사용되는 투영법이 기본 투영법임은 다음과 같이 확인할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_is_longlat(w)\n# [1] TRUE\n```\n:::\n\n\n\n그림 8.1(왼쪽)에 사용된 투영법은 등장방형 도법(정거원통 도법)으로, 경도를 $x$축, 위도를 $y$축에 선형적으로 대응시켜 지도에서 가로와 세로 방향의 거리 단위가 동일하게 유지되도록 한다.(역자주: 지구의 동서 범위는 360°, 남북 범위는 180°이므로, 이 지도의 가로세로비는 정확히 2:1이다.) 따라서 지구의 일부 영역을 이 도법으로 플로팅할 때에도 동서와 남북 방향의 거리 단위가 동일하게 유지되도록 플롯 비율을 선택해야 한다. 이는 비투영 `sf` 또는 `stars` 데이터셋에 대한 `plot()` 메서드의 기본 동작이며, `ggplot2::geom_sf()` 함수의 기본 설정이기도 하다(8.4절).(역자주: 비투영 객체는 경위도 좌표계를 가진 객체를 의미하며, 이를 `plot()` 메서드를 통해 플롯하면 기본적으로 경위도값을 평면 좌표처럼 취급한다. 지구 전체에 대해 이 방식으로 플롯하면 시각적으로 등장방형 도법과 동일하게 보인다.)\n\n플로팅 전에 투영법을 적용해 데이터를 변형할 수도 있다. 예를 들어, 독일을 플로팅하려면 국가 경계 `sf` 객체로 불러온 후, `st_transform()` 함수로 원하는 투영법을 적용한다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDE <- st_geometry(ne_countries(country = \"germany\",\n                              returnclass = \"sf\"))\nDE |> st_transform(\"+proj=eqc +lat_ts=51.14 +lon_0=90w\") ->\n    DE.eqc\n```\n:::\n\n\n\n여기서 `eqc`는 PROJ의 ‘등장방형 도법’을 의미한다. `lat_ts`는 투영 파라미터로, 표준 위선(*참인 축척*이 나타나는 위선)의 위치를 지정한다. 이 표준 위선에서는 동서와 남북 방향의 길이 단위가 동일해진다. 일반적으로 이 값은 지도의 바운딩 박스의 중간 지점에 해당한다.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n``` r\n# [1] 51.14\n```\n\n그림 8.2의 두 지도를 비교해 보면, 축 값만 다를 뿐 두 지도는 동일하다. 왼쪽 지도는 타원체 좌표(도 단위)를, 오른쪽 지도는 투영 좌표(데카르트 좌표)(미터 단위)를 사용한다.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![등장방형 도법이 적용된 독일. 왼쪽 지도의 단위는 도이고 정거원통 도법이 적용된 오른쪽 지도의 단위는 미터이다.](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-eqc-1.png){#fig-8-2}\n\n### 데이터에 맞는 투영법 선정\n\n안타깝게도 만능 해법은 없다. 모든 지점 모든 방향에서 축척이 동일한 투영법은 없으며, 이 속성은 오직 지구본만 갖는다. 널리 쓰이는 투영법은 보통 다음 중 하나를 보존한다:\n\n-   면적: 정적 도법\n\n-   형태: 정형 도법(예: *메르카토르 도법*)(역자주: 형태가 유지되기 위해서는 각도가 유지되어야 하기 때문에 정각 도법이라고도 부른다.)\n\n-   거리의 일부 속성: *등장방형* 도법은 모든 지점의 경선 방향 거리를, *정거방위* 도법은 투영 원점으로부터의 거리를 보존한다.)\n\n또한 일부 도법은 두 속성의 절충을 지향한다.(역자주: 주로 면적과 형태를 절충하며, 이를 절충 도법이라 부른다. 대표적으로 로빈슨 도법(Robinson projection)과 빈켈 트리펠 도법(Winkel Tripel Projection)이 있다.) 투영 파라미터는 지도에서 어떤 지역을 중앙과 가장자리에 배치할지, 어느 지역을 위와 아래에 둘지, 어디가 가장 크게 확대될지를 결정한다. 이러한 선택을 돕는 가이드라인은 있으나 절대적인 규준은 없으며, 맥락에 따라 정치적 결단에 가까울 때도 있다.\n\n다양한 투영법을 적용해 결과를 비교해 보는 일은 흥미롭고 교육적이다. 다만 지도 제작의 주된 목적이 투영법 자체에 대한 관심 충족이나 지식 축적이 아니라면, 널리 알려졌거나 최소한 덜 생소한 투영법을 선택해 ‘어떤 투영법을 고를 것인가’에 머무르기 보다 ‘선택한 투영법을 어떻게 적용할 것인가’로 논의를 진전시키는 편이 바람직하다. 한편 세계지도를 위한 투영법 선택과 관련해서는 일정한 합의가 있다. 대부분의 경우, 정적 도법이 플라트 카레 도법이나 웹 메르카토르 도법보다 선호된다.\n\n## 포인트, 라인, 폴리곤, 그리드 셀 플로팅\n\n지도는 통계 데이터를 플로팅하는 특별한 형식으로 볼 수 있으므로, 플로팅의 일반 규칙이 지도에도 그대로 적용된다. 다만 지도 특유의 문제가 존재하며, 예를 들면 다음과 같다.\n\n-   매우 작은 폴리곤의 경우, 플로팅 시 사라질 수 있다.\n\n-   데이터에 따라 지도 심볼이 서로 겹쳐 일부 심볼이 부분적으로만 보일 수 있다. 이때 투명도를 조정하면 겹친 심볼을 식별하는 데 도움이 된다.\n\n-   포인트 피처 또는 포인트 심볼을 플로팅하는 경우, 포인트가 쉽게 겹쳐 다른 포인트 뒤에 완전히 가려질 수 있다. 이럴 때는 커널 밀도 지도(11장)가 더 유용할 수 있다.\n\n-   라인 피처 또는 라인 심볼을 플로팅하는 경우, 색이 잘 구분되지 않을 수 있으며, 라인 너비와 무관하게 서로 겹칠 수 있다.\n\n### 컬러\n\n컬러 심볼이 적용된 폴리곤을 플로팅할 때는 폴리곤 경계를 표시할지 생략할지를 선택해야 한다. 경계선이 지나치게 눈에 띄면 회색 톤이나 폴리곤 컬러와 충돌이 덜한 색을 경계에 적용할 수 있다. 반대로 경계를 완전히 생략하면 (거의) 동일한 컬러의 폴리곤을 시각적으로 구별하기 어렵다. 컬러가 서로 다른 토지 피복 유형을 표현하는 경우에는 경계 생략이 큰 문제가 되지 않을 수 있다. 그러나 컬러가 집계값(예: 인구수)의 크기를 표현한다면 지도 오독을 유발할 수 있다.(역자주: 인구 1,000명인 폴리곤이 서로 인접해 있을 때 경계를 없애면 마치 훨씬 넓은 지역의 인구가 여전히 1,000명인 것처럼 보일 수 있다.) 특히 인구수처럼 공간 외연 속성은 오독의 위험이 크다. 더 나아가, 이러한 속성은 경계를 유지하더라도 폴리곤 내부를 컬러로 채우는 코로플레스 맵(choropleth map)이 본질적으로 적절하지 않을 수 있다. 이는 컬러가 폴리곤이 가진 속성의 크기뿐 아니라 폴리곤의 면적도 함께 전달하기 때문이다.(역자주: 이런 이유로 공간 외연 속성은 코로플레스 맵이 아니라 도형표현도로 나타내는 것이 지도학적으로 합리적이다. 그럼에도 불구하고 총합이나 총빈도를 코로플레스 맵으로 표현한 지도가 인터넷에 넘쳐난다.)\n\n연속형 컬러 스킴(컬러의 단절이 없는 팔레트)은 연속형 공간 현상을 표현할 때 주로 쓰이지만, 지도학적 실용성보다는 시각적 매력도가 더 중요한 채택 이유이다.\n\n-   지도에서 특정 컬러를 범례의 특정 값과 일대일로 맞추는 것은 인간의 시각 한계를 고려할 때 실용성이 크지 않다.(역자주: 연속형 컬러 스킴은 미세한 컬러 차이로 미세한 값 차이를 구분하게 하는데, 효과적인 정보 전달 측면에서 지도학적 실효성이 없다).\n\n-   데이터 값의 범위와 컬러 범위가 비선형적으로 연결되는 일이 흔해, 값의 상대적 차이를 분간하기 더 어렵게 만든다.\n\n따라서 값의 식별보다 공간적 현상의 연속성 재현이 더 중요한 한해 연속형 컬러 스킴의 사용이 정당화될 수 있다. 대표적인 예는 고해상도 DTM(digitnal terrain model, 수치지형모형)을 채색으로 표현하는 경우다. 적절한 컬러 스킴과 팔레트는 `hcl.colors()` 또는 `palette.colors()` 함수에서 찾을 수 있으며, **RColorBrewer**(Neuwirth 2022), **viridis**(Garnier 2021), **colorspace**(Ihaka et al. 2023; Zeileis et al. 2020) 등의 패키지에서도 제공된다.\n\n### 컬러 단절값: `classInt`\n\n연속형 공간적 속성을 제한된 컬러(또는 기호)로 플로팅하려면, 데이터를 몇 개의 계급으로 구분해야 한다. R의 **classInt** 패키지(Bivand 2022)는 이를 수행하는 여러 방법을 제공하며, 기본값은 ‘등개수 분류법(quantile)’이다.(역자주: 등개수 분류법은 각 계급에 동일한 개수의 관측치를 할당하는 방법이다.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(classInt)\n# set.seed(1) if needed ?\nr <- rnorm(100)\n(cI <- classIntervals(r))\n# style: quantile\n#   one of 1.49e+10 possible partitions of this variable into 8 classes\n#   [-2.29,-1.27)  [-1.27,-0.698) [-0.698,-0.426) [-0.426,-0.147) \n#              13              12              13              12 \n#  [-0.147,0.129)    [0.129,0.47)     [0.47,1.06)      [1.06,2.1] \n#              12              13              12              13\ncI$brks\n# [1] -2.290 -1.272 -0.698 -0.426 -0.147  0.129  0.470  1.059  2.105\n```\n:::\n\n\n\n**classInt** 패키지의 `classIntervals()` 함수에서 `n` 인수로 계급 수를 설정하고, `style` 인수로 계급 구분 방식을 선택한다. 사용 가능한 옵션에 ‘fixed’, ‘sd’, ‘equal’, ‘pretty’, ‘quantile’, ‘kmeans’, ‘hclust’, ‘bclust’, ‘fisher’, ‘jenks’이다.(역자주: ‘sd’는 표준편차 분류법, ‘equal’은 등간격 분류법, ‘fisher’와 ‘jenks’는 자연단절 분류법, ‘kmeans’, ‘hclust’, ‘bclust’는 군집화 기반 계급 구분이다.) `n`을 지정했더라도 ‘pretty’를 선택하면 무시될 수 있으며, `n`을 지정하지 않으면 `nclass.Sturges()`가 사용된다. 자동으로 `n`을 선택하는 다른 방법도 제공된다. 관측치가 3,000개를 초과하면, 'fisher'와 'jenks'에서는 10% 샘플을 사용해 계급을 산출한다.\n\n### 그래티큘 및 관련 요소\n\n그래티큘(graticule)은 일정한 위도 또는 경도를 따라 지도상에 그어진 선의 네트워크이다. 그림 1.1에서는 회색으로, 그림 1.2에서는 흰색으로 표시되어 있다. 그래티큘은 기본적으로 위치에 대한 참조물로 지도에 그려진다. 예를 들어 그림 1.1의 첫 번째 지도에서는 플로팅된 지역이 북위 35도, 서경 80도 근처에 있음을 읽을 수 있다. 투영 좌표에 기반한 그래티큘은 모든 선이 직선으로 나타나고 좌표값이 특정 지점으로부터의 거리를 의미하므로, 경위도 그래티큘에 비해 쓰임새가 크지 않다.(역자주: 통상적으로 투영 좌표에 기반한 격자망은 그래티큘이 아니라 그리드(grid)라 부른다.) 그래도 독자가 이러한 그래티큘에 익숙하고 좌표값의 단위가 제공된다면, 크기나 거리를 해석하는데 도움을 줄 수 있다. 그래티큘의 형태는 사용한 투영법의 특성을 반영한다. 따라서 그래티큘을 통해 투영법에 대한 정보를 유추할 수 있다. 등장방형 도법이나 메르카토르 도법은 수직선과 수평선을 갖고, 원추 도법은 경선이 직선(방사형)으로 나타나며 간격이 달라지고, 많은 정적 도법에서는 경선이 곡선으로 표현된다.(역자주: 이는 과도한 일반화일 수 있다. 세계 전체를 나타내는 타원형 형태의 정적 도법(예: 에케르트 IV 도법)에서는 경선이 곡선으로 표현되지만, 정적원통 도법(정축의 경우)에서는 경위선이 모두 직선으로 나타난다).\n\n그림 8.1과 다수의 다른 지도에서 실제 참조물 역할을 하는 것은 그래티큘이라기 보다는 주 경계, 국가 경계, 해안선, 강, 도로, 철도와 같은 지리적 요소들이다. 이러한 요소가 지도상에 적절히 배치된다면 그래티큘은 생략하는 편이 좋다. 그래티큘을 생략하면 일반 플롯의 중요 구성요소인 축, 눈금, 레이블도 사라지므로, 실질적인 지도 데이터로 채울 수 있는 플로팅 공간을 더 확보할 수 있다.\n\n## 베이스 플롯\n\n`sf` 및 `stars` 객체에 적용되는 `plot()` 메서드는 유용한 데이터 탐색용 플롯을 빠르고 간편하게 만들어 준다. 더 높은 품질과 사용자 자율성을 원한다면 **ggplot2**(Wickham et al. 2022), **tmap**(Tennekes 2022, 2018), **mapsf**(Giraud 2022)와 같은 패키지를 활용하면 된다.\n\n`plot()` 메서드의 기본값은 주어진 '모든 것'을 플로팅하는 것이다. 이는 다음을 의미한다.\n\n-   지오메트리만 주어지면(`sfc`), 컬러 없이 지오메트리만 플로팅된다.\n\n-   지오메트리와 속성이 함께 주어지면, 속성 값에 따라 지오메트리에 컬러가 부여된다. `factor`나 `logical` 속성에는 질적 컬러 스킴, 그 외에는 연속형 컬러 스킴이 적용되며 컬러 범례가 추가된다.\n\n-   여러 속성이 주어지면 여러 지도가 플로팅된다. 색상 할당은 각 하위 지도별로 이루어지므로 지도마다 다른 컬러 스킴이 적용된다. 기본값으로 범례는 생략된다.\n\n-   여러 속성을 가진 `stars` 객체의 경우 첫 번째 속성만 플로팅되며, 3차원 래스터 큐브의 경우 세 디멘션을 따라 생성되는 모든 슬라이스가 하위 플롯으로 플로팅된다.\n\n### 플롯에 범례 첨가하기\n\n`stars` 및 `sf` 객체의 `plot()` 메서드는 플롯 영역 한쪽에 컬러 범례를 표시할 수 있다(그림 1.1). 이를 위해 `base::plot()` 함수는 플롯 영역을 두 부분으로 나누어 두 개의 플롯을 생성한다. 하나는 지도, 다른 하나는 범례다. `plot()` 함수는 기본값으로 그래픽 장치를 초기화하며(예: `layout(matrix(1)`) 이는 이후 플롯이 이전의 영역 분할 영향을 받지 않도록 하기 위한 설정이다. 그러나 이 때문에 이미 만들어진 플롯에 그래픽 요소를 추가할 수 없게 된다. 컬러 범례가 있는 기존 플롯에 요소를 *첨가*하려면, 먼저 `plot()` 명령에서 `reset = FALSE`로 장치 초기화를 막고, 이어지는 호출에서는 `add = TRUE`를 사용한다. 예시는 그림 8.3에 제시되어 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nnc <- read_sf(system.file(\"gpkg/nc.gpkg\", package = \"sf\"))\nplot(nc[\"BIR74\"], reset = FALSE, key.pos = 4)\nplot(st_buffer(nc[1,1], units::set_units(10, km)), col = 'NA', \n     border = 'red', lwd = 2, add = TRUE)\n```\n:::\n\n\n\n![범례가 있는 베이스 플롯에 주석 달기](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-figreset-1.png){#fig-8-3}\n\n*단일* `stars` 레이어가 표시되는 경우, 주석 추가는 같은 방식으로 수행된다. 여러 슬라이스를 가진 래스터 큐브의 `stars` 패싯 플롯에 주석을 더하려면, ‘후크(hook)’ 함수를 정의해 각 슬라이스마다 개별적으로 호출되도록 하면 된다.(역자주: ‘후크 함수’는 `stars`의 `plot()`이 패싯의 각 슬라이스를 그린 직후 실행되는 사용자 정의 콜백이다. 이 함수 안에서 `text()`, `points()`, `segments()`, `box()` 같은 베이스 그래픽스를 호출해 레이블, 스케일바, 북침, 보조선 등을 패널마다 자동으로 추가할 수 있다.) 이는 다음과 같이 수행할 수 있으며, 결과는 그림 8.4에 제시되어 있다. 후크 함수는 패싯 파라미터, 패싯 레이블, 바운딩 박스에 접근할 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stars)\n# Loading required package: abind\nsystem.file(\"tif/L7_ETMs.tif\", package = \"stars\") |>\n    read_stars() -> r\nst_bbox(r) |> st_as_sfc() |> st_sample(5) |> \n    st_buffer(300) -> circ\nhook <- function() { \n    plot(circ, col = NA, border = 'yellow', add = TRUE)\n}\nplot(r, hook = hook, key.pos = 4)\n# downsample set to 1\n```\n:::\n\n\n\n![다중 슬라이스를 가진 `stars` 플롯에 주석 달기](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-starshook-1.png){#fig-8-4}\n\n베이스 `plot()` 메서드는 그래픽 장치의 해상도에 접근한다. 따라서 `stars` 및 `stars_proxy` 객체의 고밀도 래스터는 사용 중인 장치에 맞는 해상도로 다운샘플링되어, 해당 밀도로만 픽셀이 플로팅된다.\n\n### 베이스 플롯의 투영법\n\n베이스 `plot()` 메서드는 타원체 좌표를 가진 데이터를 등장방형 도법으로 플로팅하며(그림 8.2), 표준 위선 파라미터의 기본값으로 바운딩 박스의 중간 위도를 사용한다. 이 값을 제어하려면 플로팅 전에 다른 파라미터를 가진 등장방형 도법을 적용하거나 `asp` 파라미터를 직접 설정해 기본 동작을 해제하면 된다(예: `asp = 1`은 플라트 카레 도법의 지도를 생성한다(그림 8.1 왼쪽)). 기존 플롯 위에 후속 플롯을 중첩하려면, 후속 플롯에도 동일한 CRS가 적용되어야 한다. 베이스 `plot` 메서드는 CRS 일치 여부를 검사하지 않는다.\n\n### 컬러와 컬러 단절값\n\n베이스 `plot`에서는 `nbreaks` 인수로 컬러 단절값의 개수를 설정하고, `breaks` 인수로 제 컬러 단절값을 담은 숫자 벡터를 지정하거나, `classInt::classIntervals()` 함수의 `style` 인수에 전달할 스타일 문자열을 지정할 수 있다.\n\n## ggplot2 패키지를 활용한 지도 제작\n\n**ggplot2** 패키지(Wickham et al. 2022; Wickham 2016)는 더 복잡하면서도 보기 좋은 그래프를 만들 수 있게 해준다. 이 패키지에는 **sf** 패키지의 발전과 함께 도입된 `geom_sf` 레이어가 있어, 아름다운 지도를 만드는 데 도움을 준다. 이에 대한 소개는 Moreno와 Basille(2018)에서 찾을 수 있다. 첫 번째 예시는 그림 1.2에 나와 있으며, 이 플롯에 사용된 코드는 다음과 같다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) |> suppressPackageStartupMessages()\nnc.32119 <- st_transform(nc, 32119) \nyear_labels <- \n    c(\"SID74\" = \"1974 - 1978\", \"SID79\" = \"1979 - 1984\")\nnc.32119 |> select(SID74, SID79) |> \n    pivot_longer(starts_with(\"SID\")) -> nc_longer\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + geom_sf(data = nc_longer, aes(fill = value), linewidth = 0.4) + \n  facet_wrap(~ name, ncol = 1, \n             labeller = labeller(name = year_labels)) +\n  scale_y_continuous(breaks = 34:36) +\n  scale_fill_gradientn(colours = sf.colors(20)) +\n  theme(panel.grid.major = element_line(colour = \"white\"))\n```\n:::\n\n\n\n코드를 살펴보면, 패싯 형태의 플롯팅을 위해 사전에 두 개의 속성을 `pivot_longer()` 함수로 스택(길게 피벗)했다는 것을 알 수 있다. 이것이 ‘타이디’ 데이터의 핵심 개념이며, `sf` 객체에 대한 `pivot_longer()` 함수는 지오메트리 열도 함께 스택한다.\n\n**ggplot2** 패키지는 그래픽 *객체*를 먼저 생성한 뒤 플롯팅하므로, 모든 요소의 CRS를 제어할 수 있으며 이후 추가되는 객체는 첫 번째 레이어의 CRS로 자동 변환된다. 또한 회색 배경의 얇은 흰색 선(기본값)으로 그래피큘을 표시하며, 특정 데이텀(기본값은 WGS84)을 사용한다. `geom_sf()`는 다른 `geom`과 결합할 수 있어, 주석 추가 등 다양한 작업을 수행할 수 있다.\n\n**stars** 패키지의 경우, `geom_stars`가 존재하지만, 집필 시점 기준으로 활용성이 다소 제한적이다. 지도 레이아웃과 벡터 데이터 큐브는 `geom_sf`를 사용하고, 규칙 래스터는 `geom_raster`, 직교형 래스터는`geom_rect`를 추가로 사용한다. 사용자가 다운샘플링 비율을 지정하면 다운샘플링을 수행하지만, 화면 크기에 접근해 자동으로 비율을 선택하는 기능은 없다. 이 정도 기능만으로도 충분한 경우가 많으며, 예를 들어 그림 8.5는 다음 명령으로 생성되었다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(stars)\nr <- read_stars(system.file(\"tif/L7_ETMs.tif\", package = \"stars\"))\nggplot() + geom_stars(data = r) +\n        facet_wrap(~band) + coord_equal() +\n        theme_void() +\n        scale_x_discrete(expand = c(0,0)) + \n        scale_y_discrete(expand = c(0,0)) +\n        scale_fill_viridis_c()\n```\n:::\n\n\n\n![**ggplot2**와 `geom_stars`로 제작된 패싯 래스터 플롯](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-ggplotstars-1.png){#fig-8-5}\n\n더 정교한 **ggplot2** 패키지 기반의 `stars` 객체 플롯은 **ggspatial** 패키지(Dunnington, 2022)를 사용해 제작할 수 있다. 더 고품질의 지도를 만들기 위한 옵션으로 **tmap** 패키지가 있으며, **ggplot2**와 직접 호환되지는 않지만 형식적으로 유사한 스타일의 지도를 생성할 수 있다(8.5절).\n\n서로 다른 CRS를 가진 여러 피처 레이어들을 `geom_sf`로 함께 그리면, 모든 레이어가 첫 번째 레이어의 CRS로 변환된다. ‘기준’ CRS를 더 세밀하게 제어하려면 `coord_sf`를 사용하면 된다. 이렇게 하면, 예를 들어 투영 좌표계에서 작업하면서도 `sf` 객체가 *아닌* 일반 `data.frame`으로 주어진 그래픽 요소(예: WGS84에 기반한 타원체 경위도 좌표)를 함께 결합해 표현할 수 있다.\n\n## tmap 패키지를 활용한 지도 제작\n\n**tmap** 패키지(Tennekes, 2022, 2018)는 R에서 공간데이터를 플로팅하는 참선한 접근을 제시한다. 이 패키지는 **grid** 패키지를 기반으로 그래픽 객체를 먼저 구성한 뒤 출력하며, 지도 요소를 `+` 기호로 연결하는 문법은 **ggplot2** 패키지와 유사하지만, 그 외에는 **ggplot2** 패키지와 완전히 독립적이고 상호 호환되지 않는다. 또한 고품질의 전문 지도를 만들 수 있는 다양한 옵션을 제공하며, 여러 기본값도 신중하게 설계되어 있다. 유사한 두 속성의 지도를 한번에 생성하려면 `tm_polygons()` 함수에 두 변수를 동시에 지정하면 된다.(역자주: **ggplot2** 패키지로 지도를 제작하는 접근은 '지도도 그래프다'라는 관점에 서 있다. **tmap** 패키지로 지도를 제작하는 접근은 '지도는 지도다'라는 관점에 서 있다. **tmap** 패키지는 현존하는 여러 언어의 지도 제작 도구 가운데 지도학적 원칙을 가장 충실히 반영한 도구로 평가되며, 이는 R을 선택할 강력한 이유가 된다. 최근 **tmap** 4.0이 도입되면서 문법이 한층 정교해지고 기능이 보완되었다. 아래의 예시 지도들도 4.0 버전으로 제작된 것이다. 자세한 내용은 <https://r-tmap.github.io/tmap/>를 참조하라.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap)\nsystem.file(\"gpkg/nc.gpkg\", package = \"sf\") |>\n    read_sf() |> st_transform('EPSG:32119') -> nc.32119\ntm_shape(nc.32119) + \n    tm_polygons(c(\"SID74\", \"SID79\"), title = \"SIDS\") +\n    tm_layout(legend.outside = TRUE, \n              panel.labels = c(\"1974-78\", \"1979-84\")) +\n    tm_facets(free.scales=FALSE)\n```\n:::\n\n\n\n![**tmap**: `tm_polygons()` 함수에 두 개의 속성을 동시에 지정하여 플로팅하기](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-tmapnc-1.png){#fig-8-6}\n\n또는 `pivot_longer()` 함수로 얻은 긴 테이블 형식 데이터에 `tm_polygons(\"SID\")` 와 `tm_facets(by = \"name\")`를 조합해도 동일한 지도를 생성할 수 있다.\n\n**tmap** 패키지는 `stars` 객체도 지원하며, 예시는 그림 8.7에 제시되어 있다. **tmap** 패키지를 활용한 추가 사례 지도는 14\\~16장에 제시되어 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(r) + tm_raster()\n```\n:::\n\n\n\n![**tmap** 패키지를 활용해 제작한 래스터 플롯](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-tmapstars-1.png){#fig-8-7}\n\n## 인터랙티브 지도: leaflet, mapview, tmap 패키지\n\n그림 1.3과 같은 인터랙티브 지도는 R의 **leaflet**, **mapview**, **tmap** 패키지를 사용해 생성할 수 있다. **mapview** 패키지는 **leaflet** 패키지의 기본 기능을 확장하여 지도 범례, 피처 클릭 팝업의 세부 조정, 래스터 데이터 지원, FlatGeobuf 형식의 대규모 피처 세트를 위한 스케일러블 지도, 줌과 팬 동기화에 반응하는 패싯 지도를 제공한다. **tmap** 패키지는 두 가지 모드를 지원하여 다음과 같이 `'view'`를 지정하면, 모든 **tmap** 명령이 상호작용형 html/leaflet 위젯에 적용된다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"view\")\n```\n:::\n\n\n\n반면 `'plot'`을 지정하면, 모든 결과물은 다시 R의 정적 그래픽 장치로 출력된다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n:::\n\n\n\n## 연습문제\n\n1.  인도네시아와 캐나다에 대해 등장방형 도법, 정사 도법, 그리고 람베르트 정적원추 도법을 적용한 지도 플롯을 생성하시오. 각 투영법에 대해 해당 국가에 적절한 투영 파라미터를 선택하시오.\n\n2.  그림 8.3의 플롯을 **ggplot2** 패키지와 **tmap** 패키지를 각각 사용하여 재생성하시오.\n\n3.  그림 8.7의 플롯을 `viridis` 색상 팔렡트로 재생성하시오.\n\n4.  **tmap**의 인터랙티브 모드(`'view'` 모드)를 사용하여 그림 8.7을 다시 플로팅하고, 가능한 상호작용을 탐색하시오. 또한 + `tm_facets(as.layers = TRUE)`를 추가한 후 레이어의 켜기/끄기를 시험하고, 투명도를 0.5로 설정하시오.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": true
  }
}