{
  "hash": "bb6646f3ee6a388ef9279b5091352079",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# 공간데이터의 플로팅 {#sec-plotting}\n\n타임라인과 함께, 지도는 가장 강력한 그래프 중 하나일 것이다. 그건 아마도 지도 상의 공간과 현실 공간(현재 어디에 있고, 한때 어디에 있었는지)을 즉시 연관 지을 수 있기 때문일 것이다. 최근 발간된 시각화 관련 두 권의 책(Healy 2018; Wilke 2019)은 지리공간 데이터 또는 지도를 시각화하는 방법에 대한 장을 포함하고 있다. 여기에서는 어떤 지도가 좋고 나쁜지를 논하는 것이 아니라, 지도를 제작할 수 있는 다양한 가능성, 그 과정에서 마주할 수 있는 도전 과제들, 그리고 이를 해결할 수 있는 가능한 방법들을 살펴볼 것이다.\n\n## 모든 지도는 투영법을 가지고 있다. {#sec-every}\n\n세상은 둥글지만, 플로팅 장치는 평평하다. 2.2.2절에서 언급했듯이, 세상을 평평한 장치에 어떤 방식으로든 플로팅한다는 것은 우리가 특정한 투영법을 적용하고 있는 것을 의미한다. 즉, 타원체 좌표를 특정한 방식으로 데카르트 좌표로 전환하고 있는 것이다. 이는 우리가 아무것도 하지 않았다고 생각하는 경우(역자주: 투영법을 적용하지 않았다고 생각하는 경우)(그림 8.1의 왼쪽)나, 우주에서 본 것처럼 세상을 \"있는 그대로\" 보여준다고 생각하는 경우(그림 8.1의 오른쪽)에도 마찬가지이다. 평면 상의 모든 지도는 투영법을 가지고 있다.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![국가 경계: 왼쪽은 경위도를 xy 좌표로 선형 변환한 것이고(플라트 카레 도법), 오른쪽은 무한 거리에서 지구를 바라본 것 같은 방식으로 나타낸 것(정사 도법)이다.](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-world-1.png){#fig-8-1}\n\n왼쪽 지도는 다음의 코드로 그렸다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(rnaturalearth)\nw <- ne_countries(scale = \"medium\", returnclass = \"sf\")\nplot(st_geometry(w))\n```\n:::\n\n\n\n타원 좌표로 지구 전체를 나타내고자 할 때, 해당 투영법이 디폴트 투영법이라는 점을 다음을 통해 알 수 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_is_longlat(w)\n# [1] TRUE\n```\n:::\n\n\n\n그림 8.1(왼쪽)에 사용된 투영법은 등장방형 도법(정거원통 도법)으로, 경도를 $x$-축과 위도를 $y$-축과 선형적으로 연결지어 나타냄으로써 지도의 가로세로의 거리 단위가 동일하게 유지되게 한 것이다(역자주: 지구의 동서 길이는 360도이고 남북 길이는 180도이므로, 이 지도의 가로세로비는 정확히 2:1로 나타난다). 그러므로 지구의 일부분에 대해 이 투영법을 적용하여 플롯할 경우, 지도의 동서 방향과 남북 방향의 거리 단위가 동일하게 유지되도록 플롯 비율을 선택해야 한다. 이는 비투영 `sf` 또는 `stars` 데이터셋에 대한 `plot` 메서드의 디폴트 동작이며, `ggplot2::geom_sf`의 기본 설정이기도 하다(8.4절)(역자주: 비투영 객체는 경위도 좌표계를 가지고 있다는 것인데, 그것을 `plot` 메서드를 통해 플롯하게되면, 디폴트로 경위도 좌표를 마치 $xy$ 좌표처럼 나타낸다는 의미이다. 지구 전체에 대한 비투영 객체를 이러한 방식으로 플롯하면 시각적으로는 등장방형 도법과 동일하게 나타난다.).\n\n플로팅 전에 투영법을 적용하여 데이터를 변형할 수도 있다. 예를 들어 독일을 플로팅하려고 한다면, 국가 경계를 불러온 후, `st_transform` 함수를 사용하여 투영을 수행한다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDE <- st_geometry(ne_countries(country = \"germany\",\n                              returnclass = \"sf\"))\nDE |> st_transform(\"+proj=eqc +lat_ts=51.14 +lon_0=90w\") ->\n    DE.eqc\n```\n:::\n\n\n\n여기서 `eqc`는 PROJ의 \"등장방형 도법\"을 의미한다. `lat_ts`는 투영 파라미터로 표준 위선(축척의 왜곡이 *없는* 위선)의 위치를 지정할 수 있다. 이 표준 위선 상에서 동서 방향과 남북 방향의 길이 단위가 동일해진다. 이 값은 지도의 바운딩 박스의 중간 지점에 해당한다.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n``` r\n# [1] 51.14\n```\n\n그림 8.2에 나타난 두 지도를 보면, 축의 값들을 제외하고는 두 지도는 동일하다는 점을 알 수 있다. 왼쪽 지도의 축 값은 타원 좌표(도 단위)이고, 오른쪽 지도의 축 값은 투영 좌표(데카르트 좌표)(미터 단위)이다.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n![등장방형 도법이 적용된 독일. 왼쪽 지도의 단위는 도이고 정거원통 도법이 적용된 오른쪽 지도의 단위는 미터이다.](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-eqc-1.png){#fig-8-2}\n\n### 데이터에 맞는 투영법 고르기\n\n안타깝게도 여기에는 만병통치약이 없다. 모든 지점에서 모든 방향으로 축척이 동일하게 유지되는 투영법은 없다. 오직 지구본만이 이 속성을 보유한다. 널리 사용되고 있는 투영법들은 다음 중 하나를 보존하려고 한다:\n\n-   면적: 정적 도법\n\n-   형태: 정형 도법(예: *메르카토르 도법*)(역자주: 형태가 유지되기 위해서는 각도가 유지되어야 하기 때문에 정각 도법이라고도 부른다.)\n\n-   거리의 일부 속성 (등장방형 도법은 모든 지점에 경선 방향으로 정거성을 보존하고, *정거방위* 도법은 투영 원점에서 모든 방향으로 거리를 보존한다.)\n\n또는 어떤 도법은 주로 두 개 속성의 절충점을 찾으려고 한다(역자주: 주로 면적과 형태를 절충하는데, 이런 도법을 절충 도법이라 부르고 대표적인 것에 로빈슨 도법과 빈켈 트리펠 도법이 있다). 투영 패러미터는 지도의 중앙과 가장자리에 어떤 지역이 위치하는지, 어떤 지역이 위쪽에 있고 어떤 지역이 아래쪽에 있는지, 그리고 어떤 지역이 가장 크게 확대되는지를 결정한다. 이러한 모든 선택이 합리적으로 이루어지도록 도와주는 가이드라인이 있기는 하지만, 절대적인 규준은 존재할 수 없기 때문에, 어떤 맥락에서는 정치적 결단과 유사할 수도 있다.\n\n다양한 투영법을 적용하고 결과를 비교해보는 것은 재밌기도 하고 교육적이기도 하다. 그러나 지도를 그리는 주된 목적이 투영법의 다양성에 대한 흥미 충족 및 지식 획득이 아니라면, 잘 알려져 있는 투영법 혹은 최소한 덜 생소한 투영법을 선택함으로써, 어떤 투영법을 선택할 것인가와 관련된 논의에 천착하기 보다는 선택된 투영법을 어떻게 적용할 것인가와 관련된 논의로 진전해 나가는 것이 더 바람직할 수 있다. 그러나 세계 지도를 위한 투영법으로 무엇인 좋은가에 대한 질문에는 어느 정도 합의된 대답이 존재한다. 거의 모든 경우에 있어, 정적 도법이 플라트 카레(Plate Carrée)(역자주: 등장방형 도법 혹은 적도를 표준위선으로 설정한 정거원통도법의 또 다른 이름이다.)나 웹 메르카토르 도법보다 선호된다.\n\n## 포인트, 라인, 폴리곤, 그리드 셀의 플로팅\n\n지도는 통계 데이터를 플로팅하는 특별한 형식으로 볼 수 있기 때문에, 플로팅의 일반적인 규칙이 지도에도 그대로 적용된다. 그렇지만 지도-특수적 문제는 존재하며, 여기에는 다음과 같은 것들이 있다.\n\n-   매우 작은 폴리곤은 경우, 플로팅하면 사라질 수 있다.\n\n-   데이터에 따라 지도 심볼이 서로 겹칠 수 있어서 어떤 심볼은 부분적으로만 보일 수 있다. 투명도를 조정하면 겹친 심볼을 식별하는 데 도움이 될 수 있다.\n\n-   포인트 피처나 포인트 심볼을 플로팅하는 경우, 포인트들이 쉽게 겹치고 다른 포인트 뒤에 완전히 가려질 수 있다. 커널 밀도 지도(11장)가 더 유용할 수 있다.\n\n-   라인 피처나 라인 심볼을 플로팅하는 경우, 라인에 부여된 색이 잘 분간되지 않을 수 있으며, 라인 너비와 상관없이 겹칠 수 있다.\n\n### 컬러\n\n컬러 심볼이 적용된 폴리곤을 플로팅하는 경우, 폴리곤 경계를 나타낼지 아니면 생략할지를 선택할 수 있다. 경계가 너무 눈에 띄면, 회색 톤이나 폴리곤 컬러와 충돌이 적은 다른 색상을 경계에 적용할 수 있다. 경계를 완전히 생략해 버리면, (거의) 동일한 컬러를 가진 폴리곤들을 시각적으로 구별할 수 없게 된다. 컬러가 서로 다른 토지 피복 유형을 표현한 것이라면, 경계의 생략이 큰 문제가 되지는 않는다. 그러나 컬러가 집계값(예를 들어 인구수)의 크기를 표현한 것이라면 지도 오독의 문제를 발생시킬 수 있다(역자주: 인구 1,000명 정도를 가진 폴리곤이 연접해 있을 때, 경계를 없애 버리면 마친 훨씬 넓은 지역의 인구가 여전히 1,000명인 것처럼 보여질 수 있다). 특히 인구 수와 같은 공간적으로 외연적인 속성의 경우, 이는 엄청난 오독의 가능성을 야기할 수 있다. 사실은, 공간적으로 외연적인 속성의 경우는 경계를 없애지 않는다 하더라도 폴리곤 내부를 컬러로 채우는 형태의 지도는 적절하지 않다. 왜냐하면 컬러가 폴리곤이 보유한 속성의 크기 뿐만 아니라 폴리곤의 면적도 함께 나타내기 때문이다(역자주: 이런 이유로 공간적으로 외연적인 속성은 코로플레스 맵이 아니라 도형표현도로 나타내는 것이 지도학적 합리성에 부합하는 것이다. 그러나 불행하게도 총합이나 총빈도를 코로플레스 맵으로 나타낸 지도가 인터넷에 넘쳐나고 있다.).\n\n컬러의 단절이 없는 연속형 컬러 스킴은 연속형 공간 현상(역자주: 어디에나 존재하는 속성으로 예를 들어 기온)을 표현하는데 빈번히 사용되고 있는데, 지도학적 실용성보다는 시각적 매력도가 우선시되는 경우가 많다.\n\n-   지도 상의 특정 컬러와 범례 상의 특정 값을 일치시키는 것은 인간의 시각 능력을 고려할 때 큰 실용성이 없다(역자주: 연속형 컬러 스킴을 적용한다는 것은 미세한 컬러의 차이에 의거해 미세한 값의 차이를 분간하라는 것인데, 효과적인 정보 전달이라는 측면에서 큰 지도학적 실효성이 없다).\n\n-   컬러의 범위와 값의 범위가 비선형적으로 연결되는 경우가 많기 때문에, 값의 상대적인 차이를 분간하기 어렵게 만든다.\n\n값의 식별보다는 공간적 현상의 연속성의 재현이 더 중요한 경우에 한하여 연속형 컬러 스킴의 적용이 정당성을 획득할 수 있다. 대표적인 예가 고해상도 디지털 지형 모델을 채색을 통해 시각화하는 경우이다. 좋은 컬러 스킴과 팔레트는 `hcl.colors` 또는 `palette.colors` 함수에서 찾을 수 있으며, **RColorBrewer**(Neuwirth 2022), **viridis**(Garnier 2021), 또는 **colorspace**(Ihaka et al. 2023; Zeileis et al. 2020)와 같은 패키지에서도 찾아볼 수 있다.\n\n### 컬러 단절값: `classInt`\n\n연속적인 공간적 속성을 제한된 컬로(또는 기호)를 사용해 플로팅하려고 하면, 데이터를 몇 개의 계급으로 구분하여야 한다. R 패키지인 **classInt** (Bivand 2022)는 이를 수행할 수 있는 여러 방법을 제공한다. 디폴트는 \"등개수분류법(quantile)\"이다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(classInt)\n# set.seed(1) if needed ?\nr <- rnorm(100)\n(cI <- classIntervals(r))\n# style: quantile\n#   one of 1.49e+10 possible partitions of this variable into 8 classes\n#   [-2.29,-1.27)  [-1.27,-0.698) [-0.698,-0.426) [-0.426,-0.147) \n#              13              12              13              12 \n#  [-0.147,0.129)    [0.129,0.47)     [0.47,1.06)      [1.06,2.1] \n#              12              13              12              13\ncI$brks\n# [1] -2.290 -1.272 -0.698 -0.426 -0.147  0.129  0.470  1.059  2.105\n```\n:::\n\n\n\n이 함수의 `n` 아규먼트를 통해 계급의 수를 설정할 수 있고, style 아규먼트를 통해 서로다른 계급구분 방식을 선택할 수 있다. 사용가능한 옵션에 “fixed”, “sd”, “equal”, “pretty”, “quantile”, “kmeans”, “hclust”, “bclust”, “fisher”, 또는 “jenks”가 있다. `n`이 지정되었다 하더라도 “pretty”를 선택하면 무효화될 수 있고, `n`이 제공되지 않으면 `nclass.Sturges`가 사용된다. 자동으로 n을 선택할 수 있는 두 가지 다른 방법도 있다. 관측값의 수가 3000개를 초과하는 경우, “fisher”와 “jenks”의 경우 10% 샘플이 사용되어 계급을 생성한다.\n\n### 그래티큘 및 관련 요소\n\n그래티큘은 일정한 위도 또는 경도를 따라 지도상에 그으진 선의 네트워크이다. 그림 1.1에서는 회색으로 그려져 있고, 그림 1.2에서는 흰색으로 그려져 있다. 그래티큘은 기본적으로 위치에 대한 참조물로서 지도에 그려진다. 그림 1.1의 첫 번째 지도에서는 플로팅된 지역이 북위 35도, 서경 80도 근처에 있음을 읽을 수 있다. 투영 좌표에 기반한 그래티큘은 모든 선이 직선으로 나타나고 좌표값이 특정 지점으로부터의 거리를 나타내므로 경위도 그래티큘에 비해 쓰임새가 크지 않다(역자주: 통상적으로 투영 좌표에 기반한 격자망은 그래티큘이라 부르지 않고 그리드(grid)라고 부른다). 그래도 독도자가 이러한 그래티큘에 익숙하고 좌표값의 단위가 주어져 있다면, 크기나 거리를 해석하는데 도움을 줄 수 있을 것이다. 그래티큘의 형태는 사용된 투영법의 특성을 반영한다. 따라서 그래트큘을 통해 투영법에 대한 정보를 얻을 수 있다. 등장방형 도법이나 메르카토르 도법은 수직선 및 수평선을 가지며, 원추 도법은 직선이지만 간격이 넓어지는 경선(meridian)을 가지며, 많은 정적 도법에서 경선은 곡선으로 나타난다(역자주: 이것은 지나친 일반화이다. 세계 전체를 나타내는 타원형 형태의 정적 도법(예를 들어: 에케르트 IV 도법)에서 경선이 곡선으로 표현되긴 하지만, 원통 도법(정축의 경우)에서는 경위선이 모두 직선으로 나타난다).\n\n그림 8.1과 대부분의 다른 지도들에서, 실제적인 참조물 구실을 하는 것은 그래티큘이라기 보다는 주 경계, 국가 경계, 해안선, 강, 도로, 철도 등과 같은 지리적 사상들이다. 이러한 요소들이 지도상에 적절히 배치된다면 그래티큘은 생략하는 것이 좋다. 그래티큘이 생략되면 일반적인 플롯의 중요 구성요소인 축, 눈금, 레이블이 사라지므로, 실질적인 지도 데이터로 채울 수 있는 많은 플로팅 공간이 남겨지게 된다.\n\n## 베이스 `plot`\n\n`sf` 및 `stars` 객체에 적용되는 `plot` 메서드는 유용한 데이터 탐색용 플롯을 빠르고 간편하게 만들 수 있게 해준다. 더 높은 품질과 더 높은 사용자 자율성을 원한다면, **ggplot2**(Wickham et al. 2022), **tmap**(Tennekes 2022, 2018) 또는 **mapsf**(Giraud 2022)와 같은 패키지를 활용하면 된다.\n\n`plot` 메서드의 디폴트는 주어진 \"모든 것\"을 플로팅한다는 것이다. 이는 다음을 의미한다.\n\n-   지오메트리만 주어지면(`sfc`), 색상 없이 지오메트리만 플로팅된다.\n\n-   지오메트리와 속성이 함께 주어지면, 속성 값에 따라 지오메트리에 컬러가 부여된다. `factor` 또는 `logical` 속성에는 질적인 컬러 스킴이 적용되고, 그 외에는 연속적 컬러 스킴이 적용되며 컬러에 대한 범례가 추가된다.\n\n-   여러 속성이 주어지면, 여러 개의 지도가 플로팅된다. 색상 할당이 각 하위 지도별로 이루어지기 때문에 지도마다 다른 컬러 스킴이 적용된다. 디폴트로 범례는 생략된다.\n\n-   여러 속성을 가진 `stars` 객체의 경우, 첫 번째 속성만 플로팅되며, 3차원 래스터 큐브의 경우, 세 차원 상의 모든 슬라이스가 하위 플롯으로 플로팅된다.\n\n### 플롯에 범례 첨가하기\n\n`stars` 및 `sf` 객체의 `plot` 메서드는 플롯 영역의 한쪽에 컬러 범례를 나타낼 수 있다(그림 1.1). `base::plot` 함수는 이를 위해 플롯 영역을 두 개로 나누고 두 개의 플롯을 생성한다. 당연히 하나는 지도이고, 다른 하나는 범례이다. `plot` 함수는 디폴트로 그래픽 장치를 초기화하는데(`layout(matrix(1)`) 이는 이후에 생성되는 플롯이 장치가 둘로 나누어지는 것에 의해 방해받지 않도록 하려는 것이다. 하지만, 이것은 만들어진 플롯에 그래픽 요소를 *추가*하는 것을 불가능하게 한다. 색상 범례가 있는 기존 플롯에 추가하려면 plot 명령에서 `reset = FALSE`를 사용하여 장치 초기화를 방지하고, 이후 `plot` 호출에서는 `add = TRUE`를 사용해야 한다. 그림 8.3에 예시가 나타나 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nnc <- read_sf(system.file(\"gpkg/nc.gpkg\", package = \"sf\"))\nplot(nc[\"BIR74\"], reset = FALSE, key.pos = 4)\nplot(st_buffer(nc[1,1], units::set_units(10, km)), col = 'NA', \n     border = 'red', lwd = 2, add = TRUE)\n```\n:::\n\n\n\n![범례가 있는 베이스 플롯에 주석 달기](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-figreset-1.png){#fig-8-3}\n\n단일한 `stars` 레이어가 표시되는 경우, `stars` 플롯에 주석을 추가하는 것은 동일한 방식으로 이루어진다. 여러 큐브 슬라이스가 있는 `stars` 패싯 플롯에 주석을 추가하려면, \"후크(hook)\" 함수를 추가하면 되는데, 이 후크 함수는 모든 슬라이스에서 개별적으로 호출되어야 한다. 이는 다음과 같이 수행할 수 있으며 결과가 그림 8.4에 나타나 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stars)\n# Loading required package: abind\nsystem.file(\"tif/L7_ETMs.tif\", package = \"stars\") |>\n    read_stars() -> r\nst_bbox(r) |> st_as_sfc() |> st_sample(5) |> \n    st_buffer(300) -> circ\nhook <- function() { \n    plot(circ, col = NA, border = 'yellow', add = TRUE)\n}\nplot(r, hook = hook, key.pos = 4)\n# downsample set to 1\n```\n:::\n\n\n\n![다중 슬라이스를 가진 stars 플롯에 주석 달기](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-starshook-1.png){#fig-8-4}\n\n후크 함수는 패싯 파라미터, 패싯 레이블 및 바운딩 박스에 접근할 수 있다.\n\n베이스 `plot` 메서드는 화면 장치의 해상도에 접근할 수 있다. 따라서 `stars` 및 `stars_proxy` 객체에 대해 고밀도 래스터는 다운샘플링하여 가용 장치에 적합한 수준의 밀도로만 픽셀을 플로팅한다.\n\n### 베이스 플롯의 투영법\n\n베이스 `plot` 메서드는 타원체 좌표를 가진 데이터의 경우 등장방형 도법을 이용해 데이터를 플로팅하는데(그림 8.2), 표준 위선의 파라미터 값으로 경계 상자의 중간 위도를 디폴트로 사용한다. 이 파라미터 값을 제어하려면, 플로팅 전에 다른 파라미터 값을 가진 등장방형 도법을 적용하거나, 파라미터 `asp`를 직접 설정함으로써 디폴트를 해제하면 된다(`asp=1`은 플라트 카레 도법(그림 8.1 왼쪽)의 지도를 생성하게 된다). 기존 플롯에 차후의 플롯을 중첩하는 것이 의미가 있으려면, 후속 플롯에 동일한 CRS가 적용되어 있어야 한다. 베이스 `plot` 메서드는 동일 CRS의 여부를 체크하지 않는다.\n\n### 컬러와 컬러 단절값\n\n베이스 plot에서, `nbreaks` 아규먼트는 컬러 단절값의 수를 설정하는 데 사용되며, `breaks` 아규먼트는 실제 컬러 단절값을 포함한 수치 벡터를 설정하거나 `classInt::classIntervals`의 `style` 아규먼트에 대한 스타일 값을 지정하는데 사용된다.\n\n## `ggplot2` 패키지로 지도 그리기\n\n**ggplot2** 패키지(Wickham 외, 2022; Wickham, 2016)는 더 복잡하고 보기 좋은 그래프를 만들 수 있다. 이 패키지에는 sf의 개발과 함께 발전된 `geom_sf`라는 지오메트리 객체가 있으며, 아름다운 지도를 만드는 데 도움을 준다. 이에 대한 소개는 Moreno와 Basille(2018)에서 찾을 수 있다. 첫 번째 예시는 그림 1.2에 나와 있으며, 이 플롯에 사용된 코드는 다음과 같다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) |> suppressPackageStartupMessages()\nnc.32119 <- st_transform(nc, 32119) \nyear_labels <- \n    c(\"SID74\" = \"1974 - 1978\", \"SID79\" = \"1979 - 1984\")\nnc.32119 |> select(SID74, SID79) |> \n    pivot_longer(starts_with(\"SID\")) -> nc_longer\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + geom_sf(data = nc_longer, aes(fill = value), linewidth = 0.4) + \n  facet_wrap(~ name, ncol = 1, \n             labeller = labeller(name = year_labels)) +\n  scale_y_continuous(breaks = 34:36) +\n  scale_fill_gradientn(colours = sf.colors(20)) +\n  theme(panel.grid.major = element_line(colour = \"white\"))\n```\n:::\n\n\n\n코드를 살펴보면, 패싯(facet) 형태의 플롯팅을 위해 사전에 두 개의 속성을 스택(`pivot_longer`) 했다는 것을 알 수 있다. 이것이 \"타이디\" 데이터의 핵심 개념이며, `sf` 객체에 대한 `pivot_longer` 메서드는 지오메트리 열도 자동으로 스택한다.\n\n`ggplot2`는 그래픽 객체를 먼저 생성한 후 플롯팅하기 때문에, 모든 요소의 CRS를 제어할 수 있으며, 이후의 모든 객체를 첫 번째 객체의 CRS로 변환하거나 전환한다. 또한, 회색 배경 위의 얇은 흰색 선(디폴트)으로 그래피큘을 나타내며, 특정한 데이텀(디폴트는 WGS84)를 사용한다. `geom_sf`는 다른 `geom`과 결합할 수 있으며, 이를 통해 플롯에 주석을 추가하는 등의 작업을 할 수 있다.\n\n**stars** 패키지의 경우, `geom_stars`가 존재하기는 하지만 책을 쓰고 있는 현 시점을 기준으로 말하자만 활용성이 다소 제한적인 상태에 있다. `geom_stars`는 지도 레이아웃과 벡터 데이터 큐브에 대해서는 `geom_sf`를 사용하며, 규칙 래스터에 대해서는 `geom_raster`를, 직교 래스터에 대해서는 `geom_rect`를 추가적으로 사용한다. 사용자가 다운샘플링 비율을 지정하면 다운샘플링을 수행하지만, 화면 크기에 접근하여 자동으로 다운샘플링 비율을 선택하는 기능은 없다. 그러나 이 정도 기능만으로도 충분할 수 있으며, 예를 들어 그림 8.5는 다음 명령어로 생성되었다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(stars)\nr <- read_stars(system.file(\"tif/L7_ETMs.tif\", package = \"stars\"))\nggplot() + geom_stars(data = r) +\n        facet_wrap(~band) + coord_equal() +\n        theme_void() +\n        scale_x_discrete(expand = c(0,0)) + \n        scale_y_discrete(expand = c(0,0)) +\n        scale_fill_viridis_c()\n```\n:::\n\n\n\n![ggplot2와 geom_stars로 제작된 단순 패싯 래스터 플롯](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-ggplotstars-1.png){#fig-8-5}\n\n더 정교한 `ggplot2` 기반의 `stars` 객체 플롯은 **ggspatial** 패키지(Dunnington, 2022)를 사용하여 제작할 수 있다. 보다 고품질의 지도를 만드는 옵션에 **tmap** 패키지가 있다. 이를 이용하면 `ggplot2`와 호환되지는 않지만 형식적으로 `ggplot2`과 유사한 스타일의 지도를 생성할 수 있다(8.5절).\n\n## `tmap` 패키지로 지도 그리기\n\n**tmap** 패키지(Tennekes, 2022, 2018)는 R에서 공간데이터를 플로팅하는 신선한 접근을 시도한다. 이 패키지는 `grid` 패키지를 기반으로 그래픽 객체를 먼저 구성한 후 출력하며, 지도 요소를 `+` 기호로 연결하는 방식에서 `ggplot2`와 유사하지만, 그 외에는 `ggplot2`와 완전히 독립적이고 호환되지 않는다. 이 패키지는 매우 전문적인 지도를 만들 수 있는 다양한 옵션을 제공하며, 많은 디폴트 설정도 신중하게 선택되었다. 두 개의 유사한 속성을 가진 지도를 한꺼번에 만들 수 있는데, `tm_polygons` 함수에 두 속성을 동시에 지정하면 된다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tmap)\nsystem.file(\"gpkg/nc.gpkg\", package = \"sf\") |>\n    read_sf() |> st_transform('EPSG:32119') -> nc.32119\ntm_shape(nc.32119) + \n    tm_polygons(c(\"SID74\", \"SID79\"), title = \"SIDS\") +\n    tm_layout(legend.outside = TRUE, \n              panel.labels = c(\"1974-78\", \"1979-84\")) +\n    tm_facets(free.scales=FALSE)\n```\n:::\n\n\n\n![tmap: tm_polygon() 함수에 두 개의 속성을 동시에 지정하여 플로팅하기](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-tmapnc-1.png){#fig-8-6}\n\n또는, `pivot_longer`로 얻은 긴 테이블 형태의 데이터를 + `tm_polygons(\"SID\")` + `tm_facets(by = \"name\")`를 적용하면 동일한 지도를 생성할 수 있다.\n\n**tmap** 패키지는 또한 `stars` 객체를 지원하며, 아래에 예시가 그림 8.7에 나타나 있다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(r) + tm_raster()\n```\n:::\n\n\n\n![tmap을 활용하여 제작된 단순한 래스터 플롯](https://r-spatial.org/book/08-Plotting_files/figure-html/fig-tmapstars-1.png){#fig-8-7}\n\n**tmap** 패키지를 활용해 제작된 더 많은 사례 지도가 14\\~16장에 제시되어 있다.\n\n## 인터렉티브 지도: leaflet, mapview, tmap\n\n그림 1.3에 나타나 있는 것과 같은 인터렉티브 지도는 R 패키지인 **leaflet**, **mapview** 또는 **tmap**을 사용하여 생성할 수 있다. **mapview** 패키지는 **leaflet** 패키지가 제공하는 기본 기능에 여러 기능을 추가하는데, 맵 범례, 피처 클릭 팝업 창의 조정, 래스터 데이터 지원, FlatGeobuf 파일 형식의 대용량 피처 세트를 위한 축척조정형(scalable) 맵, 그리고 줌 및 팬 작업에 동기화하여 반응하는 패싯 맵과 같은 기능들이다. tmap 패키지는 다음을 제공하는 옵션이 있다.\n\n**tmap** 패키지는 두 가지 모드를 제공하는 데, 다음과 같이 \"view\" 지정을 하면 모든 `tmap` 명령이 상호작용형 html/leaflet 위젯에 적용된다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"view\")\n```\n:::\n\n\n\n그런데 \"plot\" 지정을 하면, 모든 산출물이 원래대로 R의 (정적인) 그래픽 장치로 보내진다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n:::\n\n\n\n## 연습문제\n\n1.  인도네시아와 캐나다에 대해 등장방형(equirectangular) 도법, 정사(orthographic) 도법, 그리고 람베르트 정적원추(Lambert azimuthal equal area) 도법이 적용된 지도 플롯을 생성하라. 각 투영법에 대해 해당 국가에 적절한 투영 파라미터를 선택하라.\n\n2.  그림 8.3의 플롯을 **ggplot2** 패키지와 **tmap** 패키지를 각각 사용하여 재생성하라.\n\n3.  그림 8.7의 플롯을 `viridis` 색상 램프를 사용하여 재성성하라.\n\n4.  `tmap`의 \"view\" (상호작용) 모드를 사용하여 그림 8.7을 인터랙티브 플롯으로 재생성하고 어떤 상호작용이 가능한지 탐색하라. 또한 + `tm_facets(as.layers=TRUE)`를 추가한 후, 레이어를 켜고 끄는 것을 해보라. 투명도 값을 0.5로 설정해 보라.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": true
  }
}