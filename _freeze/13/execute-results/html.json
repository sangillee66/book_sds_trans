{
  "hash": "3ad1df1d0d33864c47823153b938367a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\n---\n\n\n# 다변량 및 시공간 지구통계학 {#sec-geostatistics}\n\n12장에 살펴본 간단한 내삽 기법을 바탕으로, 이 장에서는 다변량 지구통계학과 시공간 지구통계학을 다룬다. 다변량 지구통계학은 Bivand, Pebesma와 Gómez-Rubio(2013)에서 자세히 다루고 있으므로, 여기서는 간략히 개요만 제시한다. 시공간 지구통계학은 NO₂ 대기 질 데이터의 사례 연구를 통해 설명하며, 인구 밀도를 공변량으로 활용한 시공간 내삽 기법을 소개한다.\n\n## 대기질 데이터셋 준비\n\n여기서 사용할 데이터셋은 EEA(European Enviromental Agency, 유럽환경청)에서 제공하는 대기질 데이터셋이다. 유럽 회원국들은 대기질 측정 결과를 EEA에 보고하며, *검증된* 데이터는 각 회원국에서 품질을 관리한 후 연 단위로 보고된다. 이러한 데이터는 정책 준수 여부를 평가하고 대응 조치를 마련하는 데 기초 자료로 활용된다.\n\nEEA의 대기질 전자보고(e-reporting) 웹사이트를 통해 유럽 회원국이 보고한 데이터에 접근할 수 있다. 여기서는 기본 측정 자료인 시간별(시계열) 데이터를 다운로드하였다. 웹 양식을 사용하면 선택한 데이터 기준이 손쉽게 HTTP `GET` 요청으로 변환된다. 예를 들어, 독일(`CountryCode=DE`)의 2017년(`Year_from`, `Year_to`) 모두 검증된(`Source=E1a`) $NO_2$(`Pollutant=8`) 데이터를 선택하면, 여러 CSV 파일과 해당 파일들의 URL 정보를 담은 텍스트 파일을 변환하는 URL이 생성된다. 각 CSV 파일에는 특정 측정소의 전체 기간에 대한 시간별 측정값이 포함되어 있다. 다운로드한 파일들은 `dos2unix` 명령줄 유틸리티를 이용해 인코딩을 변환하였다.\n\n마지막으로, 측정소 메타데이터가 담긴 단일 파일을 제외하고, 나머지 파일들은 모두 리스트 형태로 읽어들였다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiles <- list.files(\"aq\", pattern = \"*.csv\", full.names = TRUE)\nfiles <- setdiff(files, \"aq/AirBase_v8_stations.csv\") # metadata file\nr <- lapply(files, function(f) read.csv(f))\n```\n:::\n\n\n그다음, 시간 변수를 `POSIXct` 형식으로 변환한 뒤, 시간 순서대로 정렬한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(TZ = \"UTC\") # don't use local time zone\nr <- lapply(r, function(f) {\n        f$t = as.POSIXct(f$DatetimeBegin) \n        f[order(f$t), ] \n    }\n)\n```\n:::\n\n\n이 데이터셋에서 시간별 자료가 없는 소규모 하위 집합은 제거한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- r[sapply(r, nrow) > 1000]\nnames(r) <- sapply(r,\n               function(f) unique(f$AirQualityStationEoICode))\nlength(r) == length(unique(names(r)))\n# [1] TRUE\n```\n:::\n\n\n그다음, **xts** 패키지의 `cbind()` 함수를 사용해 모든 파일을 병합하고, 시간을 기준으로 레코드를 매칭하여 결합한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(xts) |> suppressPackageStartupMessages()\nr <- lapply(r, function(f) xts(f$Concentration, f$t))\naq <- do.call(cbind, r)\n```\n:::\n\n\n이 데이터셋에 대해 추가적인 선택을 수행하였다. 측정된 시간별 값 중 75% 이상이 유효한 측정소만을 선택한 것이다. 즉, 결측 시간별 값이 25%를 초과하는 측정소는 제외하였다. `mean(is.na(x))` 함수는 벡터 `x`에서 결측값의 비율을 계산하므로, 이 함수를 각 열(측정소)에 적용하면 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsel <- apply(aq, 2, function(x) mean(is.na(x)) < 0.25)\naqsel <- aq[, sel]\n```\n:::\n\n\n다음으로, 측정소 메타데이터를 읽어 들인 뒤, 독일(`\"DE\"`) 농촌 배경 측정소에 해당하는 자료만 선별한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) |> suppressPackageStartupMessages()\nread.csv(\"aq/AirBase_v8_stations.csv\", sep = \"\\t\") |>\n    as_tibble() |> \n    filter(country_iso_code == \"DE\",\n           station_type_of_area == \"rural\",\n           type_of_station == \"Background\") -> a2\n```\n:::\n\n\n포함된 좌표값을 이용해 측정소 메타데이터를 담은 `sf` 객체를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf) |> suppressPackageStartupMessages()\na2.sf <- st_as_sf(a2, crs = 'OGC:CRS84',\n  coords = c(\"station_longitude_deg\", \"station_latitude_deg\"))\n```\n:::\n\n\n이제 앞에서 정리한 대기질 측정 데이터에서 농촌 배경 유형에 해당하는 측정소만 선별해야 한다. 측정소의 코드 정보는 메타데이터를 정리한 `a2`에 저장되어 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsel <- colnames(aqsel) %in% a2$station_european_code\naqsel <- aqsel[, sel]\ndim(aqsel)\n# [1] 8760   74\n```\n:::\n\n\n측정소별 평균을 계산한 뒤, 이를 측정소 위치 객체와 조인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntb <- tibble(NO2 = apply(aqsel, 2, mean, na.rm = TRUE), \n            station_european_code = colnames(aqsel))\ncrs <- st_crs('EPSG:32632')\nright_join(a2.sf, tb) |> st_transform(crs) -> no2.sf \nread_sf(\"data/de_nuts1.gpkg\") |> st_transform(crs) -> de\n```\n:::\n\n\n그림 12.1에는 이렇게 계산된 측정소별 평균 NO$_2$ 농도와 국가 경계가 나타나 있다.\n\n## 다변량 지구통계학\n\n다변량 지구통계학은 여러 변수를 결합하여 모형화, 예측, 시뮬레이션하는 것을 의미한다. 이를 수식으로 표현하면 다음과 같다.\n\n$$\nZ_1(s)=X_i\\beta_i+e_1(s)\n$$\n\n$$\n...\n$$\n\n$$\nZ_n(s)=X_n\\beta_n+e_n(s)\n$$\n\n이러한 모형을 구축하려면 각 변수별로 관측치, 경향 모형, 베리오그램이 필요하며, 나아가 각 변수쌍별로 잔차의 교차 베리오그램(cross-variogram)이 필요하다. 교차 베리오그램은 $e_i(s)$와 $e_j(s+h)$ 사이의 공분산을 나타낸다. 이 교차 공분산이 0이 아니라면, $e_j(s+h)$의 정보는 $e_i(s)$를 예측(또는 시뮬레이션)하는 데 유용할 수 있다. 이는 특히 $Z_j(s)$가 $Z_i(s)$ 보다 더 조밀하게 표집된 경우에 두드러진다. 이러한 방식의 예측과 시뮬레이션은 각각 코크리깅(cokriging) 및 코시뮬레이션(cosimulation)이라 부른다. 데모 스크립트를 실행하면 **gstat** 패키지를 이용한 예제를 확인할 수 있으며, 보다 자세한 내용은 Bivand, Pebesma와 Gómez-Rubio(2013)를 참고하라.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gstat)\ndemo(cokriging)\ndemo(cosimulation)\n```\n:::\n\n\n다양한 변수가 동일한 위치에서 관측되는 경우, 예를 들어 여러 대기질 변수가 동일한 측정소에서 함께 수집되는 경우, 코크리깅(cokriging)의 통계적 이점이 미미할 수 있다. 그러나 진정한 다변량 모형화를 목표로 한다면 코크리깅을 수행하는 것이 바람직하다. 코크리깅을 통해 예측 벡터 $\\hat{Z}(s_0)=(\\hat{Z}_1(s_0),...,\\hat{Z}_n(s_0))$를 얻을 뿐만 아니라, 예측 오차의 전체 공분산 행렬도 구할 수 있다(Ver Hoef and Cressie 1993). 이 예측 오차 공분산 행렬을 이용하면, $\\hat{Z}(s_0)$의 임의의 선형 조합—예를 들어 $\\hat{Z}_2(s_0)-\\hat{Z}_1(s_0)$—에 대한 표준 오차를 계산할 수 있다.\n\n베리오그램과 교차 베리오그램은 자동으로 계산하고 적합할 수 있지만, 변수의 수가 많아질수록 다변량 지구통계 모형화의 관리가 어려워진다. 이는 필요한 베리오그램 및 교차 베리오그램의 수가 $n(n+1)/2$로 늘어나기 때문이다.\n\n또한, 여러 변수라는 의미가 동일한 변수의 여러 시점을 가리키는 경우에도 다변량(코크리깅) 예측 방법을 적용할 수 있다. 하지만 이 경우 두 시점 사이의 임의 시점에 대해 직접적으로 내삽하는 것은 불가능하다. 이러한 상황이나, 여러 시간 인스턴스에서 관측된 데이터를 처리해야 하는 경우에는 $Z(s,t)$와 같이 연속적인 시공간 *결합* 함수를 통해 변동성을 모형화할 수 있다. 다음 절에서 이를 다룬다.\n\n## 시공간 지구통계학\n\n시공간 지구통계 프로세스는 시공간의 모든 위치에서 변수 값이 존재한다는 전제에 기반한다. 이를 $Z(s,t)$로 나타낼 수 있으며, 여기서 $s$와 $t$는 시공간에서 연속적으로 정의되는 인덱스이다. 관측치 $Z(s_i,t_j)$와 베리오그램(또는 공변동) 모형 $\\gamma(s,t)$가 주어지면, 표준 가우시안 프로세스 이론을 활용해 임의의 시공간 위치 $(s_0,t_0)$에서 속성값 $Z(s_0,t_0)$를 예측할 수 있다.\n\n최근에 시공간 지구통계 데이터의 처리 및 모형화에 관한 현대적인 접근을 다룬 책들이 출간되었다. 예를 들어 Wikle, Zammit-Mangion과 Cressie(2019), Blangiardo와 Cameletti(2015) 등이 있다. 여기서는 Gräler, Pebesma와 Heuvelink(2016)를 참고하며, 이전 장에서 사용한 데이터셋을 바탕으로 간단한 예제를 제시한다.\n\n### 시공간 베리오그램 모형\n\n이 장의 서두에서 NO$_2$ 시공간 매트릭스 데이터를 `aq` 객체에 저장하였으며, 이로부터 완전한 레코드를 보유한 농촌 배경 관측소만을 선택해 `aqsel` 객체를 생성하였다. 최종적으로 74개 관측소의 공간 위치를 다음과 같이 선택할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfc <- st_geometry(a2.sf)[match(colnames(aqsel),\n                           a2.sf$station_european_code)] |>\n  st_transform(crs)\n```\n:::\n\n\n그다음, 시간과 측정소를 디멘션으로 하는 `stars` 벡터 큐브를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stars)\n# Loading required package: abind\nst_as_stars(NO2 = as.matrix(aqsel)) |>\n    st_set_dimensions(names = c(\"time\", \"station\")) |>\n    st_set_dimensions(\"time\", index(aqsel)) |>\n    st_set_dimensions(\"station\", sfc) -> no2.st\nno2.st\n# stars object with 2 dimensions and 1 attribute\n# attribute(s):\n#      Min. 1st Qu. Median Mean 3rd Qu. Max.  NA's\n# NO2  -8.1    3.02   5.66 8.39    10.4  197 16134\n# dimension(s):\n#         from   to         offset   delta            refsys point\n# time       1 8760 2017-01-01 UTC 1 hours           POSIXct    NA\n# station    1   74             NA      NA WGS 84 / UTM z...  TRUE\n#                                          values\n# time                                       NULL\n# station POINT (439814 ...,...,POINT (456668 ...\n```\n:::\n\n\n이 데이터를 바탕으로 다음과 같이 시공간 베리오그램을 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gstat)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nv.st <- variogramST(NO2~1, no2.st[,1:(24*31)], tlags = 0:48, \n    cores = getOption(\"mc.cores\", 2))\n```\n:::\n\n\n그 결과는 그림 13.1에 제시되어 있다.\n\n![2017년 독일의 농촌 배경 측정소의 시간별 NO$_2$ 농도에 대한 시공간 표본 베리오그램이다. 오른쪽의 컬러는 시간 지체를 나타내며, 노란색일수록 더 늦은 시간을 의미한다. 거리는 미터 단위이다.](https://r-spatial.org/book/13-Geostatistics_files/figure-html/fig-plotvariograms-1.png){#fig-13-1}\n\n이 표본 베리오그램에는 특정한 베리오그램 모형을 적합할 수 있다. 여기서는 비교적 유연한 모형인 곱합(product-sum) 모형(Gräler, Pebesma, and Heuvelink 2016)을 적용하며, 그 적합 과정은 다음과 같다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# product-sum\nprodSumModel <- vgmST(\"productSum\",\n    space = vgm(150, \"Exp\", 200000, 0),\n    time = vgm(20, \"Sph\", 6, 0),\n    k = 2)\n#v.st$dist = v.st$dist / 1000\nStAni <- estiStAni(v.st, c(0,200000))\n(fitProdSumModel <- fit.StVariogram(v.st, prodSumModel,\n    fit.method = 7, stAni = StAni, method = \"L-BFGS-B\",\n    control = list(parscale = c(1,100000,1,1,0.1,1,10)),\n    lower = rep(0.0001, 7)))\n# space component: \n#   model    psill range\n# 1   Nug   0.0166     0\n# 2   Exp 152.7046 83590\n# time component: \n#   model   psill range\n# 1   Nug  0.0001  0.00\n# 2   Sph 25.5736  5.77\n# k: 0.00397635996859073\n```\n:::\n\n\n그림 13.2에 결과가 제시되어 있으며, 그림 13.3과 같이 와이어프레임 형태로도 플로팅할 수 있다. 이 모형의 적합은 선택된 파라미터에 다소 민감한데, 이는 사용 가능한 관측소 수가 상대적으로 적은 74개에 불과하기 때문일 수 있다.\n\n![표본 베리오그램은 곱합 모형 적합 결과](https://r-spatial.org/book/13-Geostatistics_files/figure-html/fig-prodsummodelplot-1.png){#fig-13-2}\n\n![적합된 시공간 베리오그램 모형의 와이어프레임 플롯](https://r-spatial.org/book/13-Geostatistics_files/figure-html/fig-modelwire-1.png){#fig-13-3}\n\n시공간 베리오그램의 적합 전략과 대체 모형에 대해서는 Gräler, Pebesma와 Heuvelink(2016)를 참고하라.\n\n이 적합 모형과 주어진 관측치를 바탕으로 시공간의 임의 위치에 대해 크리깅이나 시뮬레이션을 수행할 수 있다. 예를 들어, 누락된 시계열 값을 추정(또는 시뮬레이션)하는데 활용할 수 있다. 이러한 상황은 흔히 발생하며, 이에 대한 대응으로 12.4절에서는 관측치의 최대 25%를 제외하고 시계열 평균을 계산한 바 있다. 보다 더 합리적인 방법은 결측치를 시공간적 이웃의 관측치에 기반한 추정값이나 시뮬레이션 값으로 대체한 후 연간 평균을 계산하는 것이다.\n\n보다 일반적인 관점에서, 임의의 시공간 위치에서 추정을 수행할 수 있다. 이러한 과정을 특정 위치의 시계열 값을 예측하는 경우와 공간 슬라이스를 예측하는 경우를 통해 설명할 것이다(Gräler, Pebesma, and Heuvelink 2016). 이를 위해 두 개의 공간 지점을 무작위로 선택하고, 이들 두 지점에 대한 모든 시간 인스턴스를 포함한 `stars` 객체를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1331)\npt <- st_sample(de, 2)\nt <- st_get_dimension_values(no2.st, 1)\nst_as_stars(list(pts = matrix(1, length(t), length(pt)))) |>\n    st_set_dimensions(names = c(\"time\", \"station\")) |>\n    st_set_dimensions(\"time\", t) |>\n    st_set_dimensions(\"station\", pt) -> new_pt\n```\n:::\n\n\n그다음, `krigeST()` 함수를 사용해 이 두 지점의 시공간 예측값을 구한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nno2.st <- st_transform(no2.st, crs)\nnew_ts <- krigeST(NO2~1, data = no2.st[\"NO2\"], newdata = new_pt,\n         nmax = 50, stAni = StAni, modelList = fitProdSumModel,\n         progress = FALSE)\n```\n:::\n\n\n그 결과는 그림 13.4에 제시되어 있다.\n\n![선택된 두 지점의 시공간 예측 시계열 플롯](https://r-spatial.org/book/13-Geostatistics_files/figure-html/fig-plotxts-1.png){#fig-13-4}\n\n또한, 2017년 한 해 동안 일정한 시간 간격으로 생성된 일련의 래스터 지도에 대해 시공간 예측을 생성할 수 있으며, 이는 다음과 같이 수행된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_bbox(de) |>\n  st_as_stars(dx = 10000) |>\n  st_crop(de) -> grd\nd <- dim(grd)\nt4 <- t[(1:4 - 0.5) * (3*24*30)]\nst_as_stars(pts = array(1, c(d[1], d[2], time = length(t4)))) |>\n    st_set_dimensions(\"time\", t4) |>\n    st_set_dimensions(\"x\", st_get_dimension_values(grd, \"x\")) |>\n    st_set_dimensions(\"y\", st_get_dimension_values(grd, \"y\")) |>\n    st_set_crs(crs) -> grd.st\n```\n:::\n\n\n예측은 다음과 같이 수행된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_int <- krigeST(NO2~1, data = no2.st[\"NO2\"], newdata = grd.st,\n         nmax = 200, stAni = StAni, modelList = fitProdSumModel,\n         progress = FALSE)\nnames(new_int)[2] = \"NO2\"\n```\n:::\n\n\n그 결과는 그림 13.5에 제시되어 있다.\n\n![네 개 시점의 시공간 예측 결과](https://r-spatial.org/book/13-Geostatistics_files/figure-html/fig-stpredictions-1.png){#fig-13-5}\n\n여기서는 `nmax` 인수 값을 크게 설정할 필요가 있었다. 이는 이산적인 이웃 선택에서 시간과 공간을 *모두* 고려해야 하며, 그로 인해 발생할 수 있는 시각적 왜곡(날카로운 경계)을 줄이기 위한 조치이다.(역자주: 시공간 크리깅에서는 예측값을 계산할 때 주변의 ‘이웃’ 데이터를 선택한다. 이웃을 선택할 때 공간 거리뿐 아니라 시간 차이까지 함께 고려하면, 적합한 이웃 수가 줄어들어 지도에 뚜렷하고 부자연스러운 경계선이 생길 수 있다. `nmax` 값을 크게 설정하면 이웃을 더 많이 포함시켜 이러한 경계를 완화할 수 있다.)\n\n### 불규칙 시공간 데이터\n\n관측 지점이 계속 변하거나, 고정된 관측 지점이라 하더라도 시간 프레임이 일관되지 않은 경우 `stars` 객체(벡터 데이터 큐브)는 이러한 데이터를 잘 처리하지 못한다. 이러한 불규칙 시공간 관측치는 **sftime** 패키지(Teickner, Pebesma, and Graeler 2022)에서 제공하는 `sftime` 객체로 표현할 수 있다. `sftime` 객체는 기본적으로 `sf` 객체에 지정된 시간 컬럼을 포함한 형태이다. 사용 예시는 **gstat** 패키지에서 제공되는 `demo(sftime)`에서 확인할 수 있다.\n\n## 연습문제\n\n1.  13.1절에서 \"관측소가 최소 75%의 완전한 데이터를 보유해야 한다\"는 기준을 적용할 때, 전체 관측소의 몇 %가 제거되는지 말하시오.\n\n2.  `no2.st`의 시간별 시계열 데이터에서 `aggregate()` 함수를 사용하여 일별 평균 농도를 계산하고, 이에 대한 시공간 베리오그램을 작성하시오. 이를 시간별 베리오그램과 비교하시오.\n\n3.  그림 13.5에 표시된 날짜의 일별 평균값에 대해 시공간 내삽을 수행하고, 그 결과를 비교하시오.\n\n4.  13.2절에서 소개된 데모 스크립트 예를 참고하여, 그림 13.5에 표시된 네 날짜의 일별 평균 관측소 데이터를 사용해 코크리깅을 수행하시오.\n\n5.  위에서 제시한 시공간 크리깅 접근법이 가지는 차별점은 무엇인지 말하시오.\n",
    "supporting": [
      "13_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}