---
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
editor_options: 
  chunk_output_type: console
---

# 시작하기 {#sec-start}

이 장에서는 공간데이터와 시공간데이터를 다루기 위해 필수적으로 알아야 할 기본 개념을 개략적으로 소개한다. 이어지는 장들에서 이러한 개념을 보다 자세히 다룰 것이다. 또한 모든 공간데이터사이언스 실행 환경의 기반이 되는 몇 가지 오픈소스 기술도 간략히 설명한다.

## 첫 번째 지도

공간데이터를 표현하는 가장 전형적인 방법은 지도를 그리는 것이다. 그림 1.1은 그중에서도 단순한 형태의 지도를 예시로 보여준다.

```{r}
#| echo: false
#| output: false
#| label: fig-first-map
#| fig-cap: "첫 번째 지도: 미국 노스캐롤라이나의 카운티별 출생아수, 1974~78년"
library(tidyverse)
library(sf)
system.file("gpkg/nc.gpkg", package="sf") |>
    read_sf() -> nc
nc.32119 <- st_transform(nc, 'EPSG:32119')
nc.32119 |>
    select(BIR74) |>
    plot(graticule = TRUE, axes = TRUE)
```

![첫 번째 지도: 미국 노스캐롤라이나의 카운티별 출생아수, 1974\~1978년](https://r-spatial.org/book/01-hello_files/figure-html/fig-first-map-1.png){#fig-1-1}

이 지도에는 다음과 같은 그래픽 요소가 포함되어 있다.

-   폴리곤: 검은색 외곽선으로 표시되며, 내부는 `BIR74` 변수(지도 제목)의 값에 따라 서로 다른 색상으로 채워져 있다.

-   범례: 색상이 나타내는 값을 설명하며, 특정 *컬러 팔레트*(color palette)가 적용되어 있고 색상 변화 지점에는 *컬러 단절값*(color break)이 표시되어 있다.

-   경위선망(그래티큘): 지도의 배경에 표시된다.

-   축 눈금: 경도와 위도 값을 나타낸다.

*폴리곤*은 공간 *지오메트리*(geometry)의 한 형태다. 공간 지오메트리(포인트, 라인, 폴리곤, 픽셀)에 대해서는 3장에서 자세히 다룬다. 폴리곤은 여러 포인트가 선분으로 연결되어 형성되며, 포인트의 위치 표현과 측정 방법은 2장에서 설명한다. 그림 1.1에서 볼 수 있듯, 모든 경위선이 직선으로 나타나지는 않는다. 이는 지도에 특정 투영법이 적용되었음을 의미하며, 지도 투영에 대한 내용은 2장과 8.1절에서 다룬다.

그림 1.1에서 컬러로 표현된 것은 `BIR74` 변수의 값이다. 각 값은 하나의 지오메트리, 즉 하나의 *피처*(feature)에 연결되어 있으며, 피처 속성과 지오메트리의 관계는 5장에서 다룬다. `BIR74` 변수는 출생아 수를 나타내는 지역별 빈도값(count)이다. 여기서 ‘지역별’이라는 말은, 이 값이 지역 내 모든 지점과 직접적으로 대응되는 것이 아니라는 뜻이다. 지도의 컬러가 연속적으로 채색되어 있어 모든 지점이 해당 값을 가진다고 오해할 수 있지만, 실제로는 해당 값이 폴리곤 전체와 연결된 일종의 적분값임에 유의해야 한다.

그림 1.1의 지도를 작성하려면 당연히 데이터가 필요하다. 여기서는 7.1절에서 사용된 파일을 불러와 사용하였다. 세 개 속성 변수에 대해 앞의 세 개 레코드만 요약한 결과는 다음과 같다.

```{r}
#| echo: false
#| results: false
nc |> select(AREA, BIR74, SID74) |> print(n = 3)
```

```         
# Simple feature collection with 100 features and 3 fields
# Geometry type: MULTIPOLYGON
# Dimension:     XY
# Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6
# Geodetic CRS:  NAD27
# # A tibble: 100 × 4
#    AREA BIR74 SID74                                             geom
#   <dbl> <dbl> <dbl>                               <MULTIPOLYGON [°]>
# 1 0.114  1091     1 (((-81.5 36.2, -81.5 36.3, -81.6 36.3, -81.6 36…
# 2 0.061   487     0 (((-81.2 36.4, -81.2 36.4, -81.3 36.4, -81.3 36…
# 3 0.143  3188     5 (((-80.5 36.2, -80.5 36.3, -80.5 36.3, -80.5 36…
# # ℹ 97 more rows
```

이 데이터 요약을 통해 다음과 같은 사실을 알 수 있다.

-   데이터셋은 100개의 피처(레코드)와 3개의 필드(속성)로 구성되어 있다.

-   지오메트리 유형은 `MULTIPOLYGON`이다(3장 참조).

-   디멘션은 `XY`이다. 즉, 개별 포인트는 두 개의 좌표값으로 구성되어 있다.

-   CRS(coordinate reference system, 좌표참조계)는 측지 좌표계이며, `NAD27` 데이텀을 기반으로한 경위도값을 사용한다(2장 참조).

-   세 개의 속성 변수 다음에는 `MULTIPOLYGON` 유형의 `geom` 변수가 있는데, 이는 폴리곤 정보를 각도(°) 형식으로 저장하고 있다.

패싯(facet) 플롯을 활용하면 그림 1.2와 같이 보다 복잡한 형태의 지도를 작성할 수 있다.

```{r}
#| echo: false
#| eval: false
#| label: fig-1-2
#| fig-cap: "미국 노스캐롤라이나 카운티별 영아돌연사증후군에 의한 사망아수의 패싯 지도, 1974~78년과 1979~84년" 
year_labels <- c("SID74" = "1974 - 1978", "SID79" = "1979 - 1984")
nc.32119 |> select(SID74, SID79) |>
    pivot_longer(starts_with("SID")) -> nc_longer
ggplot() + geom_sf(data = nc_longer, aes(fill = value), linewidth = 0.4) + 
  facet_wrap(~ name, ncol = 1, labeller = labeller(name = year_labels)) +
  scale_y_continuous(breaks = 34:36) +
  scale_fill_gradientn(colors = sf.colors(20)) +
  theme(panel.grid.major = element_line(color = "white"))
```

![미국 노스캐롤라이나 카운티별 영아돌연사증후군에 의한 사망아수의 패싯 지도, 1974\~1978년과 1979\~1984년](https://r-spatial.org/book/01-hello_files/figure-html/fig-firstgather-1.png){#fig-1-2}

리플릿(leaflet)을 사용하면 그림 1.3과 같은 인터랙티브 지도를 제작할 수 있다.

```{r}
#| echo: false
#| label: fig-1-3
#| fig-cap: "**mapview**로 그린 상호작용형 지도: 팬과 줌을 이용해 지도 스케일에 변화를 줄 수 있고 카운티를 클릭하면 해당 카운티의 속성을 보여주는 팝업 윈도우가 뜬다."
library(mapview) |> suppressPackageStartupMessages()
mapviewOptions(fgb = FALSE)
nc.32119 |> mapview(zcol = "BIR74", legend = TRUE, col.regions = sf.colors)
```

## 좌표참조계(CRS)

좌표참조계(CRS, coordinate reference system)는 공간데이터의 좌표값이 어떤 기준과 규칙에 따라 정의되는지를 나타낸다. 그림 1.1의 배경에 보이는 회색선은 경위선망, 즉 *그래티큘*(graticule)이다. 경위선이 $x$, $y$ 축과 직교하는 직선이 아니라는 점은, 이 데이터에 특정한 *투영법*(projection)이 적용되었음을 보여준다. 반면 그림 1.3에서는 노스캐롤라이나의 북쪽 경계가 곡선이 아닌 직선으로 나타나는데, 이는 또 다른 투영법이 사용되었음을 의미한다.

그림 1.1에 나타난 경위도 좌표는 특정한 *데이텀*(datum), 여기서는 NAD27에 기반하고 있다.(역자주: 경위도 좌표는 절대적인 값이 아니라 데이텀에 따라 달라지는 상대적인 값임을 반드시 이해해야 한다. 동일한 지점이라도 데이텀에 따라 서로 다른 경위도 좌표를 가질 수 있으며, 반대로 동일한 좌표값이 데이텀에 따라 지표상의 서로 다른 지점을 가리킬 수도 있다.) 데이텀은 지구를 모형화하기 위해 어떤 지구타원체를 선택하고, 이를 지구와 어떻게 일치시킬 것인가―즉 지구타원체의 원점을 지구상의 어느 지점에, 어떤 방향으로 맞출 것인가―에 대한 일련의 사항을 규정한다. 예를 들어, GPS 수신기(예: 모바일 폰)를 통해 획득한 좌표값은 WGS84(World Geodetic System 1984) 데이텀에 기반한다. 이 좌표값을 NAD27(North American Datum 1927) 기준으로 해석하면, 동일한 좌표값이 실제 위치에서 약 30m 정도 차이이날 수 있다.

투영법은 하나의 좌표계에서 다른 좌표계로 변환하기 위해, 두 좌표값 간의 대응 관계를 정의하는 함수이다.

-   **타원체 좌표**(ellipsoidal coordinates): 지구를 수학적으로 모형화한 지구타원체(또는 지구구체) 상의 3차원 좌표로, 경도와 위도를 사용하여 표현한다.

-   **투영 좌표**(projected coordinates): 지도 상의 2차원 평면 좌표계로, 일반적으로 $x$ 좌표와 $y$ 좌표 또는 동거(easting)와 북거(northing)로 나타낸다.

한 데이텀을 다른 데이텀으로 변환하는 과정을 데이텀 변환이라고 한다. 투영과 좌표계는 *공간참조계*(spatial reference system)의 설정과 관련된 개념이며, 이에 대해서는 2장에서 자세히 설명한다.

## 래스터 데이터와 벡터 데이터

포인트, 라인, 폴리곤 지오메트리는 *벡터*(vector) 데이터의 대표적인 예이다. 벡터 지오메트리를 구성하는 좌표값은 지표상의 '정확한' 위치를 나타낸다. 이에 반해, 래스터 데이터는 주로 정사각형 픽셀로 구성된 격자망(이를 *래스터*(raster)라고 부른다)에 각 셀의 속성값이 할당된 형태의 데이터이다. 래스터 데이터의 예는 그림 1.4에 제시되어 있다.

```{r}
#| echo: false
#| eval: false
#| label: fig-1-4
#| fig-cap: "브라질의 대서양 연안 도시 올린다에 대한 래스터 지도: (a) Landsat-7의 블루 탐지대를 타나낸 것으로 서로 다른 컬러는 속성값의 차이를 나타냄. (b) 좌상의 10X10 픽셀만 확대하여 나타냄. (c) 3개의 샘플 포인트로 구성된 벡터 데이터를 중첩하여 나타냄. (d) 샘플 포인트로부터 반경 500m를 나타낸 3개의 폴리곤으로 구성된 벡터 데이터를 중첩하여 나타냄."
library(stars)
par(mfrow = c(2, 2))
par(mar = rep(1, 4))
tif <- system.file("tif/L7_ETMs.tif", package = "stars")
x <- read_stars(tif)[,,,1]
image(x, main = "(a)")
image(x[,1:10,1:10], text_values = TRUE, border = 'grey', main = "(b)")
image(x, main = "(c)")
set.seed(131)
pts <- st_sample(st_as_sfc(st_bbox(x)), 3)
plot(pts, add = TRUE, pch = 3, col = 'blue')
image(x, main = "(d)")
plot(st_buffer(pts, 500), add = TRUE, pch = 3, border = 'blue', col = NA, lwd = 2)
```

![브라질의 대서양 연안 도시 올린다에 대한 래스터 지도: (a) Landsat-7의 청색 밴드를 타나낸 것으로 서로 다른 컬러는 속성값의 차이를 나타냄. (b) 좌상의 10 X 10 픽셀만 확대하여 나타냄. (c) 3개의 표본 포인트로 구성된 벡터 데이터를 중첩하여 나타냄. (d) 표본 포인트로부터 반경 500 m를 나타낸 3개의 폴리곤으로 구성된 벡터 데이터를 중첩하여 나타냄.](https://r-spatial.org/book/01-hello_files/figure-html/fig-ras-1.png){#fig-1-4}

벡터 데이터와 래스터 데이터는 여러 방식으로 결합할 수 있다. 예를 들어, 그림 1.4(c)에 나타난 세 개의 포인트에 해당하는 래스터 값을 추출할 수 있으며, 그림 1.4(d)에 나타난 원 내부에 포함된 모든 래스터 값을 선택적으로 추출할 수도 있다.

```{r}
#| echo: false
#| eval: false
st_extract(x, pts) # query at points
aggregate(x, st_buffer(pts, 500), FUN = mean) |> st_as_sf() # aggregate over circles
```

래스터에서 벡터로의 전환은 7.6절에서 다루며, 다음과 같은 내용을 포함한다.

-   래스터 픽셀 값을 포인트의 속성값으로 전환하기

-   래스터 픽셀 값을 폴리곤의 속성값으로 전환한 후, 동일한 속성값을 가진 폴리곤을 병합하기('폴리곤 생성')

-   특정 *범위*의 값을 가진 연속적인 픽셀 영역을 라인이나 폴리곤으로 표현하기('등치선 생성')

![그림 1.1에 나타나 있는 카운티별 출생아 수(1974\~1978)를 래스터화하여 나타낸 지도](https://r-spatial.org/book/01-hello_files/figure-html/fig-vectoras-1.png){#fig-1-5}

그림 1.5에 나타난 벡터에서 래스터로의 전환(폴리곤의 래스터화)은 매우 단순한 사례이다. 그러나 다른 형태의 벡터-투-래스터 전환은 보다 복잡한 통계적 모형화를 수반한다. 예를 들어 다음과 같은 경우가 있다.

-   포인트 속성값을 내삽하여 그리드 셀에 할당하기(12장 참조)

-   포인트의 밀도 분포를 추정하여 그리드 셀에 할당하기(11장 참조)

-   폴리곤의 속성값을 면적 가중 내삽을 통해 그리드 셀에 할당하기(5.3절 참조)

-   포인트, 라인, 폴리곤을 래스터로 직접 변환하기(7.6절 참조)

## 래스터 유형

래스터 데이터의 디멘션은 행과 열이 공간 좌표계와 어떻게 연결되는가에 따라 결정된다. 그림 1.6은 그 다양한 가능성을 예시로 보여준다.

```{r}
#| echo: false
#| eval: false
#| label: fig-1-6
#| fig-cap: "다양한 래스터 지오메트리 유형" 
x <- 1:5
y <- 1:4
d <- st_dimensions(x = x, y = y, .raster = c("x", "y"))
m <- matrix(runif(20),5,4)
r1 <- st_as_stars(r = m, dimensions = d)

r <- attr(d, "raster")
r$affine <- c(0.2, -0.2)
attr(d, "raster") = r
r2 <- st_as_stars(r = m, dimensions = d)

r <- attr(d, "raster")
r$affine <- c(0.1, -0.3)
attr(d, "raster") = r
r3 = st_as_stars(r = m, dimensions = d)

x <- c(1, 2, 3.5, 5, 6)
y <- c(1, 1.5, 3, 3.5)
d <- st_dimensions(x = x, y = y, .raster = c("x", "y"))
r4 <- st_as_stars(r = m, dimensions = d)

grd <- st_make_grid(cellsize = c(10,10), offset = c(-130,10), n = c(8,5), crs = st_crs('OGC:CRS84'))
r5 <- st_transform(grd, "+proj=laea +lon_0=-70 +lat_0=35")

par(mfrow = c(2,3), mar = c(0.1, 1, 1.1, 1))
r1 <- st_make_grid(cellsize = c(1,1), n = c(5,4), offset = c(0,0))
plot(r1, main = "regular")
plot(st_geometry(st_as_sf(r2)), main = "rotated")
plot(st_geometry(st_as_sf(r3)), main = "sheared")
plot(st_geometry(st_as_sf(r4, as_points = FALSE)), main = "rectilinear")
plot(st_geometry((r5)), main = "curvilinear")
```

![다양한 래스터 지오메트리 유형](https://r-spatial.org/book/01-hello_files/figure-html/fig-rastertypes01-1.png){#fig-1-6}

그림 1.6에 나타나 있는 규칙(regular) 래스터는 일정한 모양(반드시 정사각형일 필요는 없음)의 그리드 셀로 구성되어 있으며, 가로축과 세로축이 $x$축(동거축)과 $y$축(북거축)과 일치한다. 그러나 이 외에도 다양한 형태의 래스터가 존재한다. 예를 들어, 가로축과 세로축이 $x$축 및 $y$축과 일치하지 않는 *회전형*(rotated) 래스터, 가로축과 세로축이 서로 직교하지 않는 *전단형*(sheared) 래스터, 특정 디멘션을 따라 셀 크기가 달라지는 *직교형*(rectilinear) 래스터이다. 마지막으로, *곡선형*(curvilinear) 래스터는 셀의 크기나 방향이 한 디멘션에서만 결정되는 것이 아니라, 다른 디멘션의 변화에도 영향을 받는다.(역자주: 곡선형 래스터는 좌표축이 곡선 형태를 이루기 때문에, 셀의 크기와 방향이 한 축에서만 결정되는 것이 아니라 다른 축의 변화에도 의존한다. 이는 일반적인 직교 좌표 기반 래스터와 달리, 두 디멘션이 서로 얽혀 있는 구조를 가진다는 뜻이다.)

특정 좌표참조계에 기반한 규칙 래스터가 있다고 하자. 이 래스터를 셀 구조를 그대로 유지한 채 다른 투영법으로 변환하면, 직교형 래스터가 될 수도 있고(예: 그림 1.3에서처럼 측지 좌표를 메르카토르 도법으로 변환하는 경우), 곡선형 래스터가 될 수도 있다(예: 그림 1.1에서처럼 측지 좌표를 람베르트 정형원추 도법으로 변환하는 경우). 이와 같은 변환 과정을 역으로 수행하면 원래의 래스터를 손실없이 정확히 복원할 수 있다.

새로운 투영법이 적용된 규칙 그리드를 새로 생성하는 과정을 래스터(또는 이미지) *재투영*(reprojection) 또는 *워핑*(warping)이라고 한다(7.8절 참조). 워핑 과정에서는 정보 손실이 발생할 수 있으며, 일반적으로 불가역적이고 여러 옵션 설정이 필요하다. 예를 들어, 새로운 셀 값을 생성할 때 인터폴레이션을 적용할지, 평균값이나 합계값을 계산할지 여부를 결정해야 하며, 이웃 셀 값을 활용한 재샘플링 적용 여부도 함께 고려해야 한다. 이러한 선택은 래스터 셀 값이 범주형인지 연속형인지에 따라 달라질 수 있다(1.6절 참조).

## 시계열, 어레이, 데이터 큐브

많은 공간데이터는 공간적 특성*뿐만 아니라* 시간적 특성도 함께 지닌다. 모든 관측치는 관측이 이루어진 특정 지점뿐 아니라, 관측이 수행된 특정 시점과도 결부되어 있다. 예를 들어, 노스캐롤라이나 카운티 데이터셋은 그림 1.2에서 보듯 두 시점의 관측값을 포함하고 있다. 원래 데이터셋에서는 이 두 시점의 값이 각각 별도의 변수로 저장되어 있었을 가능성이 크지만, 그림 1.2와 같이 두 개의 패싯 지도로 표현하려면 지오메트리를 반복하여 두 변수를 하나의 열로 길게 배열하는 형태로 변형해야 한다. 위컴(Wickham, 2014)은 이러한 형태를 *타이디*(tidy) 형태라고 부른다. 그러나 지오메트리와 연결된 긴 시계열 데이터를 다룰 때는, 시간별로 여러 열을 사용하는 방식도, 지오메트리를 반복해 하나의 열로 시간값을 나열하는 방식도 효율적이지 않을 수 있다. 이러한 경우에는 시간과 공간을 각각 하나의 차원으로 설정한 매트릭스나 어레이(array) 구조가 더 효과적일 수 있다. 이미지나 래스터 데이터는 본래 매트릭스 구조로 저장되며, 여기에 시간이 추가되면 3차원 어레이가 된다. 이렇게 여러 차원의 데이터를 저장 및 표현하는 일반적인 구조를 (시공간적) **데이터 큐브**(data cube)라고 한다. 데이터 큐브는 차원의 수에 제한이 없는 어레이 구조를 의미하며, 벡터 데이터와 래스터 데이터 모두에 적용될 수 있다. 이에 대한 다양한 예시는 6장에서 다룬다.

## 서포트

단일 포인트 지오메트리가 아닌, 포인트 집합 지오메트리(다중 포인트, 라인, 폴리곤, 픽셀)를 가진 공간데이터의 경우 결부된 속성값은 해당 지오메트리와 몇 가지 서로 다른 방식으로 연결될 수 있다.

-   지오메트리의 모든 포인트에 공통적으로 적용되는 **상수값**(constant value)

-   지오메트리의 모든 포인트를 집합적으로 대표하는 **집계값**(aggregate value)

-   각 지오메트리의 고유성을 나타내는 **식별값**(identity value)

상수값의 예로는 폴리곤의 토지이용 속성이나 기반암 유형이 있고, 집계값의 예로는 카운티의 출생아수가 있으며, 식별값의 예로는 카운티 이름이 있다.(역자주: 폴리곤의 토지이용은 폴리곤 내 모든 지점에 공통적으로 적용될 수 있는 상수값이다. 반면, 카운티의 출생아 수는 카운티 내 모든 지점의 값을 합산한 집계값이므로, 특정 지점에 적용될 수는 없고 카운티 전체를 집합적으로 대표하는 값이다.)

한 속성값과 결부된 공간적 개체를 해당 속성값의 **서포트**(support)라고 한다. 집계값은 ‘블록(block)’(폴리곤 또는 라인) 서포트를 가지며, 상수값은 ‘포인트’ 서포트를 가진다(동일한 값이 모든 포인트에 적용된다). 예를 들어, 그림 1.5는 폴리곤 서포트를 갖는 변수(카운티별 출생아 수)로부터, 카운티별 속성값을 해당 카운티를 구성하는 픽셀의 속성값으로 할당한 결과이다. 그러나 이렇게 생성된 래스터 지도는 의미가 없다. 속성값인 카운티별 ‘총출생아 수’는 개별 래스터 셀과 무관하며, 속성값과 결부된 카운티 전체 경계조차 표시되어 있지 않다. 따라서 이 지도로부터 노스캐롤라이나 주 전체의 출생아 수나 출생아 밀도를 재계산할 수 없다.

래스터 셀의 속성은 포인트 서포트를 가질 수도 있고, 블록 서포트를 가질 수도 있다. 포인트 서포트의 대표적인 예는 고도이다. 예를 들어 DEM(digital elevation model, 수치표고모형)에서는 보통 셀 중심점의 고도값을 셀 속성으로 저장한다. 블록 서포트(혹은 셀 서포트)의 예로는 위성영상을 들 수 있다. 이미지 픽셀의 속성값은 대개 해당 픽셀(또는 픽셀을 중심으로 한 일정 영역) 내부 값들의 평균이다. 대부분의 파일 포맷은 이러한 서포트 정보를 명시적으로 제공하지 않는다. 그러나 래스터 데이터를 애그리게이팅(aggregating) 하거나, 리그리딩(regridding) 하거나, 워핑(warping) 할 때(7.8절), 또는 포인트별 값을 추출할 때는 매우 중요한 요소가 된다.(역자주: 애그리게이팅은 공간 해상도를 낮추는 과정, 리그리딩은 그리드 체계를 바꾸는 과정, 워핑은 다른 투영법을 적용해 래스터 유형을 변환하는 것을 의미한다.)

## 공간데이터사이언스를 위한 소프트웨어

이 책에서 기본적으로 사용하는 프로그래밍 언어는 R이며, 공간데이터사이언스를 위해 다양한 R 패키지를 활용한다. 이들 R 패키지 중 상당수는 여러 종류의 소프트웨어 라이브러리를 기반으로 동작하는데, 이러한 라이브러리들은 R만을 위해 개발된 것이 아니다. 예를 들어, 그림 1.7은 **sf** 패키지의 의존 관계(dependency)를 보여주며, 이를 통해 **sf** 패키지가 R 패키지뿐 아니라 시스템 라이브러리도 함께 사용하고 있음을 알 수 있다.

![**sf** 패키지의 의존 관계: 직선은 강한 의존성을, 점선은 약한 의존성을 나타낸다.](https://r-spatial.org/book/images/sf_deps.png){#fig-1-7}

C 또는 C++로 작성된 라이브러리(GDAL, GEOS, PROJ, liblwgeom, s2geometry, NetCDF, udunits2)는 모두 R 커뮤니티가 아니라 (공간)데이터사이언스 전반의 다른 커뮤니티에서 개발, 유지, 활용되고 있다. 이러한 라이브러리를 사용함으로써 R 사용자들은 다른 커뮤니티와 공유하는 기술과 협업의 범위를 이해할 수 있다. R, Python, Julia는 인터랙티브한 인터페이스를 제공하기 때문에 많은 사용자가 이러한 라이브러리를 기반으로 한 응용 소프트웨어 사용자들보다 라이브러리에 더 직접적으로 접근할 수 있다. 이 책의 제1부에서는 이러한 라이브러리에 내재된 핵심 개념을 설명하며, 이는 공간데이터사이언스를 폭넓게 이해하는 데 큰 도움이 될 것이다.

### GDAL

GDAL(Geospatial Data Abstraction Library)은 공간데이터 처리에서 ‘스위스 만능칼’과 같은 역할을 한다고 할 수 있다. GDAL은 R, Python, PostGIS를 비롯해 100개가 넘는 다른 소프트웨어 프로젝트에서 폭넓게 사용되고 있다.

GDAL은 공간데이터를 읽고 쓸 수 있게 해주는 라이브러리 가운데서도 핵심적인 라이브러리로, 수많은 다른 라이브러리에 의존한다. 약 100개가 넘는 라이브러리와 연동되며, 각 라이브러리는 특정 데이터 파일 포맷, 특정 데이터베이스, 특정 웹서비스 또는 특정 압축 코덱을 처리한다.

CRAN에서 배포되는 바이너리 형식의 R 패키지에는 스태틱 링크 코드(statically linked code)만 포함되어 있다. 이는 CRAN이 패키지를 배포하는 시스템에 서드파티(third-party) 라이브러리가 설치되어 있다고 가정하지 않기 때문이다. 그 결과 CRAN에서 바이너리 형식의 **sf** 패키지를 설치하면 **sf** 패키지의 의존성뿐 아니라 모든 외부 라이브러리도 함께 다운로드되어, 설치 파일 용량이 약 100MB에 달한다.(역자주: CRAN은 The Comprehensive R Archive Network의 약자로, R 패키지를 저장하는 중앙 저장소이다. R 언어 자체의 과거와 현재 버전뿐 아니라 20,000개 이상의 R 패키지가 모여 있다. 1997년 쿠르트 호르닉(Kurt Hornik)과 프리드리히 라이슈(Friedrich Leisch)가 처음 만들었으며, 현재도 쿠르트 호르닉과 많은 자원봉사자가 운영하고 있다. 스태틱 링크 코드는 컴파일 시점에 필요한 라이브러리나 의존성을 실행 파일에 미리 포함시켜 만든 코드를 의미한다.)

### PROJ

PROJ(혹은 PR$\phi$J)는 지도 투영과 데이텀 변환을 위한 라이브러리로, 공간 좌표를 한 CRS에서 다른 CRS로 변환한다. PROJ에는 현재까지 알려진 수많은 투영법에 대한 데이터베이스가 포함되어 있으며, 데이텀 변환을 위한 고정밀 계수값을 담은 데이터 그리드에 접근할 수 있다. 또한 PROJ는 CRS에 관한 국제 표준을 따른다(Lott 2015). 좌표계와 PROJ에 대해서는 2장에서 자세히 다룬다.

### GEOS와 s2geometry

GEOS(Geometry Engine Open Source)와 s2geometry는 지오메트리 연산을 위한 라이브러리이다. 이들 라이브러리를 활용하면 기하학적 측정(길이, 면적, 거리), 프레디케이트(predicate)(두 지오메트리가 포인트를 공유하는지 여부), 새로운 지오메트리 생성(두 지오메트리가 공유하는 포인트) 등의 연산을 수행할 수 있다.(역자주: 프레디케이트는 특정 조건이 참인지 거짓인지 판별하는 논리 연산을 의미한다. 공간데이터 연산에서는 두 지오메트리가 접하는지, 포함하는지, 겹치는지 등을 판정하는 함수나 연산자를 지칭한다. '(공간) 관계 연산자' 등으로 번역하기도 하지만 여기서는 원어를 음역한 '프레디케이트'를 그대로 사용한다.) GEOS는 이러한 연산을 2차원 평면($R^2$)에서 수행하며, s2geometry는 이를 3차원 구면($S^2$)에서 수행한다. CRS에 대해서는 2장에서, 그리고 2차원 공간과 3차원 공간을 다루는 차이점은 4장에서는 좀 더 깊이 논의한다.

### NetCDF, udunits2, liblwgeom

NetCDF(UCAR 2020)는 파일 형식이자 NetCDF 파일을 읽고 쓰기 위한 C 라이브러리를 의미한다. NetCDF를 통해 모든 차원의 어레이를 정의할 수 있으며, 특히 기후 모형화 커뮤니티에서 공간 및 시공간 정보를 다루는 데 널리 사용된다. Udunits2(UCAR 2014; Pebesma, Mailud, and Hiebert 2016; Pebesma et al. 2022)는 측정 단위와 관련된 데이터베이스이자 소프트웨어 라이브러리로, 측정 단위 간 전환과 파생 단위 처리를 지원하며 사용자 정의 단위도 사용할 수 있다. liblwgeom '라이브러리'는 PostGIS(Obe and Hsu 2015)의 소프트웨어 구성 요소로서, GDAL이나 GEOS에서는 다루지 않는 몇 가지 루틴을 포함한다. 예를 들어 PROJ가 포함된 GeographicLib 루틴에 손쉽게 접근할 수 있게 해준다.

## 연습문제

1.  래스터 데이터와 백터 데이터의 차이점 다섯 가지를 열거하시오.

2.  그림 1.1 아래에 나열되어 있는 것 외에, 지도의 그래픽 요소 다섯 개를 더 열거하시오.

3.  그림 1.5에 나타나 있는 수치 정보가 왜 오해를 불러일으키는지(혹은 무의미한지)에 대해 얘기해 보시오.

4.  지오메트리 연산을 $S^2$에서 수행하는 것과 $R^2$에서 수행하는 것의 차이가 가장 극명하게 드러나는 상황을 예로 들어 설명하시오.
