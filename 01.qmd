---
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
---

# 시작하기 {#sec-start}

이 장에서는 공간데이터와 시공간데이터를 다루기 위한 관련 개념들에 대해 소개한다. 이 개념들은 이후의 장들에서 좀 더 상세하게 다루어질 것이다. 이 외에도 모든 공간데이터사이언스 언어 실행의 토대가 되는 몇 가지 오픈소스 테크놀로지에 대해 소개한다.

## 첫 번째 지도

공간데이터를 표현하는 전형적인 방법은 지도를 그리는 것이다. @fig-first-map 에는 단순한 지도가 나타나 있다.

```{r}
#| echo: false
#| label: fig-first-map
#| fig-cap: "첫 번째 지도: 미국 노스캐롤라이나의 카운티별 출생아수, 1974~78년"
library(tidyverse)
library(sf)
system.file("gpkg/nc.gpkg", package="sf") |>
    read_sf() -> nc
nc.32119 <- st_transform(nc, 'EPSG:32119')
nc.32119 |>
    select(BIR74) |>
    plot(graticule = TRUE, axes = TRUE)
```

이 지도에는 몇 가지 그래픽 요소들이 나타나 있다.

-   검은색 외곽선을 가진 폴리곤이 나타나 있고, 폴리곤의 내부는 BIR74라는 변수(제목)의 값에 따라 상이한 컬러로 채워져 있다.

-   범례는 서로 다른 컬러가 무엇을 의미하는지를 설명하고 있는데, 특정한 *컬러 팔레트*가 적용되어 있고, 컬러가 변하는 지점에 *컬러 단절값*이 나타나 있다.

-   경위선망(그래티큘)이 지도의 배경에 나타나 있다.

-   축의 눈금은 특정한 경도값과 위도값이다.

*폴리곤*은 특정한 형태의 *지오메트리*이다. 공간적 지오메트리(포인트, 라인, 폴리곤, 픽셀)에 대해서는 @sec-geometry 에서 자세히 다룬다. 폴리곤은 여러 개의 포인트들로 구성되어 있고, 포인트들은 선분으로 서로 이어져 있다. 공간데이터의 포인트 위치가 어떻게 표현되고 측정되는지에 대해서는 @sec-coord 에서 다룬다. @fig-first-map 에서 볼 수 있는 것처럼, 모든 경위선이 직선으로 표현되는 것이 아니다. 이것은 지도에 특정한 형태의 투영법이 적용되어 있음을 의미한다. 지도투영에 대해서는 @sec-coord 와 @sec-every 에서 다룬다.

@fig-first-map 에서 컬러로 표현되어 있는 것은 `BIR74`라는 변수의 값이다. 값 하나는 지오메트리 혹은 피쳐(feature) 하나와 연결되어 있다. @sec-attribute 은 이러한 피처 속성 및 그것들이 피처 지오메트리와 어떻게 관련되어 있는지에 대해서 다룰 것이다. `BIR74` 변수는 출생아수를 나타내며, 이는 *지역별* 빈도값이다. 지역별 빈도값이라는 말은 이 값이 지역 내의 모든 지점과 관련되어 있는 것이 아니라는 것을 의미하는데, 지도의 컬러가 연속적인 값을 취하고 있기 때문에 이렇게 오해할 수 있지만, 사실 빈도값은 폴리곤에 전체와 연결되어 있는 일종의 적분값을 의미한다.

@fig-first-map 을 그리기 위해서는 당연히 데이터가 필요한데, @sec-sf 에서 사용된 파일을 읽어 들였다. 세 개의 속성 변수에 대한 첫 세 개 레코드의 데이터 요약을 출력하면 다음과 같다:

```{r}
#| echo: false
nc |> select(AREA, BIR74, SID74) |> print(n = 3)
```

이 데이터 요약은 다음의 사항을 알려준다:

-   데이터셋은 100개의 피처(레코드)와 3개의 필드(속성)으로 구성되어 있다.

-   지오메트리 유형은 `MULTIPOLYGON` (@sec-geometry )이다.

-   디멘션(dimension)은 `XY`이다. 즉, 개별 포인트는 두 개의 좌표값으로 구성되어 있다.

-   좌표참조계(CRS, coordinate reference system)는 측지(geodetic) 좌표계이며, NAD27 데이텀(datum)에 의거한 경위도값을 가지고 있다(@sec-coord ).

-   세 개의 속성 변수 바로 다음에 `MULTIPOLYGON` 유형의 `geom` 변수가 있는데, 이것은 폴리곤 정보를 도(degree) 형식으로 담고있다.

패싯(facet) 플롯을 활용하면 @fig-1-2 에서 보는 것과 같은 보다 복잡한 형태의 지도를 그릴 수 있다.

```{r}
#| echo: false
#| label: fig-1-2
#| fig-cap: "미국 노스캐롤라이나 카운티별 영아돌연사증후군에 의한 사망아수의 패싯 지도, 1974~78년과 1979~84년" 
year_labels <- c("SID74" = "1974 - 1978", "SID79" = "1979 - 1984")
nc.32119 |> select(SID74, SID79) |>
    pivot_longer(starts_with("SID")) -> nc_longer
ggplot() + geom_sf(data = nc_longer, aes(fill = value), linewidth = 0.4) + 
  facet_wrap(~ name, ncol = 1, labeller = labeller(name = year_labels)) +
  scale_y_continuous(breaks = 34:36) +
  scale_fill_gradientn(colors = sf.colors(20)) +
  theme(panel.grid.major = element_line(color = "white"))
```

리플릿(leaflet)을 활용하면 @fig-1-3 에서 보는 것과 같은 상호작용형 지도를 만들 수 있다.

```{r}
#| echo: false
#| label: fig-1-3
#| fig-cap: "**mapview**로 그린 상호작용형 지도: 팬과 줌을 이용해 지도 스케일에 변화를 줄 수 있고 카운티를 클릭하면 해당 카운티의 속성을 보여주는 팝업 윈도우가 뜬다."
library(mapview) |> suppressPackageStartupMessages()
mapviewOptions(fgb = FALSE)
nc.32119 |> mapview(zcol = "BIR74", legend = TRUE, col.regions = sf.colors)
```

## 좌표참조계

@fig-first-map 의 배경에 그어진 회색선은 경위선망, 즉 *그래티큘*(graticule)이다. 경위선이 두 축과 직교하는 직선이 아니라는 점이 명백하다. 이것은 데이터에 특정한 *투영법*이 적용되어 있음을 의미한다. 그런데 @fig-1-3 에는 노스케롤라이나의 북쪽 경계가 곡선이 아닌 직선으로 표현되어 있는데, 이것은 또 다른 투영법이 적용되었음을 의미한다.

@fig-first-map 에 나타나 있는 경위도 좌표는 특정한 *데이텀*(여기서는 NAD27)과 연결되어 있다(역자주: 경위도 좌표는 절대적인 것이 아니라 데이텀에 따라 달라지는 상대적인 것이라는 점을 반드시 이해해야 한다. 동일한 지점이 데이텀에 따라 다른 경위도 좌표값을 부여받고, 동일한 경위도 좌표값이 데이텀에 따라 지표 상의 다른 지점을 의미한다). 데이텀은 지구를 모델화하기 위해 어떤 지구타원체가 선택되고, 그 지구타원체를 지구와 어떠한 방식으로 일치시킬 것인가(지구타원체의 원점을 지구의 어떤 지점과 어떠한 방향으로 일치시킬 것인가)와 관련된 몇 가지 사항들을 규정한다. GPS 수신기(예: 모바일 폰)를 통해 획득된 좌표값은 WGS84(World Geodetic System 1984) 데이텀에 의거한 것인데, 만일 NAD27(North American Datum 1927)에 의거한 것이라면 동일한 좌표값에 대해 대략 30m 정도의 편차를 나타낼 것이다.

투영법은 두 개의 좌표값을 연결하는 함수이다.

-   **타원체 좌표**(ellipsoidal coordinates): 지구에 대한 수학적 모델(지구타원체 혹은 지구구체) 상의 3차원 좌표로, 경도와 위도로 나타낸 것이다.

-   **투영 좌표**(projected coordinates): 지도 상의 2차원 평면 좌표로, x 좌표와 y 좌표 혹은 동거(easting)와 북거(northing)로 나타낸 것이다.

한 데이텀을 다른 데이텀으로 바꾸는 것을 데이텀 변환이라고 한다. 투영과 좌표계는 **공간참조계**(spatial reference system)의 설정과 관련되어 있고, @sec-coord 에서 상세히 다룬다.

## 래스터 데이터와 벡터 데이터

포인트, 라인, 폴리곤 지오메트리는 *벡터*(vector) 데이터의 예시이다. 벡터 지오메트리를 구성하는 좌표값은 지표 상의 "정확한" 위치를 의미한다. 이에 반해 래스터 데이터는 주로 정사각형 픽셀로 구성된 격자망(이것을 *래스터*라고 부름)에 속성값이 부여되어 있는 데이터이다. 래스터 데이터의 예가 @fig-1-4 에 나타나 있다.

```{r}
#| echo: false
#| label: fig-1-4
#| fig-cap: "브라질의 대서양 연안 도시 올린다에 대한 래스터 지도: (a) Landsat-7의 블루 탐지대를 타나낸 것으로 서로 다른 컬러는 속성값의 차이를 나타냄. (b) 좌상의 10X10 픽셀만 확대하여 나타낸 것임. (c) 3개의 샘플 포인트로 구성된 벡터 데이터를 중첩하여 나타냄. (d) 샘플 포인트로부터 반경 500m를 나타낸 3개의 폴리곤으로 구성된 벡터 데이터를 중첩하여 나타냄."
library(stars)
par(mfrow = c(2, 2))
par(mar = rep(1, 4))
tif <- system.file("tif/L7_ETMs.tif", package = "stars")
x <- read_stars(tif)[,,,1]
image(x, main = "(a)")
image(x[,1:10,1:10], text_values = TRUE, border = 'grey', main = "(b)")
image(x, main = "(c)")
set.seed(131)
pts <- st_sample(st_as_sfc(st_bbox(x)), 3)
plot(pts, add = TRUE, pch = 3, col = 'blue')
image(x, main = "(d)")
plot(st_buffer(pts, 500), add = TRUE, pch = 3, border = 'blue', col = NA, lwd = 2)
```

벡터 데이터와 래스터 데이터를 여러 가지 방식으로 결합될 수 있다. 예를 들어, @fig-1-4 (c)에 나타나 있는 세 포인트에 해당하는 래스터 값만을 추출할 수도 있고, @fig-1-4 (d)에 나타나 있는 원과 결부된 모든 래스터 값을 추출할 수도 있다.

래스터-투-벡터 전환은 섹션 7.6에서 다루어지는데, 다음과 같은 내용이 포함된다.

-   래스터 픽셀값을 포인트 속성값으로 전환하기

-   래스터 픽셀값을 폴리곤 속성값으로 전환한 후, 동일한 속성값을 가진 폴리곤을 머지하기("폴리곤 생성")

-   특정한 범위의 값을 가진 연속적인 픽셀 연속체를 나타내는 라인이나 폴리곤을 생성하기("등치선 생성")

```{r}
#| echo: false
#| label: fig-1-5
#| fig-cap: 그림 1.1에 나타나 있는 카운티별 출생아수(1974~78)를 래스터화하여 나타낸 지도
plot(st_rasterize(nc["BIR74"], dx = 0.1), col = sf.colors(), breaks = "equal")
```

벡터-투-래스터 전환은 @fig-1-5 에 나타나 있는 것(폴리곤의 래스터화)처럼 매우 간단한 것일 수 있다. 그러나 다른 형태의 벡터-투-래스터 전환은 통계적 모델링을 수반할 수 있다.

-   포인트 속성값을 인터폴레이션을 통해 그리드 셀에 할당하기 (12장)

-   포인트의 밀도 분포를 추정하여 그리드 셀에 할당하기 (11장)

-   폴리곤의 속성값을 에어리어-가중 인터폴레이션을 통해 그리드 셀에 할당하기 (섹션 5.3)

-   포인트, 라인, 폴리곤을 래스터로 직접 변환하기 (섹션 7.6)

## 래스터 유형

래스터 디멘션은 행과 열이 공간 좌표계와 어떻게 관련되어 있는가에 의해 결정된다. @fig-1-6 은 다양한 가능성을 예시로 보여주고 있다.

```{r}
#| echo: false
#| label: fig-1-6
#| fig-cap: "다양한 래스터 지오메트리 유형" 
x <- 1:5
y <- 1:4
d <- st_dimensions(x = x, y = y, .raster = c("x", "y"))
m <- matrix(runif(20),5,4)
r1 <- st_as_stars(r = m, dimensions = d)

r <- attr(d, "raster")
r$affine <- c(0.2, -0.2)
attr(d, "raster") = r
r2 <- st_as_stars(r = m, dimensions = d)

r <- attr(d, "raster")
r$affine <- c(0.1, -0.3)
attr(d, "raster") = r
r3 = st_as_stars(r = m, dimensions = d)

x <- c(1, 2, 3.5, 5, 6)
y <- c(1, 1.5, 3, 3.5)
d <- st_dimensions(x = x, y = y, .raster = c("x", "y"))
r4 <- st_as_stars(r = m, dimensions = d)

grd <- st_make_grid(cellsize = c(10,10), offset = c(-130,10), n = c(8,5), crs = st_crs('OGC:CRS84'))
r5 <- st_transform(grd, "+proj=laea +lon_0=-70 +lat_0=35")

par(mfrow = c(2,3), mar = c(0.1, 1, 1.1, 1))
r1 <- st_make_grid(cellsize = c(1,1), n = c(5,4), offset = c(0,0))
plot(r1, main = "regular")
plot(st_geometry(st_as_sf(r2)), main = "rotated")
plot(st_geometry(st_as_sf(r3)), main = "sheared")
plot(st_geometry(st_as_sf(r4, as_points = FALSE)), main = "rectilinear")
plot(st_geometry((r5)), main = "curvilinear")
```

@fig-1-6 에 나타나 있는 레귤러(regular) 래스터는 일정한 모양(반드시 정사각형일 필요는 없다)의 그리드 셀로 이루어져 있고, 가로추과 세로축이 x-축(동거축)과 y-축(북거축)과 일치한다. 그러나 다른 래스터 유형도 존재할 수 있는데, 가로축과 세로축이 더 이상 x-축 및 y-축과 일치하지 않거나(*rotated*), 가로축과 세로축이 직교하지 않거나(sheared), 셀 크기가 동일 축 상에서 조차 다르게 나타날 수 있다(rectilinear). 심지어 curvilinear 래스터의 경우는 셀의 크기 및 방향 속성이 더 이상 또 다른 래스터 디멘션으로부터 독립적이지 않다(?).

특정한 좌표참조계에 의거해 regular한 지오메트리 유형을 가진 래스터가 있다고 하자. 이것을 셀 구조는 그대로둔 상태로 다른 투영법으로 전환하게 되면, rectilinear 하게 될 수도 있고(예를 들어, @fig-1-3 에서처럼, 측지좌표를 메르카토르 도법으로 전환하는 경우), curvilinear 해 질 수도 있다(예를 들어, @fig-first-map 에서처럼, 측지좌표를 람베르트 정형원추 도법으로 전환하는 경우). 이 전환을 역으로 수행하게 되면 정확히 동일한 래스터를 회복할 수 있다.

새로운 투영법이 적용된 새로운 레귤러 그리드를 생성하는 것을 래스터(혹은 이미지) *재투영*(reprojection) 혹은 *워핑*(warping)이라고 한다(섹션 7.8). 워핑은 정보 손실이 발생하고, 불가역적이며, 다양한 옵션의 설정이 필수적이다. 예를 들어, 새로운 셀 값을 생성하기 위해 인터폴레이션을 적용할지, 평균값을 산출할지, 합산값을 산출할지를 결정해야 하며, 이웃값을 활용한 재표집(resampling)이 적용되어야 할지의 여부를 결정해야 한다. 이러한 선택은 래스터 셀 값이 범주형인지 연속형인지에 따라 달라질 수 있다(섹션 1.6).

## 시계열, 어레이, 데이터 큐브

많은 공간데이터는 *단지* 공간적이기만 한 것이 아니라 시간적이기도 하다. 모든 관측치는 그것이 관측된 특정한 지점과 결부되어 있을 뿐만 아니라 관측이 이루어진 특정한 시간과도 결부되어 있다. 노스캐롤라이나 카운티 데이터셋은 그림 1.2에서 보는 것처럼 두 기간의 관측값을 가지고 있다. 원 데이터셋에서는 두 기간이 두 개의 변수로 저장되어 있었겠지만, 그림 1.2처럼 두 개의 패싯 지도로 표현되기 위해서는 지오메트리의 반복을 통해 두 변수가 하나의 컬럼에 길게 이어져 있는 형태로 변형되어야 한다. 이러한 형태를 위컴(Wickham)(2014)은 타이디(tidy) 형태라고 부른바 있다. 그런데 지오메트리와 연결된 긴 시계열(time series) 데이터를 가지고 있을 때, 두 개의 옵션(시간을 여러 개의 컬럼에 할당하거나 지오메트리의 반복을 통해 시간을 하나의 컬럼에 길게 배열하는 것) 중 어는 것도 적절해 보이지는 않는다. 이런 경우 보다 효과적인 방법은 메트릭스나 어레이(array) 형식을 취해, 하나의 차원에는 시간을 할당하고 나머지 차원에는 공간을 할당하는 것이다. 이미지나 래스터 데이터는 이미 이러한 방식대로 매트릭스 형태로 저장되어 있고, 여기에 시간이 첨가되면 3차원의 어레이 형태가 된다. 그러한 데이터를 부를는 일반 용어가 바로 (시공간적) **데이터 큐브**이다. 큐브는 차원의 개수에 구애받지 않는 어레이를 의미한다. 데이터 큐브는 벡터 데이터와 래스터 데이터 모두를 지칭하는데 사용될 수 있고, 예시들이 6장에서 제시될 것이다.

## 서포트

단순한 포인트 지오메트리가 아니라 포인트 집합체의 지오메트리(다중-포인트, 라인, 폴리곤, 픽셀)를 가지 공간데이터의 경우 결부되어 있는 속성값은 지오메트리와 몇 가지 상이한 방식의 관련성을 갖는다.

-   지오메트리의 모든 포인트에 공통적으로 적용되는 **동일값**

-   지오메트리의 모든 포인트를 집합적으로 대표하는 **합산값**

-   개별 지오메트리의 고유성을 표현하는 **식별값**

동일값의 예로 폴리곤의 토지이용 속성이나 기반암 유형 속성을 들 수 있고, 합산값의 예로 카운티의 출생아수를 들 수 있고, 식별값으로 카운티 이름을 들 수 있다(역자주: 폴리곤의 토지이용은 폴리곤 내의 모든 지점에 공통적으로 적용될 수 있고, 카운티의 출생아수는 카운티 내 모든 지점의 출생아수를 합산했다는 의미이므로 카운티 내의 모든 지점에 그 값이 적용될 수는 없고, 카운티 전체를 집합적으로 대표한다).

한 속성값과 결부되어 있는 공간적 개체를 속성값의 **서포트**라고 한다. 합산값은 "블록" (폴리곤 혹은 라인) 서포트를 갖고 동일값은 "포인트" 서포트를 갖는다 (동일값은 모든 포인트에 적용된다). 예를 들어, 그림 1.5는 폴리곤 서포트를 갖는 변수(카운티별 출생아수)로부터 도출된 것으로, 카운티별 속성값을 카운티를 구성하는 픽셀의 속성값으로 할당한 것이다. 이러한 래스터화를 통해 생성된 지도는 무의미한다. 즉, 속성값인 카운티별 "총출생아수"는 래스터 셀과 무관하며, 속성값과 결부되어 있는 카운티의 경계는 표시 조차되어 있지 않다. 이 지도로부터 노스캐롤라이나 주 전체의 출생아수나 출생아 밀도를 재계산하는 것은 불가능하다. 이처럼 서포트를 무시하는 것은 무의미한 지도의 산출로 귀결된다. 5장에서 좀 더 심도있게 다룰 것이다.

래스터 셀 속성은 포인트 서포트를 가질 수도 있고 블록 스포트를 가질 수도 있다. 포인트 서포트의 예로 고도를 들 수 있는데, 디지털고도모델(digital elevation model)의 경우 보통 셀 중심점의 고도값을 셀의 속성값으로 저장한다. 블록 서포트 (혹은 셀 서포트)의 예로 위성영상을 들 수 있는데, 이미지 픽셀의 속성값은 주로 픽셀(혹은 픽셀을 중심으로 한 특정 영역) 내부의 값들의 평균값이다. 대부분의 파일 포맷은 이러한 정보를 제공하지 않는다. 그러나 래스터 데이터를 애그리게이팅(aggregating), 리그리딩(regridding), 워핑하거나(섹션 7.8), 포인트별 값을 추출할 때 매우 중요한 사안이다.

## 공간데이터사이언스를 위한 소프트웨어

이 책의 기본 프로그래밍 언어는 R이고, 공간데이터사이언스를 위한 다양한 R 패키지를 활용한다. 그런데 우리가 사용할 R 패키지 중 많은 것들이 R만을 위해서 개발되지는 않은 다양한 소프트웨어 라이브러리를 활용하고 있다. 하나의 예로서, 그림 1.7은 sf 패키지의 의존계(dependency), 즉 sf 패키지가 어떤 R 패키지나 어떤 시스템 라이브러리에 의존하고 있는지를 보여주고 있다.

![sf의 의존계: 직선은 강한 의존성을 점선은 약한 의존성을 나타낸다.](https://r-spatial.org/book/images/sf_deps.png){#fig-1-7}

C 혹은 C++ 라이브러리(GDAL, GEOS, PROJ, liblwgeom, s2geometry, NetCDF, udunits2)는 모두 R 커뮤니티와는 직접 관련성이 없는 (공간) 데이터사이언스 커뮤니티에 의해 개발, 유지 및 사용되고 있다. 이러한 라이브러리를 활용함으로써 R 사용자들은 이러한 다른 커뮤니티와 무엇을 공유하고 협업하고 있는지를 이해하게 된다. R, 파이썬, 줄리아는 상호작용형 인터페이스를 제공하고 있기 때문에 동일한 라이브러리를 활용하는 다른 소프트웨어의 사용자들과는 달리 이러한 라이브러리에 보다 가깝게 접근할 수 있다. 이 책의 첫 번째 파트에서는 이러한 라이브러리에 어떤한 개념이 녹아들어 있는지를 설명하고자 하는데, 공간데이터사이언스 일반을 이해하는데 도움이 될 것이다.

### GDAL

GDAL(Geospatial Data Abstraction Library)는 공간데이터에 대한 스위스 아미 나이프(Swiss army knife)정도로 생각할 수 있다. GDAL는 R, 파이썬, PostGIS 외에 100개가 넘는 다른 소프트웨어 프로젝트에서 사용되고 있다.

GDAL은 공간데이터를 읽고 쓸수 있게 해주는 라이브러리 중의 라이브러리로, 수많은 다른 라이브러리를 필요로 한다. 대략 100개가 넘는 라이브러리와 연결되어 있는데, 개별 라이브러리는 특정한 데이터 파일 포맷, 특정한 데이터베이스, 특정한 웹서비스, 특정한 압축 코덱을 다룰 수 있다.

CRAN(역자주: CRAN은 The Comprehensive R Archive Network의 약자로서, R의 수많은 패키지의 저장소로 이해하면 된다. R 언어 자체의 과거와 현재의 버전들 뿐만 아니라 현재 대략 20,000개 이상의 R 패키지가 모여 있다. 1997년 Kurt Hornik와 Friedrich Leisch에 의해 처음 만들어졌으며 현재에도 Hornik와 많은 자원봉사자들에 의해 운영되고 있다)에서 배포되는 바이너리 형식의 R 패키지에는 스태틱 링크 코드(statically linked code)만 포함되어 있는데, 이는 CRAN이 패키지의 호스트 시스템에 서드파티(third-party) 라이브러리가 존재하는지 그렇지 않은지에 대한 가정을 하지 않으려 하기 때문이다. 그 결과 CRAN으로부터 바이너리 형식의 `sf` 패키지를 인스톨하면, `sf` 패키지의 의존계 뿐만 아니라 모든 외부 라이브러리도 함께 다운로드되기 때문에 용량이 100 Mb에 달한다.

### PROJ

PROJ(혹은 PR$\phi$J)는 지도투영과 데이텀변환을 위한 라이브러리이다. 공간 좌표를 하나의 CRS로부터 다른 CRS로 바꾸어 준다. PROJ 속에는 현재까지 알려져 있는 수많은 투영법에 대한 데이터베이스가 포함되어 있으며, 데이터 그리드(데이텀변환을 위한 고정밀 계수값)에 접근할 수 있게 해준다. CRS의 국제 표준에 맞추어져 있다(Lott 2015). 2장에서 좌표계와 PROJ를 자세히 다룬다.

### GOES와 s2geometry

GOES(Geometry Engine Open Source)와 s2geometry는 지오메트리 오퍼레이션을 위한 라이브러리이다. 이 라이브러리를 활용해 기하학적 측정(길이, 면적, 거리), 논리적 판단(두 지오메트리가 포인트를 공유하고 있는지의 여부), 새로운 지오메트리의 생성(두 지오메트리가 공유하고 있는 포인트) 등의 오퍼레이션을 수행할 수 있다. GEOS는 이러한 오퍼레이션을 2차원 평면($R^2$)에서 수행할 수 있게 해주고, s2geometry는 3차원 구면($S^2$)에서 수행할 수 있게 해준다. 2장에서 CRS를 다루며, 4장에서는 2차원 공간과 3차원 공간을 다루는 데 있어 차이점에 대해 더 자세히 논의한다.

### NetCDF, udunits2, liblwgeom

NetCDF(UCAR 2020)은 파일 형식이자 NetCDF 파일을 읽고 쓰기 위한 C 라이브러리를 의미한다. NetCDF를 통해 모든 차원의 어레이를 정의할 수 있으며, 특히 (기후) 모델링 커뮤니티에서 공간 및 시공간 정보를 다루는데 널리 사용된다. Udunits2(UCAR 2014; Pebesma, Mailud, and Hiebert 2016; Pebesma et al. 2022)는 측정 단위와 관련된 데이터베이스이자 소프트웨어 라이브러리이다. Udunits2를 통해 측정 단위간 전환 및 파생 단위의 처리를 할 수 있고, 사용자-정의 단위에 대한 지원을 받을 수 있다. liblwgeom "라이브러리"는 POSTGIS(Obe and Hsu 2015)의 소프트웨어 요소로서 GDAL이나 GEOS에서는 다루지 않는 몇 가지 루틴을 포함하고 있다. 예를 들어 PROJ를 장착하고 있는 GeographicLib 루틴에 쉽게 접근할 수 있게 해준다.

## 연습문제

1.  래스터 데이터와 백터 데이터의 차이점 다섯 가지를 나열하라.

2.  그림 1.1 아래에 나열되어 있는 것 외에, 지도의 그래픽 요소 다섯 개를 더 나열하라.

3.  그림 1.5에 나타나 있는 수치 정보가 왜 오해를 불러일으키는지(혹은 무의미한지)에 대해 얘기해 보라.

4.  지오메트리 오퍼레이션을 $S^2$에서 행하는 것과 $R^2$에서 행하는 것의 차이가 가장 극명하게 드러나는 상황을 예를 들어 설명해 보라.
