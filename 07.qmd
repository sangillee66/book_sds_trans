---
date-modified: last-modified
number-sections: true
format: 
  html: 
    toc: true
code-link: true
code-copy: true
execute: 
  warning: false
  error: false
  freeze: auto
editor: visual
---

# sf와 stars {#sec-sf-stars}

이 장에서는 R 패키지인 **sf**와 **stars**를 소개한다. **sf**는 피처의 기하 정보를 리스트-컬럼에 저장하는 단순 피처의 테이블 포맷을 제공한다. **stars** 패키지는 래스터와 벡터 데이터 큐브(6장에서 다룸)를 지원하기 위해 작성되었으며, 래스터 레이어, 래스터 스택 및 피처 시계열 또한 지원한다. **sf**는 2016년에 CRAN에 처음 등장했고, **stars**는 2018년에 등장했다. 두 패키지의 개발은 R 컨소시엄의 지원과 강력한 커뮤니티 참여로 이루어졌다. 이 패키지들은 함께 작동하도록 설계되었다. **sf**나 **stars** 객체를 대상으로 하는 함수 또는 메서드는 `st_`로 시작하는데, 쉽게 관련 함수를 인식할 수 있을 뿐만 아니라 명령어 완성 기능을 사용할 때 검색의 용이함이 있다.

## sf 패키지 {#sec-sf}

R 패키지 **sf**(Pebesma 2018)는 기존의 R 패키지인 **sp**, r**geos** 및 **rgdal**의 벡터 부분을 대체하고 성공적으로 이어받기 위해 개발되었으며, 산업계 및 오픈 소스 프로젝트에서 볼 수 있는 표준 기반 접근법에 더 가까이 다가가고, 최신 버전의 오픈소스 지리공간 소프트웨어 스택(그림 1.7)을 기반으로 하며, 필요 시 R 공간 소프트웨어와 타이디버스(Wickham et al. 2019)의 통합을 가능하게 한다.

이를 위해 **sf**는 R에 네이티브로 심플 피처 접근(Herring et al. 2011)을 제공한다. 이 패키지는 여러 타이디버스 패키지, 특히 **ggplot2**, **dplyr**, **tidyr**와의 인터페이스를 제공하며, GDAL을 통해 데이터를 읽고 쓰고, GEOS(투영 좌표의 경우) 또는 s2geometry(타원체 좌표의 경우)를 사용하여 기하학적 연산을 수행하며, PROJ를 이용해 좌표 변환 또는 좌표 전환 작업을 수행할 수 있다. 외부 C++ 라이브러리와의 인터페이싱(연결)은 **Rcpp** 패키지(Eddelbuettel 2013)를 통해 이루어진다.

**sf**는 `sf` 객체로 심플 피처를 나타내며, 이는 `data.frame` 또는 티블(tibble)의 하위 클래스이다. `sf` 객체는 최소 하나 이상의 `sfc` 클래스의 지오메트리 *리스트 열*(list-column)을 포함하는데, 각 요소는 `sfg` 클래스의 R 객체로서 지오메트리 정보를 담고 있다. 지오메트리 리스트 열은 `data.frame` 또는 티블 내에서 변수처럼 작동하지만, 숫자나 문자형 변수와 같은 기본 벡터보다 더 복잡한 구조를 가지고 있다(부록 B.3 참조).

`sf` 객체는 다음과 같은 메타데이터를 가진다.

-   (활성화된) 지오메트리 열의 이름: `sf_column` 속성에 저장되어 있음.

-   각 비기하 변수의 속성-지오메트리 관계 (5.1절 참조): `agr` 속성에 저장되어 있음.

`sfc` 지오메트리 리스트 열은 `st_geometry`함수를 통해 `sf` 객체에서 추출되며, 다음과 같은 메타데이터를 가진다

-   좌표참조계: `crs` 속성에 저장되어 있음.

-   바운딩 박스: `bbox` 속성에 저장되어 있음.

-   정밀도: `precision` 속성에 저장되어 있음.

-   지오메트리 수: `n_empty` 속성에 저장되어 있음.

이러한 속성들의 값을 확인하거나 수정하기 위해 `st_bbox`, `st_crs`, `st_set_crs`, `st_agr`, `st_set_agr`, `st_precision`, `st_set_precision` 같은 함수를 사용할 수 있다.

### 생성

다음과 같은 방식으로 `sf` 객체를 생성할 수 있다.

```{r}
#| eval: false
library(sf)
# Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE
p1 <- st_point(c(7.35, 52.42))
p2 <- st_point(c(7.22, 52.18))
p3 <- st_point(c(7.44, 52.19))
sfc <- st_sfc(list(p1, p2, p3), crs = 'OGC:CRS84')
st_sf(elev = c(33.2, 52.1, 81.2), 
      marker = c("Id01", "Id02", "Id03"), geom = sfc)
# Simple feature collection with 3 features and 2 fields
# Geometry type: POINT
# Dimension:     XY
# Bounding box:  xmin: 7.22 ymin: 52.2 xmax: 7.44 ymax: 52.4
# Geodetic CRS:  WGS 84
#   elev marker              geom
# 1 33.2   Id01 POINT (7.35 52.4)
# 2 52.1   Id02 POINT (7.22 52.2)
# 3 81.2   Id03 POINT (7.44 52.2)
```

![sf 객체의 구조](https://r-spatial.org/book/images/sf_obj.png){#fig-7-1}

그림 7.1은 출력된 구성 요소에 대한 설명을 제공한다. 객체를 처음부터 생성하는 대신, R에서의 공간데이터는 보통 외부 소스에서 읽어오며, 그 외부 소스에는 다음과 같은 것이 있다.

-   외부 파일

-   데이터베이스 내의 테이블(또는 테이블 집합)

-   웹서비스에서 호출을 통해 획득된 데이터셋

-   R 패키지에 포함되어 있는 데이터셋

### 읽어오기와 쓰기

외부 "데이터 소스"(파일, 웹서비스 또는 문자열)로부터 데이터셋을 읽어오는 것은 `st_read()` 함수를 사용하여 수행된다.

```{r}
#| output: false
library(sf)
(file <- system.file("gpkg/nc.gpkg", package = "sf"))
# [1] "/home/edzer/R/x86_64-pc-linux-gnu-library/4.3/sf/gpkg/nc.gpkg"
nc <- st_read(file)
# Reading layer `nc.gpkg' from data source 
#   `/home/edzer/R/x86_64-pc-linux-gnu-library/4.3/sf/gpkg/nc.gpkg' 
#   using driver `GPKG'
# Simple feature collection with 100 features and 14 fields
# Geometry type: MULTIPOLYGON
# Dimension:     XY
# Bounding box:  xmin: -84.3 ymin: 33.9 xmax: -75.5 ymax: 36.6
# Geodetic CRS:  NAD27
```

여기서 파일 이름과 경로는 sf 패키지에서 읽어오는 것인데, sf 패키지를 설치하는 과정에서 설정된 것이므로 어떤 컴퓨터에서건 예외없이 읽어들여진다.

`st_read()` 명령어는 두 개의 아규먼트(*데이터 소스 이름*(dsn)과 *레이어*(layer))를 가진다. 위의 예에서 *geopackage*(GPKG) 파일은 단일 레이어만 포함하고 있으며, 해당 레이어가 불러들여진 것이다. 만약 여러 레이어가 포함되어 있었다면, 첫 번째 레이어가 읽히고 경고 메시지가 표출되었을 것이다. 데이터셋의 사용 가능한 레이어는 다음과 같이 조회할 수 있다.

```{r}
#| eval: false
st_layers(file)
# Driver: GPKG 
# Available layers:
#   layer_name geometry_type features fields crs_name
# 1    nc.gpkg Multi Polygon      100     14    NAD27
```

심플 피처 객체는 `st_write` 함수를 사용하여 저장할수 있다.

```{r}
#| eval: false
(file = tempfile(fileext = ".gpkg"))
# [1] "/tmp/Rtmpm9lGRF/file361e653fae4a9.gpkg"
st_write(nc, file, layer = "layer_nc")
# Writing layer `layer_nc' to data source 
#   `/tmp/Rtmpm9lGRF/file361e653fae4a9.gpkg' using driver `GPKG'
# Writing 100 features with 14 fields and geometry type Multi Polygon.
```

여기서 파일 형식(GPKG)은 파일 이름 익스텐션에서 파생된다. `st_write()` 함수의 `append` 아규먼트 설정을 통해 기존 레이어에 레코드를 추가하거나 아예 레이어를 교체할 수 있는데, `append` 아규먼트 설정되지 않으면 레이어가 이미 존재할 경우 오류가 발생한다. 타이디버스 스타일의 `write_sf()` 함수는 `append`가 설정되지 않은 경우 오류 표출 없이 레이어를 교체한다. 또한, `st_delete()` 함수를 사용하여 레이어를 삭제할 수 있으며, 이는 특히 데이터베이스의 테이블과 연결되어 있는 레이어를 다룰 때 편리하다.

WKT-2 좌표참조계를 지원하는 파일 형식의 경우, `st_read()`와 `st_write()`는 이를 읽고 쓸 수 있다. 그러나 `csv`와 같은 간단한 포맷에서는 이 기능이 작동하지 않는다. 또한, 셰이프파일(shapefile) 형식은 CRS에 대해 매우 제한된 인코딩만 지원한다.

### 부분을 골라내기

매우 일반적인 작업 중 하나는 객체의 일부분을 골라내기(subset)하는 것이며, 베이스 R에서는 이를 위해 대괄호 기호(\[) 를 사용한다. `data.frame` 객체에 적용되는 규칙을 sf 객체에 그대로 적용할 수 있다. 예를 들어, 다음과 같은 코드를 통해 레코드 2에서 5와 열 3에서 7을 선택할 수 있다.

```{r}
#| eval: false
nc[2:5, 3:7]
```

여기에 몇몇 옵션을 부가적으로 적용할 수 있다.

-   `drop` 아규먼트가 디폴트로 FALSE로 설정되어 있는데, 지오메트리 열이 *항상* 선택되며 `sf` 객체가 반환된다. TRUE로 설정되면, 지오메트리열이 선택되지 않으면 해당 열이 제거된 `data.frame`이 반환된다.

-   공간(`sf`, `sfc` 또는 `sfg`) 객체를 첫 번째 아규먼트로 사용한 선택은 해당 객체와 공간적으로 *교차*하는 피처를 선택하는 결과를 가져온다(다음 절 참조). 다른 프레디케이트를 선택하고자 할 경우, **op** 아규먼트를 설정하여 `st_covers`와 같은 함수 또는 3.2.2절에 나열된 다른 이항 프레디케이트 함수로 지정할 수 있다.

### 바이너리 프레디케이트

`st_intersects`, `st_covers`와 같은 이항 프레디케이트 함수(3.2.2절 참조)는 두 개의 피처 집합 또는 피처 지오메트리를 입력받아 모든 쌍에 대해 조건이 TRUE인지 FALSE인지를 반환한다. 대규모 집합의 경우, 이는 일반적으로 대부분 FALSE 값으로 채워진 거대한 행렬을 생성할 수 있으며, 이러한 이유로 기본적으로 희소 표현(sparse representation)이 반환된다(역자주: 희소 표현은 메모리 사용을 최적화하고, 데이터 처리를 더욱 효율적으로 만들어 준다. 희소 표현을 일반적으로 TRUE 값만을 저장하고, FALSE 값은 저장하지 않는다.)

```{r}
#| output: false
nc5 <- nc[1:5, ]
nc7 <- nc[1:7, ]
(i <- st_intersects(nc5, nc7))
# Sparse geometry binary predicate list of length 5, where the
# predicate was `intersects'
#  1: 1, 2
#  2: 1, 2, 3
#  3: 2, 3
#  4: 4, 7
#  5: 5, 6
```

```{r}
#| echo: false
#| label: fig-7-2
#| fig-cap: "노스케롤라이나의 첫 7개의 카운티"
library(sf)
plot(st_geometry(nc7))
plot(st_geometry(nc5), add = TRUE, border = "brown")
cc = st_coordinates(st_centroid(st_geometry(nc7)))
text(cc, labels = 1:nrow(nc7), col = "blue")
```

그림 7.2는 첫 다섯 개 카운티와 첫 일곱 개 카운티의 교차를 이해하는 방법을 보여준다. 다음과 같은 방식으로 희소 논리 행렬을 조밀한 행렬(dense matrix)로 변환할 수 있다.

```{r}
#| output: false
as.matrix(i)
#       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]
# [1,]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
# [2,]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE
# [3,] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE
# [4,] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE
# [5,] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE
```

`nc5`의 개별 카운티가 교차하는 `nc7` 카운티의 수는 다음과 같이 계산할 수 있다.

```{r}
#| output: fale
lengths(i)
# [1] 2 3 2 2 2
```

역으로 `nc7`의 개별 카운티가 교차하는 `nc5`의 카운티의 수는 다음과 같이 계산할 수 있다.

```{r}
#| output: false
lengths(t(i))
# [1] 2 3 2 1 1 1 1
```

객체 `i` 가 `sgbp`(sparse geometrical binary predicate) 클래스의 한 객체라고 했을 때, 객체 `i`는 정수 벡터의 리스트로 주어지는데, 리스트의 각 요소는 논리 프레디케이트 행렬의 한 행을 나타내고, 논리 프레디케이트 행렬은 해당 행에 대해 TRUE 값을 갖는 열의 인덱스를 보유하고 있다. 이 객체는 사용된 프레디케이트 및 총 열 수와 같은 메타데이터도 포함하고 있다. sgbp 객체에 적용할 수 있는 메소드에 다음과 같은 것들이 있다.

```{r}
#| output: false
methods(class = "sgbp")
#  [1] as.data.frame as.matrix     coerce        dim          
#  [5] initialize    Ops           print         show         
#  [9] slotsFromS3   t            
# see '?methods' for accessing help and source code
```

`sgbp` 클래스의 객체에서 사용 가능한 유일한 `Ops` 메서드는 `!`(부정 연산자)이다.

### 타이디버스

**tidyverse** 패키지는 다양한 데이터사이언스 패키지를 함께 로드한다(Wickham and Grolemund 2017; Wickham et al. 2019). **sf** 패키지는 **tidyverse** 스타일의 읽기 및 쓰기 함수인 read_sf()와 write_sf()를 제공하며, 이 함수들은 다음과 같은 특징이 있다.

-   `data.frame` 대신 `tibble`을 반환한다.

-   출력 내용을 인쇄하지 않는다.

-   기본적으로 기본 데이터를 덮어쓴다.

`sf` 객체에 사용될 수 있는 **tidyverse** 로 `filter`, `select`, `group_by`, `ungroup`, `mutate`, `transmute`, `rowwise`, `rename`, `slice`, `summarise`, `distinct`, `gather`, `pivot_longer`, `spread`, `nest`, `unnest`, `unite`, `separate`, `separate_rows`, `sample_n`, 및 `sample_frac`등과 같은 것이 있다. 대부분의 함수는 `sf` 객체의 메타데이터를 관리하기만 할 뿐 지오메트리 정보를 건드리지 않는다. 사용자가 지오메트리를 제거하고자 할 경우, `st_drop_geometry`를 사용하거나 선택하기 전에 간단히 `tibble` 또는 `data.frame`으로 강제 변환(coerce)할 수 있다.

```{r}
#| output: false
library(tidyverse) |> suppressPackageStartupMessages()
nc |> as_tibble() |> select(BIR74) |> head(3)
# # A tibble: 3 × 1
#   BIR74
#   <dbl>
# 1  1091
# 2   487
# 3  3188
```

`sf` 객체에 대한 `summarise` 함수는 두 가지 특별한 아규먼트를 가지고 있다

-   `do_union` (기본값: TRUE): 그룹화된 지오메트리가 반환 시 유니언(합집합)되는지 여부를 결정하여, 유효한 지오메트리가 형성하도록 한다.

-   `is_coverage` (기본값: FALSE): 그룹화된 지오메트리가 커버리지(겹침이 없는 경우)를 형성하는 경우, 이를 TRUE로 설정하면 유니언 과정이 빨라진다.

`distinct` 함수는 고유한 레코드를 선택하며, `st_equals` 함수는 지오메트리의 고유성을 평가한다.

`filter` 함수는 일반적인 프레디케이트와 함께 사용할 수 있으며, 공간적 프레디케이트를 사용하고자 할 경우, 예를 들어 오렌지 카운티에서 50km 이내에 있는 모든 카운티를 선택하려면 다음과 같이 사용할 수 있다.

```{r}
#| output: false
orange <- nc |> dplyr::filter(NAME == "Orange")
wd <- st_is_within_distance(nc, orange, 
                            units::set_units(50, km))
o50 <- nc |> dplyr::filter(lengths(wd) > 0)
nrow(o50)
# [1] 17
```

(여기서 `dplyr::filter`를 사용하는 것은 베이스 R의 `filter` 함수와의 혼동을 피하기 위함이다.)

그림 7.3은 이 분석의 결과를 보여주며, 카운티 경계 주위에 버퍼도 추가되어 있다. 이 버퍼는 설명을 위한 것이며, 카운티를 선택하는 데 사용되지는 않았음을 주의하라.

```{r}
#| echo: false
#| label: fig-7-3
#| fig-cap: "오렌지 카운티(오렌지색), 반경 50km 내의 카운티(검은색), 오랜지 카운티 주변의 버퍼(갈색), 나머지 카운티(회색)"
og <- st_geometry(orange)
buf50 <- st_buffer(og, units::set_units(50, km))
all <- c(buf50, st_geometry(o50))
plot(st_geometry(o50), lwd = 2, extent = all)
plot(og, col = 'orange', add = TRUE)
plot(buf50, add = TRUE, col = NA, border = 'brown')
plot(st_geometry(nc), add = TRUE, border = 'grey')
```

## 공간적 조인

일반적인 조인(왼쪽, 오른쪽 또는 내부 조인)에서는 두 테이블 사이에서 하나 이상의 속성이 일치할 때 조인이 이루어진다. 공간적 조인도 이와 유사하지만, 레코드를 조인하는 기준은 속성의 일치가 아니라 공간적 프레디케이트이다. 이로 인해 공간적으로 일치하는 레코드를 정의하는 다양한 선택지가 있으며, 이는 3.2.2절에 나열된 바이너리 프레디케이트를 사용하여 결정할 수 있다. "왼쪽," "오른쪽," "내부," 또는 "전체" 조인의 개념은 비공간 조인과 동일하게 유지되는데, 이 경우는 공간적 일치를 상정하지 않은 상태에서 레코드의 조인을 처리할 때이다.

공간적 조인을 실행할 때, 각 레코드에 여러 일치하는 레코드가 있을 수 있어 결과 테이블이 매우 커질 수 있다. 이 복잡성을 줄이는 방법으로, 일치하는 레코드 중에서 타깃 지오메트리와 가장 넓은 면적이 겹치는 레코드 하나를 선택하는 방식이 있다. 이 방법의 시각적 예시는 그림 7.4에 나타나 있으며, `st_join` 함수에서 `largest = TRUE` 아규먼트를 사용하여 이를 수행할 수 있다.

```{r}
#| echo: false
#| label: fig-7-4
#| fig-cap: "largest = TRUE 아규먼트를 적용한 st_join 함수의 예: 아래쪽 그림의 폴리곤과 가장 넓은 면적이 겹치는 위쪽 그림의 폴리곤 라벨이 아래쪽 폴리곤에 할당되어 있다."
# example of largest = TRUE:
system.file("shape/nc.shp", package="sf") |> 
    read_sf() |>
    st_transform('EPSG:2264') -> nc
gr <- st_sf(
         label = apply(expand.grid(1:10, LETTERS[10:1])[,2:1], 1, paste0, collapse = ""),
         geom = st_make_grid(nc))
gr$col <- sf.colors(10, categorical = TRUE, alpha = .3)
# cut, to verify that NA's work out:
gr <- gr[-(1:30),]
suppressWarnings(nc_j <- st_join(nc, gr, largest = TRUE))
par(mfrow = c(2,1), mar = rep(0,4))
plot(st_geometry(nc_j), border = 'grey')
plot(st_geometry(gr), add = TRUE, col = gr$col)
text(st_coordinates(st_centroid(st_geometry(gr))), labels = gr$label, cex = .85)
# the joined dataset:
plot(st_geometry(nc_j), border = 'grey', col = nc_j$col)
text(st_coordinates(st_centroid(st_geometry(nc_j))), labels = nc_j$label, cex = .7)
plot(st_geometry(gr), border = '#88ff88aa', add = TRUE)
```

결과의 복잡성을 줄이는 또 다른 방법은 조인 후에 `aggregate` 함수를 사용하여 모든 일치하는 레코드를 결합함과 동시에 지오메트리도 병합하는 것이다. 이에 대한 자세한 내용은 5.4절을 참고하라.

### 샘플링, 그리딩, 인터폴레이팅

`sf` 패키지가 제공하는 유용한 함수 몇 가지를 소개하고자 한다. `st_sample` 함수는 타깃 지오메트리로부터 임의의 샘플링 포인트를 생성해 주는데, 타깃 지오메트리는 점, 선, 또는 폴리곤 등 다양할 수 있다. 샘플링 방식으로 완전 무작위 방식, 규칙적 방식, 또는 폴리곤의 경우 삼각형 방식이 선택될 수 있다. 11장에서 `spatstat` 패키지에서 제공하는 공간적 샘플링(또는 포인트 패턴 시뮬레이션) 방법들이 어떻게 `st_sample` 함수를 통해 이루어지는지 설명한다.

`st_make_grid` 함수는 특정 영역 위에 정사각형, 직사각형, 또는 육각형의 그리드를 생성해준다. 옵션을 다르게 적용하면 그리드 자체가 아니라 그리드의 중심점 혹은 구석점을 생성해준다. 이 함수는 그림 7.4에서 직사각형 그리드를 생성하는 데 사용되었다.

함수 `st_interpolate_aw`는 5.3절에서 설명된 대로 공간적으로 내포적인 변수와 공간적으로 외연적인 변수를 새로운 영역으로 "인터폴레이션"하는 기능을 제공한다.

## 타원 좌표

비투영 데이터는 경위도로 표현된 타원체 좌표를 가진다. 4.1절에서 설명된 대로, 포인트간 "직선"은 최단 곡선 경로("측지선")이다. 기본적으로 **sf** 패키지는 `s2geometry` 라이브러리의 기하학적 연산을 사용하며, 이는 **s2** 패키지를 통해 이루어진다(Dunnington, Pebesma, and Rubak 2023). 예를 들어, 아래의 지점은 특정 폴리곤 *내부*에 존재한다(그림 7.5의 왼쪽 그림: 정사 도법).

```{r}
"POINT(50 50.1)" |> st_as_sfc(crs = "OGC:CRS84") -> pt
```

```{r}
#| output: false
"POLYGON((40 40, 60 40, 60 50, 40 50, 40 40))" |>
  st_as_sfc(crs = "OGC:CRS84") -> pol
st_intersects(pt, pol)
# Sparse geometry binary predicate list of length 1, where the
# predicate was `intersects'
#  1: 1
```

```{r}
#| echo: false
#| label: fig-7-5
#| fig-cap: "인터섹션의 결과는 측지선 혹은 대권호를 사용하느냐(왼쪽) 데카르트 좌표계를 사용하느냐에 따라 달라진다."
par(mfrow = c(1, 2))
par(mar = c(2.1, 2.1, 1.2, .5))
ortho <- st_crs("+proj=ortho +lon_0=50 +lat_0=45")
pol |> st_transform(ortho) |> plot(axes = TRUE, graticule = TRUE, 
                                   main = 's2geometry')
pt |> st_transform(ortho) |> plot(add = TRUE, pch = 16, col = 'red')
# second plot:
plot(pol, axes = TRUE, graticule = TRUE, main = 'GEOS')
plot(pt, add = TRUE, pch = 16, col = 'red')
```

**sf** 패키지가 타원체 좌표를 마치 데카르트 좌표처럼 사용하도록 하려면, **s2** 사용을 비활성화하면 된다.

```{r}
#| output: false
old <- sf_use_s2(FALSE)
# Spherical geometry (s2) switched off
st_intersects(pol, pt)
# although coordinates are longitude/latitude, st_intersects assumes
# that they are planar
# Sparse geometry binary predicate list of length 1, where the
# predicate was `intersects'
#  1: (empty)
sf_use_s2(old) # restore
# Spherical geometry (s2) switched on
```

이렇게 하면, 그림 7.5의 오른쪽 그림(정거원통 도법)처럼, 엠프티 인터섹션이 리턴된다. 타원체 좌표를 평면 좌표로 취급한다는 점이 경고 메시지에 명시되어 있다.

성능이나 레거시 구현과의 호환성 이유로 **s2** 사용을 비활성화할 수 있다. 데카르트 기하학을 위한 **GEOS** 라이브러리와 구체 기하학을 위한 **s2geometry** 라이브러리(그림 1.7)는 서로 다른 동기로 개발되었으며, **sf**를 통해 사용될 때 그 방식에서 몇 가지 차이가 있다.

-   특정 오퍼레이션에서 속도차가 크게 날 수 있다.

-   특정 함수는 오로지 특정 라이브러리에만 존재한다(예를 들어 `st_relate` 함수는 **GEOS** 라이브러리에만 존재)

-   변환자(transformer)를 사용할 때, **GEOS**는 외부 폴리곤 링을 시계 방향으로 노드로 반환하며, 이를 반시계 방향으로 되돌리기 위해 `st_sfc(..., check_ring_dir = TRUE)`를 사용한다. 반면, `s2geometry`는 외부 폴리곤 링을 반시계 방향으로 반환한다.

## stars 패키지

`sp` 패키지가 래스터 데이터에 대한 지원이라는 측면에서 정체되어 있는 동안, `raster` 패키지(Hijmans 2023a)가 지난 10여년 동안 래스터 분석을 위한 강력하고 유연하며 확장 가능한 패키지로서 지배적인 위치를 공고히 하였다. `raster` 패키지(및 그 후속인 `terra` 패키지(Hijmans 2023b))는 2D 규칙 래스터 또는 래스터 레이어 집합(“래스터 스택”)이라는 래스터 데이터 모델에 기반하고 있다. 이는 세상이 수많은 레이어로 구성되어 있고 개별 레이어는 특정한 주제를 반영하고 있다는 고전적인 정적 “GIS 뷰”와 일치한다. 그러나 오늘날의 많은 데이터는 동적이며, 시계열 래스터 또는 시계열 래스터 스택으로 제공된다. 기존의 래스터 스택은 이러한 동적 특성을 제대로 반영하지 못하며, 사용자늘 어떤 레이어가 무엇을 나타내는지를 기록하고 있어야만 한다.

또한, `raster` 패키지와 그 후속인 `terra` 패키지는 데이터 크기가 로컬 저장소(컴퓨터의 하드 드라이브)보다 크지 않을 때에만 훌륭한 전산 처리 능력을 발휘한다. 그러나 최근 데이터셋, 예를 들어 위성 이미지, 기후 모델 또는 기상 예보 데이터는 로컬 저장소의 용량으로는 더 이상 감당하기 어려운 수준에 도달했다(9장 참조). `spacetime` 패키지(Pebesma 2012, 2022)는 벡터 지오메트리 또는 래스터 그리드 셀의 시계열 분석을 어느 정도 다룰 수 있다. 하지만 더 높은 차원의 어레이나 메모리가 감당하기 어려운 정도의 크기를 가진 데이터셋은 여전히 다루기 어렵다.

여기서 우리는 래스터 및 벡터 데이터 큐브 분석을 위한 패키지로 `stars`를 소개한다. 이 패키지는 다음과 같은 기능을 제공한다.

-   동적(시간 변화) 래스터 스택을 재현할 수 있다.

-   로컬 디스크의 크기에 한정되지 않는 확장 가능성을 목표로 한다.

-   GDAL 라이브러리의 래스터 기능과 강력한 통합을 제공한다.

-   규칙 그리드 외에도 회전, 전단, 직선, 곡선 래스터를 처리할 수 있다(그림 1.6 참조).

-   sf 패키지와의 긴밀한 통합을 제공한다.

-   비래스터(non-raster) 공간 차원을 가진 어레이 데이터(벡터 데이터 큐브)를 처리할 수 있다.

-   타이디버스 디자인 원리를 따른다.

벡터 데이터 큐브에는 심플 피처의 시계열이나 출발지-목적지 매트릭스(그것의 시계열 포함)와 같은 공간 그래프 데이터가 포함된다. 공간적 벡터 및 래스터 데이터 큐브의 개념은 6장에서 설명되었다. 불규칙 시공간 관측치는 `sftime` 패키지(Teickner, Pebesma, and Graeler 2022)에서 제공하는 `sftime` 객체로 재현될 수 있으며, 이는 시간 열을 추가하는 방식으로 `sf` 객체를 확장한 것이다(13.3절 참조).

### 래스터 데이터의 읽기와 쓰기

래스터 데이터는 일반적으로 파일을 불러온다. 우리는 브라질의 올린다 시에 대한 30m 해상도의 Landsat 7 데이터셋(밴드 1-5 및 7)을 사용한다. 패키지 **stars**에서 규칙 비회전 그리드에 대한 예제 GeoTIFF 파일을 읽을 수 있다.

```{r}
#| output: false
tif <- system.file("tif/L7_ETMs.tif", package = "stars")
library(stars)
# Loading required package: abind
(r <- read_stars(tif))
# stars object with 3 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs.tif     1      54     69 68.9      86  255
# dimension(s):
#      from  to  offset delta            refsys point x/y
# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]
# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
# band    1   6      NA    NA                NA    NA
```

여기서 우리는 오프셋, 셀 크기, 좌표참조계, 및 차원을 확인할 수 있다. 차원 테이블은 각 차원에 대해 다음과 같은 필드를 포함한다.

-   `from`: 시작 인덱스 값

-   `to`: 종료 인덱스 값

-   `offset`: 첫 번째 픽셀의 시작(모서리)에서의 차원 값

-   `delta`: 셀 크기로 음의 delta 값은 디멘션 값이 감소할수록 필셀 인덱스 값이 증가한다는 것을 의미

-   `refsys`: 참조계

-   `point`: 셀 값이 포인트 서포트인지, 셀 서포트인지를 명시하는 논리 값

-   `x/y`: 디멘션이 래스터의 x- 축과 관련되는지 y-축과 관련되는지를 나타내는 값

여기에는 사용되지 않기 때문에 숨겨진 또 다른 필드인 `values`가 있다. 정규, 회전, 또는 전단 그리드와 같은 규칙적으로 이산화된 차원(예: 시간)의 경우, 오프셋과 델타는 NA가 아니다. 반면 불규칙한 경우에는 오프셋과 델타가 NA이며, `values` 속성은 다음 중 하나를 포함한다.

-   값 또는 구간의 시퀀스: 직선 공간 래스터 또는 불규칙 시간 차원의 경우

-   공간 차원과 연결된 지오메트리: 벡터 데이트 큐브의 경우

-   각 래스터 셀에 대한 좌표값이 포함된 매트릭스: 곡선 래스터의 경우

-   차원 값과 연결된 밴드 이름 또는 레이블: 이산 디멘션의 경우

`stars` 클래스의 객체 `r`은 길이가 1인 간단한 리스트로 구성되어 있으며, 3차원 어레이를 포함한다.

```{r}
#| output: false
length(r)
# [1] 1
class(r[[1]])
# [1] "array"
dim(r[[1]])
#    x    y band 
#  349  352    6
```

또한, 이 객체는 어레이 차원이 무엇을 나타내는지 알기 위해 필요한 모든 메타데이터를 포함한 디멘션 테이블을 속성으로 가지고 있다. 이는 다음을 통해 얻어진다.

```{r}
#| output: false
st_dimensions(r)
```

어레이의 공간적 범위에 대한 정보를 다음과 같이 얻을 수 있다.

```{r}
#| output: false
st_bbox(r)
#    xmin    ymin    xmax    ymax 
#  288776 9110729  298723 9120761
```

`write_stars` 함수를 통해 래스터 데이터를 로컬 디스크에 저장할 수 있다.

```{r}
#| output: false
tf <- tempfile(fileext = ".tif")
write_stars(r, tf)
```

파일 확장자를 통해 데이터 형식(이 경우, GeoTIFF)이 지정된다. 단순 피처와 마찬가지로 읽기 및 쓰기 작업은 GDAL 라이브러리를 사용하며, 래스터 데이터에 사용할 수 있는 드라이버 목록은 다음을 통해 확인할 수 있다.

```{r}
#| output: false
st_drivers("raster")
```

### `stars` 데이터 큐브로부터 일부분 골라내기

데이터 큐브는 `[` 연산자를 사용하거나 타이디버스 동사를 사용하여 부분 집합을 만들 수 있다. 첫 번째 옵션인 `[`를 사용하는 방식은 다음의 아규먼트를 쉼표의 구분과 함께 순서대로 지정하는 것이다.

-   속성(이름, 인덱스, 또는 논리 벡터)

-   차원

예를 들어, `r[1:2, 101:200,, 5:10]`는 `r`에서 속성 1-2를 선택하고, 디멘션 1에 대해 인덱스 101-200, 차원 3에 대해 인덱스 5-10을 선택함을 의미한다. 차원 2를 통한 선택은 이루어지지 않는다. 속성의 경우, 속성 이름, 인덱스 또는 논리 벡터를 사용할 수 있다. 차원의 경우에는 논리 벡터가 지원되지 않는다. 불연속 범위 선택은 규칙 시퀀스일 때만 지원된다. 기본적으로 `drop`은 `FALSE`로 설정되어 있으며, `TRUE`로 설정하면 단일 값을 가진 차원은 모두 제거된다.

```{r}
#| output: false
r[,1:100, seq(1, 250, 5), 4] |> dim()
#    x    y band 
#  100   50    1
r[,1:100, seq(1, 250, 5), 4, drop = TRUE] |> dim()
#   x   y 
# 100  50
```

특정 범위의 차원 *값*을 선택하기 위해 `filter` 함수를 사용할 수 있는데, 이는 `dplyr` 패키지를 우선적으로 로드해야 한다.

```{r}
#| output: false
library(dplyr, warn.conflicts = FALSE)
filter(r, x > 289000, x < 290000)
# stars object with 3 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs.tif     5      51     63 64.3      75  242
# dimension(s):
#      from  to  offset delta            refsys point x/y
# x       1  35  289004  28.5 SIRGAS 2000 / ... FALSE [x]
# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
# band    1   6       1     1                NA    NA
```

이는 차원의 오프셋을 변경한다. 특정 큐브 슬라이스는 `slice` 함수를 사용하여 얻을 수 있다.

```{r}
#| output: false
slice(r, band, 3)
# stars object with 2 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs.tif    21      49     63 64.4      77  255
# dimension(s):
#   from  to  offset delta            refsys point x/y
# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]
# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
```

이는 단일 차원 `band`를 제거한다. `mutate` 함수는 `stars` 객체에서 기존 어레이를 기반으로 새로운 어레이를 추가하는 데 사용되며, `transmute`는 여기에 덧붙여 기존 어레이를 제거한다.

### 잘라내기

부분 집합을 생성하는 또 다른 방법에 `sf`, `sfc` 또는 `bbox` 클래스의 공간 객체를 사용하는 방법이 있다.

```{r}
#| output: false
b <- st_bbox(r) |>
    st_as_sfc() |>
    st_centroid() |>
    st_buffer(units::set_units(500, m))
r[b]
# stars object with 3 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max. NA's
# L7_ETMs.tif    22      54     66 67.7    78.2  174 2184
# dimension(s):
#      from  to  offset delta            refsys point x/y
# x     157 193  288776  28.5 SIRGAS 2000 / ... FALSE [x]
# y     159 194 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
# band    1   6      NA    NA                NA    NA
```

예를 들어, 해당 지역에 대한 직경 500m의 원형 중심부를 추출할 수 있는데, 그림 7.6에는 첫 번째 밴드에 적용한 결과가 나타나 있다.

```{r}
#| echo: false
#| label: "fig-7-6"
#| fig-cap: "Landsat 7 (band 1) 이미지의 원형 중심부"
plot(r[b][,,,1], reset = FALSE)
plot(b, border = 'brown', lwd = 2, col = NA, add = TRUE)
```

원형 공간 객체의 외부에 존재하는 픽셀에는 NA 값이 할당되는 것을 볼 수 있다. 이 원형 객체는 여전히 `r`의 `offset`과 `delta` 값에 대한 차원 인덱스를 가지고 있다. 다음과 같은 방식으로 `offset` 값을 재설정할 수 있다.

```{r}
#| output: false
r[b] |> st_normalize() |> st_dimensions()
#      from to  offset delta            refsys point x/y
# x       1 37  293222  28.5 SIRGAS 2000 / ... FALSE [x]
# y       1 36 9116258 -28.5 SIRGAS 2000 / ... FALSE [y]
# band    1  6      NA    NA                NA    NA
```

기본적으로, 결과 래스터는 선택 객체의 범위로 잘린다. 입력 객체와 동일한 차원을 가진 객체는 다음과 같은 방식으로 얻을 수 있다.

```{r}
#| output: false
r[b, crop = FALSE]
# stars object with 3 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max.   NA's
# L7_ETMs.tif    22      54     66 67.7    78.2  174 731280
# dimension(s):
#      from  to  offset delta            refsys point x/y
# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]
# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
# band    1   6      NA    NA                NA    NA
```

`stars` 객체의 잘라내기는 `st_crop` 함수를 사용하여 직접 수행할 수도 있다.

```{r}
#| output: false
st_crop(r, b)
```

### stars 객체의 차원재부여 및 결합

`stars` 패키지는 다양한 어레이 조작을 수행하기 위해 패키지 `abind` (Plate and Heiberger 2016)를 사용한다. 한 예로 어레이를 순열하여 전치하는 `aperm` 함수이다.

```{r}
#| output: false
aperm(r, c(3, 1, 2))
# stars object with 3 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs.tif     1      54     69 68.9      86  255
# dimension(s):
#      from  to  offset delta            refsys point x/y
# band    1   6      NA    NA                NA    NA    
# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]
# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
```

`stars` 객체에 대한 메서드가 제공되며, 결과 객체의 차원 순서를 순열한다.

속성과 차원을 교환할 수 있으며, 이는 `split`과 `merge`를 사용하여 수행된다.

```{r}
#| output: false
(rs <- split(r))
# stars object with 2 dimensions and 6 attributes
# attribute(s):
#     Min. 1st Qu. Median Mean 3rd Qu. Max.
# X1    47      67     78 79.1      89  255
# X2    32      55     66 67.6      79  255
# X3    21      49     63 64.4      77  255
# X4     9      52     63 59.2      75  255
# X5     1      63     89 83.2     112  255
# X6     1      32     60 60.0      88  255
# dimension(s):
#   from  to  offset delta            refsys point x/y
# x    1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]
# y    1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
merge(rs, name = "band") |> setNames("L7_ETMs")
# stars object with 3 dimensions and 1 attribute
# attribute(s):
#          Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs     1      54     69 68.9      86  255
# dimension(s):
#      from  to  offset delta            refsys point    values x/y
# x       1 349  288776  28.5 SIRGAS 2000 / ... FALSE      NULL [x]
# y       1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE      NULL [y]
# band    1   6      NA    NA                NA    NA X1,...,X6
```

`split` 함수는 밴드 차원을 2차원 어레이의 여섯 개 속성에 분배하며, `merge` 함수는 거꾸로 수행한다. `st_redimension` 함수는 단일 어레이 차원을 두 개의 새로운 차원으로 분할하는 것과 같은 보다 일반적인 작업에 사용된다.

```{r}
#| output: false
st_redimension(r, c(x = 349, y = 352, b1 = 3, b2 = 2))
# stars object with 4 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs.tif     1      54     69 68.9      86  255
# dimension(s):
#    from  to  offset delta            refsys point x/y
# x     1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]
# y     1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
# b1    1   3      NA    NA                NA    NA    
# b2    1   2      NA    NA                NA    NA
```

동일한 차원을 가진 여러 개의 `stars` 객체는 `c`를 사용하여 결합할 수 있다. 결합된 어레이는 추가적인 속성으로 취급하는 것이 디폴트 설정이지만, `along` 아규먼트를 지정하면 어레이를 새로운 차선을 따라 병합할 수도 있다.

```{r}
#| output: false
c(r, r, along = "new_dim")
# stars object with 4 dimensions and 1 attribute
# attribute(s), summary of first 1e+05 cells:
#              Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs.tif    47      65     76 77.3      87  255
# dimension(s):
#         from  to  offset delta            refsys point x/y
# x          1 349  288776  28.5 SIRGAS 2000 / ... FALSE [x]
# y          1 352 9120761 -28.5 SIRGAS 2000 / ... FALSE [y]
# band       1   6      NA    NA                NA    NA    
# new_dim    1   2      NA    NA                NA    NA
```

이의 사용 예시는 7.5.2절에서 설명된다.

### 포인트 샘플 추출하기, 애그리게이팅하기

래스터 데이터 큐브 분석의 매우 일반적인 사용 사례는 특정 위치에서 값을 추출하거나 특정 지오메트리에 대해 집계값을 계산하는 것이다. `st_extract` 함수는 포인트 값을 추출한다. 우리는 `r` 객체의 바운딩 박스 내의 몇 개의 무작위로 샘플링 포인트에 대해 이 오퍼레이션을 수행할 것이다.

```{r}
#| output: false
set.seed(115517)
pts <- st_bbox(r) |> st_as_sfc() |> st_sample(20)
(e <- st_extract(r, pts))
# stars object with 2 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs.tif    12    41.8     63   61    80.5  145
# dimension(s):
#          from to            refsys point
# geometry    1 20 SIRGAS 2000 / ...  TRUE
# band        1  6                NA    NA
#                                           values
# geometry POINT (293002 ...,...,POINT (290941 ...
# band                                        NULL
```

이것은 20개의 포인트와 6개의 밴드를 가진 벡터 데이터 큐브를 생성한다(시드를 설정하게 되면, 반복 실행에서 동일한 샘플의 사용이 보장된다. 따라서 포인트의 무작위 생성을 재실행하고자 하는 경우는 시드를 설정해서는 안된다).

데이터 큐브에서 정보를 추출하는 또 다른 방법은 집계값을 산출하는 것이다. 이를 수행하는 한 가지 방법은 공간 폴리곤 또는 라인에 의거해 값을 공간적으로 집계하는 것이다(6.4절 참조). 예를 들어, 그림 1.4(d)에 표시된 세 개의 원 각각에 대해 여섯 개 밴드의 최대 픽셀 값을 계산할 수 있다.

```{r}
#| output: false
circles <- st_sample(st_as_sfc(st_bbox(r)), 3) |>
    st_buffer(500)
aggregate(r, circles, max)
# stars object with 2 dimensions and 1 attribute
# attribute(s):
#              Min. 1st Qu. Median Mean 3rd Qu. Max.
# L7_ETMs.tif    73    94.2    117  121     142  205
# dimension(s):
#          from to            refsys point
# geometry    1  3 SIRGAS 2000 / ... FALSE
# band        1  6                NA    NA
#                                           values
# geometry POLYGON ((2913...,...,POLYGON ((2921...
# band                                        NULL
```

이는 세 개의 지오메트리와 여섯 개의 밴드를 가진 (벡터) 데이터 큐브를 생성한다. 시간 차원에 대한 집계값의 산출은 `aggregate` 함수의 두 번째 아규먼트로 시간 변수를 설정하여 수행된다. 시간 변수에 다음과 같은 것이 있을 수 있다.

-   시간 간격의 시작을 나타내는 타임 스탬프의 집합

-   `make_intervals` 함수로 정의된 시간 간격 집합

-   "주", "5일" 또는 "년"과 같은 시간 기간

### 예측 모델

R에서의 일반적인 모델 예측 워크플로우는 다음과 같다.

-   응답 변수와 예측 변수(공변량)가 포함된 `data.frame`의 사용

-   `data.frame`을 기반으로 모델 객체를 생성

-   모델 객체와 대상 예측 변수 값이 포함된 `data.frame`을 사용하여 `predict`를 호출

`stars` 패키지는 `stars` 객체에 대한 `predict` 메서드를 제공하며, 이는 본질적으로 위의 마지막 단계를 수행하는데, data.frame을 생성하고, `predict` 메서드를 호출한 후, 예측 값으로 `stars` 객체를 재구성한다.

이 과정을 설명하기 위해 Landsat 데이터셋에 위에서 추출한 샘플 포인트를 적용해 육지를 바다에서 분리하는 간단한 이진 클래스 예제를 사용할 것이다. 결과는 그림 7.7에 나타나 있다.

```{r}
#| echo: false
#| label: fig-7-7
#| fig-cap: "트레이닝 데이터로 사용되는 무작위 샘플 포인트: 빨간색은 해양부이고 노란색을 육지부이다."
plot(r[,,,1], reset = FALSE)
col <- rep("yellow", 20)
col[c(8, 14, 15, 18, 19)] = "red"
st_as_sf(e) |> st_coordinates() |> text(labels = 1:20, col = col)
```

이 그림에서 포인트 8, 14, 15, 18 및 19는 수부에 위치하고 있으며, 나머지는 육지부에 있다는 것을 "육안"으로 확인할 수 있다. 선형 판별("최대 우도") 분류기를 사용하여, 우리는 그림 7.8에 나타난 모델 예측 결과를 얻을 수 있다.

```{r}
#| output: false
rs <- split(r)
trn <- st_extract(rs, pts)
trn$cls <- rep("land", 20)
trn$cls[c(8, 14, 15, 18, 19)] <- "water"
model <- MASS::lda(cls ~ ., st_drop_geometry(trn))
pr <- predict(rs, model)
```

여기서 우리는 `MASS::` 접두사를 사용하여 **MASS** 패키지를 로드하지 않았으며, 이는 `dplyr`의 `select` 함수를 가리는 것을 방지하기 위함이다. `split` 단계는 밴드 차원을 속성으로 변환하여 예측 변수로 투입하기 위해 필요한 단계이다.

```{r}
#| echo: false
#| label: fig-7-8
#| fig-cap: "육지부/수부 구분을 위한 선형 판별 분류기로 그림 7.7의 트레이닝 데이터에 기반한 결과임."
plot(pr[1], key.pos = 4, key.width = lcm(3.5), key.length = lcm(2))
```

우리는 또한 그림 7.8에 플로팅된 레이어가 클래스 레이블을 가진 범주형 변수임을 알 수 있다.

### 래스터 데이터 플로팅

### 래스터 데이터 분석하기

### 곡선 래스터

### GOAL utils

## 벡터 데이터 큐브 사례

### 사례: 대기질 시계열 애그리게이팅하기

### 사례: 브리스톨 출발지-도착지 데이터 큐브

### 타이디 어레이 데이터

### 벡터 데이터 큐브를 위한 파일 포멧

## 래스터-투-벡터와 벡터-투-래스터

### 벡터-투-래스터

## 좌표변환 및 좌표전환

### 데이텀 그리드, proj.db, cdn.proj.org. 로컬 캐쉬

### 변환 파이프라인

### 축 순서와 방향

## 래스터 변환 및 워프

## 연습문제
